<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin入坑小结-HelloKotlin]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin%2F</url>
    <content type="text"><![CDATA[有困难要上，没困难制造困难也要上。 曾几何时，一觉醒来发现Kotlin成为了Android的官方语言，怎么又有新语言出来啊，WTF。 不管你看不看好Kotlin，这个时候还是需要了解一下，万一哪天突然改用Kotlin呢？其实现在北京很多大厂都开始使用Kotlin了。我问其中的一些朋友由Java转换成Kotlin困难不，他们却说3天，只要3天就可以转变过来。其实并不难，对于有一定编程能力的猿猿来说，读懂一门语言并不复杂，也很好上手。我用了下班之余的部分时间，看了几本书，总结了一下，算是一个读书笔记吧。 这个笔记包括三个部分： Kotlin基本语法 用Kotlin实现一个天气App 附录，一些不错的博客收集 第一部分 Kotlin基本语法第1章 第一个 Kotlin 程序第2章 Kotlin基础知识第3章 类和接口第4章 枚举类和扩展第5章 数据类与封闭类第6章 泛型第7章 对象和委托第8章 高阶函数与Lambda表达式第9章 函数第10章 其他Kotlin技术（1）第11章 其他Kotlin技术（2）第二部分 用Kotlin实现一个天气App所有笔记中的代码我都传到Github中了，地址是：HelloKotlin]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章 其他Kotlin技术(2)]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-11%2F</url>
    <content type="text"><![CDATA[11.1null值安全性在Kotlin中，类型系统明确区分可以指向null的引用和不可以指向null的引用。例如，一个通常的String变量不可以指向null。 123var s:String = null //编译错误，a不可为nullvar b:String = &quot;abc&quot;b = null //编译错误，b不可为null 要允许null值，我们可以将变量声明可为null的字符串类型：String?。 第二个方案是使用安全调用操作符:?。 123var b:String?=&quot;abc&quot;b = nullprintln(b?.length) //输出null 如果b不是null，这个表达式就会返回b.length，否则返回null。这个表达式本身的类型为Int?。 安全调用在链式调用的情况下非常有用，只要属性链中任何一个属性为null，整个表达式就会返回null。 Elvis表达式]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章 其他Kotlin技术（1）]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-10%2F</url>
    <content type="text"><![CDATA[10.1数据解构数据解构就是讲对象中的数据解析成相应的独立变量，也就是脱离原来的对象存在。 1data class Person(var name:String,var age:Int,var salary:Float) 这行代码是一个Person数据类，该数据类有3个参数，下面的代码要将这3个参数对应的属性值赋给相应的3个变量。 12345fun main(args: Array&lt;String&gt;) &#123; var person = Person(&quot;Bill&quot;,30,1200F) var(name,age,salary) = person println(&quot;name=$&#123;name&#125; age=$&#123;age&#125; salary=$&#123;salary&#125;&quot;)&#125; 运行结果： 1name=Bill age=30 salary=1200.0 如果想让一个函数返回多个值。并能解构这些值，也需要返回数据类对象。 12345fun deletePerson(id:Int):Person&#123; println(&quot;已经成功删除指定Person&quot;) var person = Person(&quot;Bill&quot;,30,1200F) return person&#125; 调用deletePerson函数，并解构其返回值的代码如下： 12var(name,age,salary) = deletePerson(20)println(&quot;name=$&#123;name&#125; age=$&#123;age&#125; salary=$&#123;salary&#125;&quot;) 有很多对象，可以保存一组值。例如Map。下面的代码创建MutableMap对象，并保存了两个key-value值对，然后通过for语句将其解构出来。 1234567var map = mutableMapOf&lt;Int,String&gt;() map.put(10,&quot;Bill&quot;) map.put(20,&quot;Mike&quot;) for ((key,value) in map)&#123; println(&quot;key=$&#123;key&#125; value=$&#123;value&#125;&quot;) &#125; 运行结果： 12key=10 value=Billkey=20 value=Mike 其中这些对象都是通过数据类实现的。例如，我们也可以自己来实现类似的功能。 12345678data class MyArrayItem(var key:Int,var value:String,var comment:String)fun valueArray():Collection&lt;MyArrayItem&gt;&#123; var result = arrayListOf&lt;MyArrayItem&gt;(MyArrayItem(20,&quot;A&quot;,&quot;Comment1&quot;), MyArrayItem(30,&quot;B&quot;,&quot;Comment2&quot;), MyArrayItem(40,&quot;C&quot;,&quot;Comment3&quot;)) return result&#125; 执行一下： 123for ((key,value,comment) in valueArray())&#123; println(&quot;key=$&#123;key&#125; value=$&#123;value&#125; comment=$&#123;comment&#125;&quot;) &#125; 运行结果： 123key=20 value=A comment=Comment1key=30 value=B comment=Comment2key=40 value=C comment=Comment3 10.2集合Kotlin标准库将集合分为可修改和不可修改的。不可修改的集合API包括List、Set、Map，可修改的集合的API包括MutableList、MutableSet、MutableMap等。这些API都是接口，而且他们都是Collection的子接口。 如果泛型用out声明，那么该泛型只能用于读操作。 下面是一些集合常用的方式： 123456789101112131415fun main(args: Array&lt;String&gt;) &#123; // 创建可读写的列表对象 val numbers:MutableList&lt;Int&gt; = mutableListOf(1,2,3) // 将读写列表变成字段列表 val readOnlyView:List&lt;Int&gt; = numbers // 输出[1,2,3] println(numbers) //向numbers添加一个新元素 numbers.add(4) // 输出[1,2,3,4] println(readOnlyView) //readOnlyView.clear()//编译出错，没有clear函数 &#125; 下面是一些常用的创建集合对象的函数。 listOf：用于创建List对象 setOf：用于创建Set对象 mapOf：用于创建Map对象 mutableListOf：用于创建mutable对象 mutableSetOf：用于创建mutableSetOf对象 mutableMapOf：用于创建mutableMapOf对象 对于可读写的集合，可以通过toXxx函数将其转换为只读的版本，其中Xxx是List、Set和Map。 12var mutableList:MutableList&lt;String&gt; = mutableListOf()var list:List&lt;String&gt; = mutableList.toList() 10.3值范围值范围表达式使用rangeTo函数实现，该函数的操作符形式是两个点（..），另外还有两个相关操作符in和!in。任何可比较大小的数据类型都可以定义值范围。 12345678var n = 20if (n in 1..100)&#123; println(&quot;满足要求&quot;)&#125;if (n !in 30..80)&#123; println(&quot;符合条件&quot;)&#125; 整数的值范围（IntRange、LongRange、CharRange）还有一种额外的功能，就是可以对这些值范围进行遍历。 123for (i in 1..10)&#123; println(i*i)&#125; 执行这段代码会输出1到100内的10个数。 如果按照倒序输出，只需要使用标准库中的downTo函数即可。 123for (i in 10 downTo 1)&#123; println(i*i)&#125; 如果要修改步长，就要使用step函数。 1234567for (i in 1..10 step 2)&#123; println(i*i)&#125;for(i in 10 downTo 1 step 3)&#123; println(i*i)&#125; 前面的代码中，使用的都是闭区间，1&lt;=i&lt;=10。如果要表示1&lt;=i&lt;10，需要使用until函数。 123for (i in 1 until 10)&#123; println(i)&#125; 10.4类型检查和类型转换is与!is操作符is操作符：在运行时检查一个对象与一个给定的类型是否一致。!is与之相反。 123456789101112131415var obj:Any = 456 var obj1 = 123 var obj2 = &quot;hello&quot; if(obj is String)&#123; println(&quot;obj是字符串&quot;) &#125; if (obj is Int)&#123; println(&quot;obj是Int类型&quot;) &#125; if (obj!is Int)&#123; println(&quot;obj不是Int类型&quot;) &#125; 如果is表达式满足条件，Kotlin编译器会自动转换is前面的对象到后面的数据类型，也就是说上面一个if语句中，obj已经是String类型了。 要注意的是，对象和is后面的类型要兼容，否则无法编译通过。 强制类型转换如果类型强制转换，而且类型不兼容，类型转换操作符通常会抛出一个异常。因此，我们称之为不安全的，在Kotlin中，不安全的类型转换使用中缀操作符as。 12var y:Any = &quot;abcd&quot;var x:Int = y as Int // abcd无法转换为数值，因此会抛出异常 注意：null不能被转换为String，因为这个类型不是可为null的。我们需要在类型转换操作符的右侧使用可为null的类型。 123var y:Any? = &quot;abcd&quot;var x:Int? = y as? Int // 转换错误，但不会抛出异常，x的值是nullprintln(x) // 输出null 10.5this表达式为了表示当前函数的接收者。可以使用this表达式。在类的成员函数中，this指向这个类的当前对象实例。在扩展函数中或者带接受者的函数字面值中，this代表调用函数时，在点号左侧传递的接收者参数。 如果this没有限定值，那么它指向包含当前代码的最内层范围，如果想要指向其他范围内的this，需要使用标签限定符。 为了访问更外层范围内的this，使用this@label，其中@label是一个标签，代表我们想要访问的this所属的范围。 12345678910111213141516171819class A&#123; inner class B&#123; fun Int.foo()&#123; var a = this@A //指向A的this var b = this@B var c = this // 指向foo()函数的接收者，一个Int值 var c1 = this@foo // 指向foo()函数的接收者，一个Int值 val finLit = lambda@ fun String.()&#123; val d = this // 指向funLit的接收者 &#125; val finLit2 = &#123; s : String -&gt; val d1 = this // 函数的接收者，因为包含当前代码的Lambda表达式没有接收者 &#125; &#125; &#125;&#125; 10.6相等判断在Kotlin中有两种相等判断。 引用相等，也即是两个引用指向同一个对象，使用”===”(以及他的相反操作!==) 结构相等，使用equals函数判断,使用”==”(以及他的相反操作!=)]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 函数]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-09%2F</url>
    <content type="text"><![CDATA[9.1函数基本用法12345678910// 函数的标准定义fun double(x:Int):Int&#123; return 2*x&#125;fun main(args:Array&lt;String&gt;)&#123; // 调用函数 double(3) println(double(4))&#125; 9.2使用中辍标记法调用函数中辍表达式：指将函数名称放到两个操作数中间。这两个操作数，左侧是包含函数的对象或值，右侧是函数的参数值。 满足中辍标记法调用的函数满足的条件： 成员函数或者扩展函数 只有一个参数 使用infix关键字声明函数 例子：字符串除法，就是去除分子字符中包含的所有分母字符串 12345/*字符串除法*/infix fun String.div(str:String):String&#123; // 将当前字符串中的所有str替换成&quot;&quot; return this.replace(str,&quot;&quot;)&#125; 一般方式调用: 12345fun main(args:Array&lt;String&gt;)&#123; /*一般方式调用*/ var str = &quot;hello world&quot; println(str.div(&quot;l&quot;))&#125; 运行结果： 1heo word 使用中辍表达式调用: 123456fun main(args:Array&lt;String&gt;)&#123; var str = &quot;hello world&quot; /*使用中辍表达式调用*/ println(str div &quot;l&quot;)&#125; 运行结果： 1heo word 中辍表达式可以连续使用: 123456fun main(args:Array&lt;String&gt;)&#123; var str = &quot;hello world&quot; /* 中辍表达式可以连续使用*/ println(str div &quot;l&quot; div &quot;o&quot;)&#125; 运行结果： 1he wrd 9.3单表达式函数如果一个函数的函数体只要一条语句，而且是return语句，那么可以省略函数体的大括号，以及return关键字。return后面的表达式可以直接写在函数声明的后面，用等号与函数声明分割。 1fun double1(x:Int):Int = x*2 如果Kotlin编译器能够推断出等号右侧的表达式类型，那么可以省略函数的返回值类型。 1fun double2(x:Int) = x*2 9.4函数参数和返回值可变参数：可以有任意多个参数 一个函数的一个参数（一般是最后一个参数）标记为vararg，这样可以作为可变参数处理。在函数内部，会按照数组来处理这些参数值。 asList功能是将一组值转换为List对象，并返回改对象： 123456fun &lt;T&gt; asList(vararg ts:T):List&lt;T&gt;&#123; var result= ArrayList&lt;T&gt;() for (t in ts) result.add(t) return result&#125; 调用asList函数： 1234fun main(args:Array&lt;String&gt;)&#123; var list = asList(1,2,&quot;a&quot;,4,5) println(list)&#125; 运行结果： 1[1, 2, a, 4, 5] 只有一个参数可以标记vararg，如果vararg参数不是函数的最后一个参数，那么对于vararg参数之后的其他参数可以使用命名参数来传递参数值。 例子：下面的asList2有3个参数，第1个是可变参数，后面两个value1和value2，由于最后一个参数不是可变参数，因此传递value1和value2参数的时候后需要使用命名参数。 1234567fun &lt;T&gt; asList2(vararg ts:T,value1:Int,value2:String):List&lt;T&gt;&#123; var result= ArrayList&lt;T&gt;() for (t in ts) result.add(t) println(&quot;value1=$&#123;value1&#125; value2=$&#123;value2&#125;&quot;) return result&#125; 调用asList2函数： 1234fun main(args:Array&lt;String&gt;)&#123; var list2 = asList2(1,2,&quot;a&quot;,value1 = 4,value2 = &quot;5&quot;) println(list2)&#125; 运行结果： 12value1=4 value2=5[1, 2, a] 如果我们已经有了一个数组，将数组的内容传递给asList函数，可以使用展开操作符，在数组之前加* 123456fun main(args:Array&lt;String&gt;)&#123; val a = arrayOf(1,2,3) var list = asList(-1,0,*a,4,5) println(list)&#125; 运行结果： 1[-1, 0, 1, 2, 3, 4, 5] 返回值类型： 如果函数体为多行语句组成的代码段，那么就必须明确返回值类型，除非这个函数不返回任何值（Unit），对于多行语句的函数，Kotlin不会推断其返回值类型。 9.5函数的范围在Kotlin中，函数可以定义在源代码的顶级范围内，这就意味着可以不必像java中创建一个类来容纳函数。除顶级函数外，kotlin函数还可以定义为局部函数、成员函数和扩展函数。 局部函数kotlin支持局部函数，就是嵌套在另一个函数内的函数 12345678fun saveFile()&#123; fun getFullName(fn:String):String&#123; return &quot;/user/$&#123;fn&#125;&quot; &#125; var fileName = getFullName(&quot;test.txt&quot;) println(&quot;$&#123;fileName&#125;已经保存成功&quot;)&#125; 调用saveFile 123fun main(args: Array&lt;String&gt;) &#123; saveFile()&#125; 运行结果： 1/user/test.txt已经保存成功 局部函数可以访问外部函数的局部变量，例子如下： 123456789fun saveFile2()&#123; var fn = &quot;text.txt&quot; fun getFullName():String&#123; return &quot;/user/$&#123;fn&#125;&quot; &#125; var fileName = getFullName() println(&quot;$&#123;fileName&#125;已经保存成功&quot;)&#125; 调用saveFile2运行结果： 1/user/test.txt已经保存成功 成员函数成员函数是指定义在类或者对象内的函数 123456class Sample()&#123; //成员函数 fun foo()&#123; println(&quot;foo&quot;) &#125;&#125; 对成员函数的调用使用点号标记法 1234fun main(args: Array&lt;String&gt;) &#123; // 创建Sample实例，并调用foo方法 Sample().foo()&#125; 运行结果： 1foo 9.6泛型函数函数可以带泛型参数，泛型参数通过函数名前的尖括号指定 123fun &lt;T&gt; SingletionList(item:T):List&lt;T&gt;&#123; //……&#125; 9.7内联函数要想让函数支持内联，需要在定义函数时使用inline关键字。 未使用inline关键字 1234567fun processProduct(area:(name:String)-&gt;String):String&#123; return area(&quot;iphone&quot;)&#125;fun main(args: Array&lt;String&gt;) &#123; println(processProduct &#123; name -&gt; &quot;$&#123;name&#125; 美国&quot; &#125;)&#125; 运行结果： 1iphone 美国 使用inline关键字 123inline fun processProduct2(area:(name:String)-&gt;String):String&#123; return area(&quot;iphone&quot;)&#125; 内联部分Lambda表达式 如果一个需要内联的函数，多个参数都是函数类型，使用inline后，会将所有的Lambda表达式的参数值都内联进当前函数。如果参数前面加了noinline，那么即使函数加了inline，这个参数也不会内联进调用函数。 123inline fun processProduct3(area1:(name:String)-&gt;String,noinline area2:(name:String)-&gt;String):String&#123; return area1(&quot;iphone&quot;) +&quot; &quot;+ area2(&quot;埃菲尔铁塔&quot;)&#125; 运行结果： 1iphone 美国 埃菲尔铁塔 法国]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 高阶函数与Lambda表达式]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-08%2F</url>
    <content type="text"><![CDATA[8.1 高阶函数高阶函数是一种特殊的函数，它接受函数作为函数，或者返回一个函数。在下面的例子中，processProduct是一个高阶函数，该函数的第1个参数是一个对象（Product类型），第2个参数是一个函数类型。这个函数类型需要传递一个name参数（String类型），并返回一个String类型。processProduct函数会通过第2个参数area为产品添加产地。 1234567891011121314151617181920212223242526272829303132333435interface Product&#123; var area:String fun sell(name:String)&#125;class MobilePhone:Product&#123; override var area: String = &quot;&quot; override fun sell(name: String) &#123; println(&quot;销售$&#123;name&#125;&quot;) &#125; override fun toString(): String &#123; return area &#125;&#125;fun mobilePhoneArea(name: String):String&#123; return &quot;$&#123;name&#125; 美国&quot;&#125;fun processProduct(product: Product,area:(name:String)-&gt;String):Product&#123; //调用第二个参数指定的函数 product.area = area(&quot;iphone&quot;) return product&#125;fun main(args: Array&lt;String&gt;) &#123; var product = MobilePhone() //将函数作为函数值传入高阶函数，需要在函数名前加两个冒号，作为标记 processProduct(product,::mobilePhoneArea) println(product)&#125; 运行结果： 1iphone 美国 8.2 Lambda表达式与匿名函数Lambda表达式，或者称为匿名函数，是一种”函数字面值“，也就是一个没有声明的函数，但是可以作为表达式传递出去。 1max(strings,&#123;a,b-&gt;a.length &lt; b.length&#125;) 函数max是一个高阶函数，也就是说，它接受一个函数值作为第二个参数。第二个参数是一个表达式，本身又是另一个函数，也就是说，它是一个函数字面量。作为函数等价于下面的代码： 1fun compare(a:String,b:String):Boolean = a.length&lt;b.length 函数类型对于接受另一个函数作为自己参数的函数，我们必须针对这个参数指定一个函数类型。 1234567fun &lt;T&gt; max(collection: Collection&lt;T&gt;,less:(T,T) -&gt; Boolean):T?&#123; var max:T? = null for (it in collection) if (max == null || less(max,it)) max = it return max&#125; 参数less的类型是(T,T) -&gt; Boolean，也就是说，它是一个函数，接受两个T类型参数，并且返回一个Boolean类型结果。 Lambda表达式的语法Lambda表达式的完整语法形式，也就是函数类型的字面值，如下： 1val sum = &#123;x:Int,y:Int -&gt; x+y&#125; Lambda表达式包含在大括号之内，在完整语法形式中，参数声明在小括号内，参数类型的声明可选，函数体在-&gt;之后。如果Lambda表达式自动推断返回值类型不是Unit，那么在Lambda表达式函数体中，最后一条表达式的值会被当作整个Lambda表达式的返回值。 如果我们把所有可选内容去掉，那么剩余的部分如下： 1val sum2 :(Int,Int) -&gt;Int = &#123;x,y-&gt;x+y&#125; 很多情况下，Lambda表达式只有唯一一个参数，如果Kotlin能够自行判断出Lambda表达式的参数定义，那么它将允许我们省略唯一一个参数的定义（”-&gt;”也可以一同省略），并且会为我们隐含的定义这个参数，使用能够函数名为it，例如，8.1节调用processProduct函数的代码可以改成如下： 123processProduct(product)&#123; &quot;$&#123;it&#125;美国&quot;&#125; 如果使用带标签限定的return语句，那么可以在Lambda表达式内明确的返回一个结果值。否则，会隐含的返回Lambda表达式内最后一条表达式的值。 123processProduct2(product)&#123; return &quot;$&#123;it&#125;美国&quot;&#125; 匿名函数123fun main(args: Array&lt;String&gt;) &#123; fun(x:Int,y:Int):Int = x+y&#125; 匿名函数省略了函数名，函数体可以是一个表达式，也可以是多条语句组成的代码段： 12345fun main(args: Array&lt;String&gt;) &#123; fun(x:Int,y:Int):Int&#123; return x+y &#125;&#125; 参数和返回值类型的声明与通常的函数一样，但如果参数类型可以通过上下文推断得到，那么类型声明可以省略。 123fun main(args: Array&lt;String&gt;) &#123; ints.filter(fun(item) = item&gt;0)&#125; 对于匿名函数，返回值类型的自动推断方式与通常的函数一样：如果函数体是一个表达式，那么返回值类型可以自动推断得到；如果函数体是多条语句组成的代码段，则返回值类型必须明确指出，否则认为是（Unit） 注意：匿名函数参数一定要在小括号内传递。允许将函数类型参数写在小括号之外的语法，仅对Lambda表达式有效。 闭包Lambda表达式、匿名函数可以访问他/她的闭包，也就是定义在外层范围中的变量。与Java不同，闭包中捕获的变量是可以修改的。 1234567fun main(args: Array&lt;String&gt;) &#123; var sum = 0 ints.filter&#123;it&gt;0&#125;.forEach&#123; sum+=it &#125; println(sum)&#125;]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 对象和委托]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-07%2F</url>
    <content type="text"><![CDATA[7.1 Kotlin 对象表达式和对象声明Kotlin 用对象表达式和对象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类。 对象表达式通过对象表达式实现一个匿名内部类的对象用于方法的参数中： 12345678window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // ... &#125; override fun mouseEntered(e: MouseEvent) &#123; // ... &#125;&#125;) 对象可以继承于某个基类，或者实现其他接口: 123456789open class A(x: Int) &#123; public open val y: Int = x&#125;interface B &#123;……&#125;val ab: A = object : A(1), B &#123; override val y = 15&#125; 如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔。 通过对象表达式可以越过类的定义直接得到一个对象： 12345678fun main(args: Array&lt;String&gt;) &#123; val site = object &#123; var name: String = &quot;石嘉成的博客&quot; var url: String = &quot;www.shijiacheng.studio&quot; &#125; println(site.name) println(site.url)&#125; 请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。 12345678910111213141516class C &#123; // 私有函数，所以其返回类型是匿名对象类型 private fun foo() = object &#123; val x: String = &quot;x&quot; &#125; // 公有函数，所以其返回类型是 Any fun publicFoo() = object &#123; val x: String = &quot;x&quot; &#125; fun bar() &#123; val x1 = foo().x // 没问题 val x2 = publicFoo().x // 错误：未能解析的引用“x” &#125;&#125; 在对象表达中可以方便的访问到作用域中的其他变量: 123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ……&#125; 对象声明Kotlin 使用 object 关键字来声明一个对象。 Kotlin 中我们可以方便的通过对象声明来获得一个单例。 12345678object DataProviderManager &#123; fun registerDataProvider(provider: DataProvider) &#123; // …… &#125; val allDataProviders: Collection&lt;DataProvider&gt; get() = // ……&#125; 引用该对象，我们直接使用其名称即可： 1DataProviderManager.registerDataProvider(……) 当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。 1234var data1 = DataProviderManagervar data2 = DataProviderManagerdata1.name = &quot;test&quot;print(&quot;data1 name = $&#123;data2.name&#125;&quot;) 实例 以下实例中，两个对象都输出了同一个 url 地址： 1234567891011object Site &#123; var url:String = &quot;&quot; val name: String = &quot;石嘉成的博客&quot;&#125;fun main(args: Array&lt;String&gt;) &#123; var s1 = Site var s2 = Site s1.url = &quot;www.shijiacheng.studio&quot; println(s1.url) println(s2.url)&#125; 输出结果为: 12www.shijiacheng.studiowww.shijiacheng.studio 对象可以有超类型： 123456789object DefaultListener : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // …… &#125; override fun mouseEntered(e: MouseEvent) &#123; // …… &#125;&#125; 与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。 1234567891011121314class Site &#123; var name = &quot;石嘉成的博客&quot; object DeskTop&#123; var url = &quot;www.shijiacheng.studio&quot; fun showName()&#123; print&#123;&quot;desk legs $name&quot;&#125; // 错误，不能访问到外部类的方法和变量 &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var site = Site() site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象 Site.DeskTop.url // 正确&#125; 伴生对象类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。 1234567class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125;val instance = MyClass.create() // 访问到对象的内部元素 我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名： 123456class MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 注意：一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。 请伴生对象的成员看起来像其他语言的静态成员，但在运行时他们仍然是真实对象的实例成员。例如还可以实现接口： 12345678910interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125; 对象表达式和对象声明之间的语义差异对象表达式和对象声明之间有一个重要的语义差别： 对象表达式是在使用他们的地方立即执行的 对象声明是在第一次被访问到时延迟初始化的 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配 7.2 kotlin 委托委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。 Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。 类委托类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。 以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。 1234567891011121314151617// 创建接口interface Base &#123; fun print()&#125;// 实现此接口的被委托的类class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;// 通过关键字 by 建立委托类class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) Derived(b).print() // 输出 10&#125; 在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。 属性委托属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。 属性委托语法格式： 1val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt; var/val：属性类型(可变/只读) 属性名：属性名称 类型：属性的数据类型 表达式：委托代理类 by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。 定义一个被委托的类该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。 1234567891011121314151617181920212223import kotlin.reflect.KProperty// 定义包含属性委托的类class Example &#123; var p: String by Delegate()&#125;// 委托的类class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot; &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println(&quot;$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val e = Example() println(e.p) // 访问该属性，调用 getValue() 函数 e.p = &quot;Shijiacheng&quot; // 调用 setValue() 函数 println(e.p)&#125; 输出结果为： 123Example@433c675d, 这里委托了 p 属性Example@433c675d 的 p 属性赋值为 ShijiachengExample@433c675d, 这里委托了 p 属性 标准委托Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。 延迟属性 Lazylazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。 123456789val lazyValue: String by lazy &#123; println(&quot;computed!&quot;) // 第一次调用输出，第二次调用不执行 &quot;Hello&quot;&#125;fun main(args: Array&lt;String&gt;) &#123; println(lazyValue) // 第一次执行，执行两次输出表达式 println(lazyValue) // 第二次执行，只输出返回值&#125; 执行输出结果： 123computed!HelloHello 可观察属性 Observableobservable 可以用于实现观察者模式。 Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。 在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值： 1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable(&quot;初始值&quot;) &#123; prop, old, new -&gt; println(&quot;旧值：$old -&gt; 新值：$new&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = &quot;第一次赋值&quot; user.name = &quot;第二次赋值&quot;&#125; 执行输出结果： 12旧值：初始值 -&gt; 新值：第一次赋值旧值：第一次赋值 -&gt; 新值：第二次赋值 把属性储存在映射中一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他”动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。 12345678910111213141516class Site(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val url: String by map&#125;fun main(args: Array&lt;String&gt;) &#123; // 构造函数接受一个映射参数 val site = Site(mapOf( &quot;name&quot; to &quot;石嘉成的博客&quot;, &quot;url&quot; to &quot;www.shijiacheng.studio&quot; )) // 读取映射值 println(site.name) println(site.url)&#125; 执行输出结果： 12石嘉成的博客www.shijiacheng.studio 如果使用 var 属性，需要把 Map 换成 MutableMap： 12345678910111213141516171819202122232425class Site(val map: MutableMap&lt;String, Any?&gt;) &#123; val name: String by map val url: String by map&#125;fun main(args: Array&lt;String&gt;) &#123; var map:MutableMap&lt;String, Any?&gt; = mutableMapOf( &quot;name&quot; to &quot;石嘉成的博客&quot;, &quot;url&quot; to &quot;www.shijiacheng.studio&quot; ) val site = Site(map) println(site.name) println(site.url) println(&quot;--------------&quot;) map.put(&quot;name&quot;, &quot;Google&quot;) map.put(&quot;url&quot;, &quot;www.google.com&quot;) println(site.name) println(site.url)&#125; 执行输出结果： 12345石嘉成的博客www.shijiacheng.studio--------------Googlewww.google.com Not NullnotNull 适用于那些无法在初始化阶段就确定属性值的场合。 123456class Foo &#123; var notNullBar: String by Delegates.notNull&lt;String&gt;()&#125;foo.notNullBar = &quot;bar&quot;println(foo.notNullBar) 需要注意，如果属性在赋值前就被访问的话则会抛出异常。 局部委托属性你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化： 1234567fun example(computeFoo: () -&gt; Foo) &#123; val memoizedFoo by lazy(computeFoo) if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123; memoizedFoo.doSomething() &#125;&#125; memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。 属性委托要求对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数： thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型 property —— 必须是类型 KProperty&lt;*&gt; 或其超类型 这个函数必须返回与属性相同的类型（或其子类型）。 对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数: 翻译规则在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性： 1234567891011class C &#123; var prop: Type by MyDelegate()&#125;// 这段是由编译器生成的相应代码：class C &#123; private val prop$delegate = MyDelegate() var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)&#125; Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。 提供委托通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。 provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。 例如，如果要在绑定之前检查属性名称，可以这样写： 123456789101112131415161718class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123; operator fun provideDelegate( thisRef: MyUI, prop: KProperty&lt;*&gt; ): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(thisRef, prop.name) // 创建委托 &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;&#125;fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;class MyUI &#123; val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id)&#125; provideDelegate 的参数与 getValue 相同： thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型 property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。 如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便： 12345678910111213// 检查属性名称而不使用“provideDelegate”功能class MyUI &#123; val image by bindResource(ResourceID.image_id, &quot;image&quot;) val text by bindResource(ResourceID.text_id, &quot;text&quot;)&#125;fun &lt;T&gt; MyUI.bindResource( id: ResourceID&lt;T&gt;, propertyName: String): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(this, propertyName) // 创建委托&#125; 在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码： 123456789101112class C &#123; var prop: Type by MyDelegate()&#125;// 这段代码是当“provideDelegate”功能可用时// 由编译器生成的代码：class C &#123; // 调用“provideDelegate”来创建额外的“delegate”属性 private val prop$delegate = MyDelegate().provideDelegate(this, this::prop) val prop: Type get() = prop$delegate.getValue(this, this::prop)&#125; 请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 泛型]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-06%2F</url>
    <content type="text"><![CDATA[Kotlin 泛型泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。 与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。 声明一个泛型类: 123class Box&lt;T&gt;(t: T) &#123; var value = t&#125; 创建类的实例时我们需要指定类型参数: 123val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)// 或者val box = Box(1) // 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。 以下实例向泛型类 Box 传入整型数据和字符串： 1234567891011class Box&lt;T&gt;(t : T) &#123; var value = t&#125;fun main(args: Array&lt;String&gt;) &#123; var boxInt = Box&lt;Int&gt;(10) var boxString = Box&lt;String&gt;(&quot;Shijiacheng&quot;) println(boxInt.value) println(boxString.value)&#125; 输出结果为： 1210Shijiacheng 定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。 Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面： 12345fun &lt;T&gt; boxIn(value: T) = Box(value)// 以下都是合法语句val box4 = boxIn&lt;Int&gt;(1)val box5 = boxIn(1) // 编译器会进行类型推断 在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。 以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理： 123456789101112131415161718fun main(args: Array&lt;String&gt;) &#123; val age = 23 val name = &quot;runoob&quot; val bool = true doPrintln(age) // 整型 doPrintln(name) // 字符串 doPrintln(bool) // 布尔型&#125;fun &lt;T&gt; doPrintln(content: T) &#123; when (content) &#123; is Int -&gt; println(&quot;整型数字为 $content&quot;) is String -&gt; println(&quot;字符串转换为大写：$&#123;content.toUpperCase()&#125;&quot;) else -&gt; println(&quot;T 不是整型，也不是字符串&quot;) &#125;&#125; 输出结果为： 123整型数字为 23字符串转换为大写：RUNOOBT 不是整型，也不是字符串 泛型约束我们可以使用泛型约束来设定一个给定参数允许使用的类型。 Kotlin 中使用 : 对泛型的的类型上限进行约束。 最常见的约束是上界(upper bound)： 123fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123; // ……&#125; Comparable 的子类型可以替代 T。 例如: 12sort(listOf(1, 2, 3)) // OK。Int 是 Comparable&lt;Int&gt; 的子类型sort(listOf(HashMap&lt;Int, String&gt;())) // 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型 默认的上界是 Any?。 对于多个上界约束条件，可以用 where 子句： 12345fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt; where T : CharSequence, T : Comparable&lt;T&gt; &#123; return list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;&#125; 型变Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。 声明处型变声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。 使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型： 12345678910111213// 定义一个支持协变的类class Runoob&lt;out A&gt;(val a: A) &#123; fun foo(): A &#123; return a &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var strCo: Runoob&lt;String&gt; = Runoob(&quot;a&quot;) var anyCo: Runoob&lt;Any&gt; = Runoob&lt;Any&gt;(&quot;b&quot;) anyCo = strCo println(anyCo.foo()) // 输出 a&#125; in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型： 1234567891011// 定义一个支持逆变的类class Runoob&lt;in A&gt;(a: A) &#123; fun foo(a: A) &#123; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var strDCo = Runoob(&quot;a&quot;) var anyDCo = Runoob&lt;Any&gt;(&quot;b&quot;) strDCo = anyDCo&#125; 星号投射有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓”安全地使用”是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。 对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection): 假如类型定义为 Foo , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo&lt;&gt; 等价于 Foo . 它表示, 当 T 未知时, 你可以安全地从 Foo&lt;&gt; 中 读取TUpper 类型的值. 假如类型定义为 Foo , 其中 T 是一个反向协变的类型参数, Foo&lt;&gt; 等价于 Foo . 它表示, 当 T 未知时, 你不能安全地向 Foo&lt;&gt; 写入 任何东西. 假如类型定义为 Foo , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo&lt;*&gt; 等价于 Foo , 对于写入值的场合, 等价于 Foo . 如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function , 那么可以出现以下几种星号投射: Function&lt;*, String&gt; , 代表 Function ; Function , 代表 Function ; Function&lt;, &gt; , 代表 Function . 注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 数据类与封闭类]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-05%2F</url>
    <content type="text"><![CDATA[5.1 数据类Kotlin 可以创建一个只包含数据的类，关键字为 data： 1data class User(val name: String, val age: Int) 编译器会自动的从主构造函数中根据所有声明的属性提取以下函数： equals() / hashCode() toString() 格式如 &quot;User(name=John, age=42)&quot; componentN() functions 对应于属性，按声明顺序排列 copy() 函数 如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。 为了保证生成代码的一致性以及有意义，数据类需要满足以下条件： 主构造函数至少包含一个参数。 所有的主构造函数的参数必须标识为val 或者 var ; 数据类不可以声明为 abstract, open, sealed 或者 inner; 数据类不能继承其他类 (但是可以实现接口)。 1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 复制复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样： 1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 实例 使用 copy 类复制 User 数据类，并修改 age 属性: 12345678910data class User(val name: String, val age: Int)fun main(args: Array&lt;String&gt;) &#123; val jack = User(name = &quot;Jack&quot;, age = 1) val olderJack = jack.copy(age = 2) println(jack) println(olderJack)&#125; 输出结果为： 12User(name=Jack, age=1)User(name=Jack, age=2) 数据类以及解构声明组件函数允许数据类在解构声明中使用： 123val jane = User(&quot;Jane&quot;, 35)val (name, age) = janeprintln(&quot;$name, $age years of age&quot;) // prints &quot;Jane, 35 years of age&quot; 标准数据类标准库提供了 Pair 和 Triple 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。 5.2 封闭类封闭类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而封闭类 的一个子类可以有可包含状态的多个实例。 声明一个封闭类，使用 sealed 修饰类，封闭类可以有子类，但是所有的子类都必须要内嵌在封闭类中。 sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误) 12345678910sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr()fun eval(expr: Expr): Double = when (expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN&#125;]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 枚举类和扩展]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-04%2F</url>
    <content type="text"><![CDATA[4.1 Kotlin 枚举类枚举类最基本的用法是实现一个类型安全的枚举。 枚举常量用逗号分隔,每个枚举常量都是一个对象。 123enum class Color&#123; RED,BLACK,BLUE,GREEN,WHITE&#125; 枚举初始化每一个枚举都是枚举类的实例，它们可以被初始化： 12345enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125; 默认名称为枚举字符名，值从0开始。若需要指定值，则可以使用其构造函数： 1234enum class Shape(value:Int)&#123; ovel(100), rectangle(200)&#125; 枚举还支持以声明自己的匿名类及相应的方法、以及覆盖基类的方法。如： 1234567891011enum class ProtocolState &#123; WAITING &#123; override fun signal() = TALKING &#125;, TALKING &#123; override fun signal() = WAITING &#125;; abstract fun signal(): ProtocolState&#125; 如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开 使用枚举常量Kotlin 中的枚举类具有合成方法，允许遍历定义的枚举常量，并通过其名称获取枚举常数。 12EnumClass.valueOf(value: String): EnumClass // 转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentExceptionEnumClass.values(): Array&lt;EnumClass&gt; // 以数组的形式，返回枚举值 获取枚举相关信息： 12val name: String //获取枚举名称val ordinal: Int //获取枚举值在所有枚举数组中定义的顺序 实例 12345678910111213enum class Color&#123; RED,BLACK,BLUE,GREEN,WHITE&#125;fun main(args: Array&lt;String&gt;) &#123; var color:Color=Color.BLUE println(Color.values()) println(Color.valueOf(&quot;RED&quot;)) println(color.name) println(color.ordinal)&#125; 自 Kotlin 1.1 起，可以使用 enumValues&lt;T&gt;() 和 enumValueOf&lt;T&gt;() 函数以泛型的方式访问枚举类中的常量 ： 1234567891011enum class RGB &#123; RED, GREEN, BLUE &#125;inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123; print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)&#125;fun main(args: Array&lt;String&gt;) &#123; printAllValues&lt;RGB&gt;() // 输出 RED, GREEN, BLUE&#125; 4.2 Kotlin 扩展Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。 扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。 扩展函数扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式： 123fun receiverType.functionName(params)&#123; body&#125; receiverType：表示函数的接收者，也就是函数扩展的对象 functionName：扩展函数的名称 params：扩展函数的参数，可以为NULL 以下实例扩展 User 类 ： 1234567891011class User(var name:String)/**扩展函数**/fun User.Print()&#123; print(&quot;用户名 $name&quot;)&#125;fun main(arg:Array&lt;String&gt;)&#123; var user = User(&quot;Shijiacheng&quot;) user.Print()&#125; 实例执行输出结果为： 1用户名 Shijiacheng 下面代码为 MutableList 添加一个swap 函数： 123456789101112131415// 扩展函数 swap,调换不同位置的值fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // this 对应该列表 this[index1] = this[index2] this[index2] = tmp&#125;fun main(args: Array&lt;String&gt;) &#123; val l = mutableListOf(1, 2, 3) // 位置 0 和 2 的值做了互换 l.swap(0, 2) // &apos;swap()&apos; 函数内的 &apos;this&apos; 将指向 &apos;l&apos; 的值 println(l.toString())&#125; 实例执行输出结果为： 1[3, 2, 1] this关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。 扩展函数是静态解析的扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的: 123456789101112131415open class Cclass D: C()fun C.foo() = &quot;c&quot; // 扩展函数 foofun D.foo() = &quot;d&quot; // 扩展函数 foofun printFoo(c: C) &#123; println(c.foo()) // 类型是 C 类&#125;fun main(arg:Array&lt;String&gt;)&#123; printFoo(D())&#125; 实例执行输出结果为： 1c 若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。 12345678910class C &#123; fun foo() &#123; println(&quot;成员函数&quot;) &#125;&#125;fun C.foo() &#123; println(&quot;扩展函数&quot;) &#125;fun main(arg:Array&lt;String&gt;)&#123; var c = C() c.foo()&#125; 实例执行输出结果为： 1成员函数 扩展一个空对象在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如: 12345678910fun Any?.toString(): String &#123; if (this == null) return &quot;null&quot; // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()&#125;fun main(arg:Array&lt;String&gt;)&#123; var t = null println(t.toString())&#125; 实例执行输出结果为： 1null 扩展属性除了函数，Kotlin 也支持属性对属性进行扩展: 12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。 1val Foo.bar = 1 // 错误：扩展属性不能有初始化器 扩展属性只能被声明为 val。 伴生对象的扩展如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。 伴生对象通过”类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用： 123456789101112131415class MyClass &#123; companion object &#123; &#125; // 将被称为 &quot;Companion&quot;&#125;fun MyClass.Companion.foo() &#123; println(&quot;伴随对象的扩展函数&quot;)&#125;val MyClass.Companion.no: Int get() = 10fun main(args: Array&lt;String&gt;) &#123; println(&quot;no:$&#123;MyClass.no&#125;&quot;) MyClass.foo()&#125; 实例执行输出结果为： 12no:10伴随对象的扩展函数 扩展的作用域通常扩展函数或属性定义在顶级包下: 123package foo.barfun Baz.goo() &#123; …… &#125; 要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用: 123456789package com.example.usageimport foo.bar.goo // 导入所有名为 goo 的扩展 // 或者import foo.bar.* // 从 foo.bar 导入一切fun usage(baz: Baz) &#123; baz.goo()&#125; 扩展声明为成员在一个类内部你可以为另一个类声明扩展。 在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。 1234567891011121314151617181920212223class D &#123; fun bar() &#123; println(&quot;D bar&quot;) &#125;&#125;class C &#123; fun baz() &#123; println(&quot;C baz&quot;) &#125; fun D.foo() &#123; bar() // 调用 D.bar baz() // 调用 C.baz &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c: C = C() val d: D = D() c.caller(d)&#125; 实例执行输出结果为： 12D barC baz 在 C 类内，创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。 假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。 1234567891011121314151617181920212223class D &#123; fun bar() &#123; println(&quot;D bar&quot;) &#125;&#125;class C &#123; fun bar() &#123; println(&quot;C bar&quot;) &#125; // 与 D 类 的 bar 同名 fun D.foo() &#123; bar() // 调用 D.bar()，扩展接收者优先 this@C.bar() // 调用 C.bar() &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c: C = C() val d: D = D() c.caller(d)&#125; 实例执行输出结果为： 12D barC bar 以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的。 12345678910111213141516171819202122232425262728293031323334353637open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println(&quot;D.foo in C&quot;) &#125; open fun D1.foo() &#123; println(&quot;D1.foo in C&quot;) &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println(&quot;D.foo in C1&quot;) &#125; override fun D1.foo() &#123; println(&quot;D1.foo in C1&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; C().caller(D()) // 输出 &quot;D.foo in C&quot; C1().caller(D()) // 输出 &quot;D.foo in C1&quot; —— 分发接收者虚拟解析 C().caller(D1()) // 输出 &quot;D.foo in C&quot; —— 扩展接收者静态解析&#125; 实例执行输出结果为： 123D.foo in CD.foo in C1D.foo in C]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 类和接口]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-03%2F</url>
    <content type="text"><![CDATA[3.1类的声明和Java一样，类的声明使用class关键字，如果声明一个空类，Kotlin和Java没有任何区别。 123class MyClass&#123;&#125; 3.2构造器类允许定义一个主构造器和若干个第二构造器。 主构造器主构造器是类头的一部分，紧跟在类名后面，构造器参数是可选的。 123class Person constructor(firstName:String)&#123;&#125; 如果主构造器没有任何注释和修饰器，constructor关键字可省略 123class Person (firstName:String)&#123;&#125; 主构造器需要在init块中进行初始化，在init块中可以直接使用主构造器的参数。 12345class Person (firstName:String)&#123; init &#123; println(firstName) &#125;&#125; 主构造器的参数不仅可以用在init块中，还可以用于对类属性进行初始化。 123456class Person (firstName:String)&#123; var name = firstName init &#123; println(firstName) &#125;&#125; 注意：即使在构造器内部使用var声明变量，修改参数变量值后，并不会把修改的值传到对象外部。 第二构造器Kotlin可以声明若干个第二构造器。第二构造器需要在类中声明，前面必须要加constructor关键字。 如果类中声明了主构造器，那么所有的第二构造器都需要在声明后面调用主构造器，或者通过另外一个第二构造器间接地调用主构造器。 123456789101112131415161718192021class QACommunity(var url:String)&#123; //主构造器实现 init &#123; println(url) &#125; // 第二构造器（通过this直接调用了主构造器） constructor(value:Int):this(&quot;shijiacheng.studio&quot;)&#123; println(value) &#125; // 第二构造器（通过this直接调用了主构造器） constructor(desc:String,url: String):this(&quot;(&quot;+url+&quot;)&quot;)&#123; println(desc+&quot;:&quot;+url) &#125; // 第二构造器（通过this调用了第二构造器，间接的调用了主构造器） constructor():this(20)&#123; println(&quot;&lt;http://shijiacheng.studio&gt;&quot;) &#125;&#125; 调用QACommunity类的每个构造器： 12345678910fun main(args: Array&lt;String&gt;) &#123; println(&quot;*****第1个*****&quot;) QACommunity(&quot;http://shijiacheng.studio&quot;) println(&quot;*****第2个*****&quot;) QACommunity(20) println(&quot;*****第3个*****&quot;) QACommunity(&quot;我的博客&quot;,&quot;http://shijiacheng.studio&quot;) println(&quot;*****第4个*****&quot;) QACommunity()&#125; 运行结果： 123456789101112*****第1个*****http://shijiacheng.studio*****第2个*****shijiacheng.studio20*****第3个*****(http://shijiacheng.studio)我的博客:http://shijiacheng.studio*****第4个*****shijiacheng.studio20&lt;http://shijiacheng.studio&gt; 注意：在主构造器参数中可以使用可以使用var和val，但在第二构造器参数中不能使用var和val。这就意味着第二构造器的参数都是只读的，不能在构造器内部改变参数的值。 Kotlin中的Singleton模式1234567891011121314class Singleton private constructor() &#123; public var value: Singleton? = null private object mHolder &#123; val INSTANCE = Singleton() &#125; companion object Factory &#123; fun getInstance(): Singleton &#123; return mHolder.INSTANCE &#125; &#125;&#125; 执行下面代码，访问Singleton类： 1234567fun main(args: Array&lt;String&gt;) &#123; var obj1 = Singleton.getInstance() var obj2 = Singleton.getInstance() println(obj1) println(obj2)&#125; 运行结果： 12com.shijc.hellokotlin.unit03.Singleton@355da254com.shijc.hellokotlin.unit03.Singleton@355da254 执行这段代码后，会输出如下内容，我们会发现。obj1和obj2的输出结果完全一样。这就证明了obj1和obj2是完全一样的。 Kotlin函数中的默认参数Kotlin函数支持默认参数，例子： 123class Customer(var customerName:String = &quot;Bill&quot;,var value: Float = 20.4F)&#123;&#125; 如果创建Customer的实例，可以直接使用Customer()。customerName和value的参数值就会使用Bill和20.4。 创建类的实例在Kotlin中创建类的实例不需要使用new关键字。因此，调用函数和创建类的实例在语法上没有区别。只能通过上下文来区分。 3.3类成员属性的基本用法123var/val &lt;propertyName&gt;[:&lt;propertyType&gt;][=&lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 在属性语法中，只有var/val和propertyName(属性名)是必须的，其他都是可选的。如果要引用属性，就行引用变量一样。 12345678910class Customer2&#123; var name:String = &quot;Bill&quot; var value:Int = 20 var flag:Boolean = true fun getDesc()&#123; println(&quot;name=$&#123;name&#125; value=$&#123;value&#125; flag=$&#123;flag&#125;&quot;) &#125;&#125; 属性的getter和setter形式如果属性是只读的，需要将属性声明为val，并只添加一个getter形式，如果属性是读写的，需要使用var是声明属性，并添加getter和vsetter形式。如果getter和setter中只有一行实现代码。直接用=分割getter和代码即可。如果包含多行代码需要使用{……}处理。 1234567891011121314class Customer3&#123; // 只读属性 val name:String get() = &quot;Bill&quot; // 读写属性 var v:Int = 20 var value:Int get() = v set(value)&#123; println(&quot;value属性被设置&quot;) v = value &#125;&#125; 保存属性值的字段在属性的getter和setter中，可以将field当做成员变量使用，也就是通过field读写属性值。 123456789101112class Customer4&#123; val name:String get() = &quot;Bill&quot; // 读写属性 var value:Int = 0 get() = field set(value)&#123; println(&quot;value属性被设置&quot;) field = value &#125;&#125; 修改Customer4的value值： 12345fun main(args: Array&lt;String&gt;) &#123; var customer4 = Customer4() customer4.value = 40 println(customer4.value)&#125; 运行结果： 12value属性被设置40 函数函数既可以在类外部定义，也可以在类内部定义。如果是前者是全局函数，如果是后者是类成员函数。 函数也支持默认参数值。要注意的是，带默认值的参数必须是最后几个参数，也就是说，如果某个参数带默认值。那么该参数后面的所有参数都必须有默认值。 12345class QACommunity2&#123; fun printQAcommunity(url:String,schema:String=&quot;http&quot;)&#123; println(&quot;$&#123;schema&#125;://$&#123;url&#125;&quot;) &#125;&#125; 执行代码： 123fun main(args: Array&lt;String&gt;) &#123; QACommunity2().printQAcommunity(&quot;shijiacheng.studio&quot;)&#125; 运行结果： 1http://shijiacheng.studio 如果我们想为下面的函数按顺序传入参数值，很简单 12345class Person2&#123; fun process(value: Int,name:String=&quot;Bill&quot;,age:Int=30,salary:Float=4000F)&#123; println(&quot;value=$&#123;value&#125; name=$&#123;name&#125; age=$&#123;age&#125; salary=$&#123;salary&#125;&quot;) &#125;&#125; 123fun main(args: Array&lt;String&gt;) &#123; Person2().process(30,&quot;Bill&quot;,30,12000F)&#125; 如果我们只想修改最后 一个参数的值，安装之前的思路必须每个参数的值都传一遍，很麻烦。为了解决这个问题，Kotlin允许使用命名参数传递参数值。例如： 123fun main(args: Array&lt;String&gt;) &#123; Person2().process(30,salary = 15000F)&#125;frev 如果传入参数的参数个数不固定，就要使用可变参数了，可变参数用vararg关键字声明： 12345678910111213141516class Person3(name: String)&#123; private var mName:String = name fun getName():String&#123; return mName &#125;&#125;class Persons&#123; fun addPersons(vararg persons:Person3):List&lt;Person3&gt;&#123; var result = ArrayList&lt;Person3&gt;() for(person in persons)&#123; result.add(person) &#125; return result &#125;&#125; 调用addPersons方法： 123456fun main(args: Array&lt;String&gt;) &#123; var persons = Persons().addPersons(Person3(&quot;Bill&quot;), Person3(&quot;Jill&quot;),Person3(&quot;Mike&quot;)) for (person in persons)&#123; println(person.getName()) &#125;&#125; 函数单行表达式：如果Kotlin函数体只有一行代码，可以直接在函数声明后面加等号=，后面直接跟代码，这种表达方式可以省略函数返回值类型。 1234567891011class Person4(name: String)&#123; private var mName:String = name fun getName():String&#123; return mName &#125; //函数单行表达式 fun getName1():String=mName // 函数单行表达式，省略返回值类型 fun getName2() = mName&#125; 本地函数：在函数体内定义函数，作用域就是包含本地函数的函数体 12345678fun addPerson(name: String)&#123; //process函数作用域就是addPerson的函数体 fun process(age: Int)&#123; println(&quot;age=$&#123;age&#125;&quot;) &#125; process(20) println(&quot;name=$&#123;name&#125;&quot;)&#125; 嵌套类嵌套类就是类中定义的类。 1234567class Outer&#123; private val bar:Int = 1 //嵌套类 class Nested&#123; fun foo() = 2 &#125;&#125; 调用foo方法： 123fun main(args: Array&lt;String&gt;) &#123; val demo = Outer.Nested().foo()&#125; 嵌套类还可以使用inner关键字声明，这样可以通过外部类的实例引用嵌套类 123456class Outer2&#123; private val bar:Int = 1 inner class Inner&#123; fun foo() = bar &#125;&#125; 3.4修饰符（Modifiers）Kotlin中有private、protected、internal、public 4个修饰符。 private：仅仅在类的内部可以访问 protected：类似private，但在子类中也可以访问 internal：在任何模块内部类都可以访问 public：任何类都可以访问 如果不指定任何修饰符，默认是public。 1234567891011open class Outer3&#123;//open表明Outer2是可继承的 private val a = 1 protected open val b = 2 internal val c = 3 val d = 4 // 默认是public protected class Nested&#123; public val e:Int = 5 &#125;&#125; 1234567class SubClass:Outer3()&#123; //无法访问父类的a常量 //可以访问b、c、d // Nested类和e变量可以访问 override val b =5 // 重写父类的常量b&#125; 3.5类的继承类如何继承Kotlin类的继承需要使用冒号（:）,冒号后需要调用父类的构造器，与Java一样，都是单继承的。要注意的是，Kotlin默认时class是final的，也就是说，默认时class不允许继承，需要显式的使用open关键字允许继承class。 123456789101112131415open class Parent &#123;// 需要open声明Parent，才允许其他类继承 protected var mName: String = &quot;Bill&quot; fun getName(): String &#123; return mName &#125;&#125;class Child:Parent()&#123; //Child类继承了Parent类，mName和getName在Child中都可以访问了 fun printName()&#123; println(mName) &#125;&#125; 重写方法如果要在子类中重写方法，就需要在父类相应的方法前面加open关键字，而且要在子类重写的方法前面加override关键字。 123456789101112131415161718192021open class Parent2 &#123;// 需要open声明Parent，才允许其他类继承 protected var mName: String = &quot;Bill&quot; open fun getName(): String &#123; // 只有加open关键字，getname才可以被子类的方法重写 return mName &#125;&#125;open class Child2:Parent2()&#123; //Child类继承了Parent类，mName和getName在Child中都可以访问了 fun printName()&#123; println(getName()) &#125; // 重写父类的getname方法 override fun getName(): String &#123; return &quot;&lt;&quot;+super.getName()+&quot;&gt;&quot; &#125;&#125; 现在调用Child2l类的getName方法，实际上执行的是Child2自身的getName方法，而不是Parent2类的getName方法。 如果一个方法前加了override，那么这个方法就可以被重写了，例如Child2类的getName方法在子类中是可以被再次重写的。 123456class MyChild2:Child2()&#123; //再次重写getName方法 override fun getName(): String &#123; return &quot;[&quot;+super.getName()+&quot;]&quot; &#125;&#125; 如果想阻止getName方法被子类重写，需要在override前面加final 123456class MyChild3:Child2()&#123; //再次重写getName方法 final override fun getName(): String &#123; return &quot;[&quot;+super.getName()+&quot;]&quot; &#125;&#125; 重写属性属性的重写方式与方法类似，被重写的属性必须使用open声明，子类中重写的属性必须使用overr声明。注意的是，val属性可以被重写为var属性，但反过来不可以。 12345678910111213141516171819202122232425open class Parent3&#123; open val name:String=&quot;Bill&quot; get() &#123; println(&quot;获取Parent.name属性值&quot;) return field &#125;&#125;open class Child3:Parent3()&#123; override var name:String = &quot;Mike&quot; get() &#123; println(&quot;获取Child3.name属性值&quot;) return field &#125; set(value)&#123; field = value println(&quot;Child3.name被写入&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var child = Child3() child.name = &quot;John&quot; println(child.name)&#125; 运行结果： 123Child3.name被写入获取Child3.name属性值John 3.6接口接口使用interface关键字声明，一个类可以实现多个接口。实现的方法和类继承相似。而且接口中的属性和方法都是open的。 12345678910111213141516171819202122interface MyInterface&#123; fun process() fun getName():String&#123; return &quot;Bill&quot; &#125;&#125;class MyClass2 :MyInterface&#123; override fun process() &#123; println(&quot;process&quot;) &#125; override fun getName(): String &#123; return &quot;Mike&quot; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; println(MyClass2().getName()) MyClass2().process()&#125; 在Kotlin中，允许接口的方法包含默认的方法体。对于有方法体的接口方法。并不要求一定重写该方法。也就是说getName方法可以在MyClass2中不重写。 3.7抽象类抽象类不能被实例化，需要使用abstract关键字声明，抽象类实现接口后，接口中没有函数体的函数可以不重写（override），接口中的这些方法就自动被继承到实现接口的抽象类中，称为抽象方法。 1234567open class Base&#123; open fun f()&#123;&#125;&#125;abstract class Derived:Base()&#123; override abstract fun f()&#125; 抽象方法不需要使用open声明，因为抽象类本身就是可继承的。]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 Kotlin基础知识]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-02%2F</url>
    <content type="text"><![CDATA[2.1 Kotlin基础语法Kotlin 文件以 .kt 为后缀。 包声明代码文件的开头一般为包的声明： 123456package com.shijc.mainimport java.util.*fun test() &#123;&#125;class Shijiacheng &#123;&#125; kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 以上例中 test() 的全名是 com.shijc.main.test、Shijiacheng 的全名是 com.shijc.main.Shijiacheng。 如果没有指定包，默认为 default 包。 默认导入有多个包会默认导入到每个 Kotlin 文件中： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 函数定义函数定义使用关键字 fun，参数格式为：参数 : 类型 123fun sum(a: Int, b: Int): Int &#123; // Int 参数，返回值 Int return a + b&#125; 表达式作为函数体，返回类型自动推断： 123fun sum(a: Int, b: Int) = a + bpublic fun sum(a: Int, b: Int): Int = a + b // public 方法则必须明确写出返回类型 无返回值的函数(类似Java中的void)： 123456789fun printSum(a: Int, b: Int): Unit &#123; print(a + b)&#125;// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：public fun printSum(a: Int, b: Int) &#123; print(a + b)&#125; 可变长参数函数函数的变长参数可以用 vararg 关键字进行标识： 12345678910fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(vt) &#125;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; vars(1,2,3,4,5) // 输出12345&#125; lambda(匿名函数)lambda表达式使用实例： 12345// 测试fun main(args: Array&lt;String&gt;) &#123; val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125; println(sumLambda(1,2)) // 输出 3&#125; 定义常量与变量可变变量定义：var 关键字 1var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量) 1val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 常量与变量都可以没有初始化值,但是在引用前必须初始化 编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。 12345678val a: Int = 1val b = 1 // 系统自动推断变量类型为Intval c: Int // 如果不在声明时初始化则必须提供变量类型c = 1 // 明确赋值var x = 5 // 系统自动推断变量类型为Intx += 1 // 变量可修改 注释Kotlin 支持单行和多行注释，实例如下： 1234// 这是一个单行注释/* 这是一个多行的 块注释。 */ 与 Java 不同, Kotlin 中的块注释允许嵌套。 字符串模板$ 表示一个变量名或者变量值 $varName 表示变量值 ${varName.fun()} 表示变量的方法返回值: 1234567var a = 1// 模板中的简单名称：val s1 = &quot;a is $a&quot; a = 2// 模板中的任意表达式：val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot; NULL检查机制Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理 12345678//类型后面加?表示可为空var age: String? = &quot;23&quot; //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。 当 str 中的字符串内容不是一个整数时, 返回 null: 123fun parseInt(str: String): Int? &#123; // ...&#125; 以下实例演示如何使用一个返回值可为 null 的函数: 12345678910111213fun main(args: Array&lt;String&gt;) &#123; if (args.size &lt; 2) &#123; print(&quot;Two integers expected&quot;) return &#125; val x = parseInt(args[0]) val y = parseInt(args[1]) // 直接使用 `x * y` 会导致错误, 因为它们可能为 null. if (x != null &amp;&amp; y != null) &#123; // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量 print(x * y) &#125;&#125; 类型检测及自动类型转换我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。 1234567891011121314fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 return obj.length &#125; //在这里还有一种方法，与Java中instanceof不同，使用!is // if (obj !is String)&#123; // // XXX // &#125; // 这里的obj仍然是Any类型的引用 return null&#125; 或者 123456fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // 在这个分支中, `obj` 的类型会被自动转换为 `String` return obj.length&#125; 甚至还可以 123456fun getStringLength(obj: Any): Int? &#123; // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String` if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null&#125; 区间区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例: 123456789101112131415161718for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; 实例测试 1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; print(&quot;循环输出：&quot;) for (i in 1..4) print(i) // 输出“1234” println(&quot;\n----------------&quot;) print(&quot;设置步长：&quot;) for (i in 1..4 step 2) print(i) // 输出“13” println(&quot;\n----------------&quot;) print(&quot;使用 downTo：&quot;) for (i in 4 downTo 1 step 2) print(i) // 输出“42” println(&quot;\n----------------&quot;) print(&quot;使用 until：&quot;) // 使用 until 函数排除结束元素 for (i in 1 until 4) &#123; // i in [1, 4) 排除了 4 print(i) &#125; println(&quot;\n----------------&quot;)&#125; 输出结果： 12345678循环输出：1234----------------设置步长：13----------------使用 downTo：42----------------使用 until：123---------------- 2.2 Kotlin 基本数据类型Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于Java的是，字符不属于数值类型，是一个独立的数据类型。 类型 位宽度 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 字面常量下面是所有类型的字面常量： 十进制：123 长整型以大写的 L 结尾：123L 16 进制以 0x 开头：0x0F 2 进制以 0b 开头：0b00001011 注意：8进制不支持 Kotlin 同时也支持传统符号表示的浮点数值： Doubles 默认写法: 123.5, 123.5e10 Floats 使用 f 或者 F 后缀：123.5f 你可以使用下划线使数字常量更易读： 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 比较两个数字Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所有在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。 在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。 123456789101112fun main(args: Array&lt;String&gt;) &#123; val a: Int = 10000 println(a === a) // true，值相等，对象地址相等 //经过了装箱，创建了两个不同的对象 val boxedA: Int? = a val anotherBoxedA: Int? = a //虽然经过了装箱，但是值是相等的，都是10000 println(boxedA === anotherBoxedA) // false，值相等，对象地址不一样 println(boxedA == anotherBoxedA) // true，值相等&#125; 类型转换由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误 我们可以代用其toInt()方法。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b.toInt() // OK 每种数据类型都有下面的这些方法，可以转化为其它的类型： 1234567toByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char 有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的： 1val l = 1L + 3 // Long + Int =&gt; Long 位操作符对于Int和Long类型，还有一系列的位操作符可以使用，分别是： 1234567shl(bits) – 左移位 (Java’s &lt;&lt;)shr(bits) – 右移位 (Java’s &gt;&gt;)ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)and(bits) – 与or(bits) – 或xor(bits) – 异或inv() – 反向 字符和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ‘ 包含起来的。比如普通字符 ‘0’，’a’。 12345fun check(c: Char) &#123; if (c == 1) &#123; // 错误：类型不兼容 // …… &#125;&#125; 字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\t、 \b、\n、\r、\’、\”、\ 和 \$。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’。 我们可以显式把字符转换为 Int 数字： 12345fun decimalDigitValue(c: Char): Int &#123; if (c !in &apos;0&apos;..&apos;9&apos;) throw IllegalArgumentException(&quot;Out of range&quot;) return c.toInt() - &apos;0&apos;.toInt() // 显式转换为数字&#125; 当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。 布尔布尔用 Boolean 类型表示，它有两个值：true 和 false。 若需要可空引用布尔会被装箱。 内置的布尔运算有： 123|| – 短路逻辑或&amp;&amp; – 短路逻辑与! - 逻辑非 数组数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。 数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组： 12345678910fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 如上所述，[] 运算符代表调用成员函数 get() 和 set()。 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。 除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样： 12val x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2] 字符串和 Java 一样，String 是可不变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历： 123for (c in str) &#123; println(c)&#125; Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如： 1234567fun main(args: Array&lt;String&gt;) &#123; val text = &quot;&quot;&quot; 多行字符串 多行字符串 &quot;&quot;&quot; println(text) // 输出有一些前置空格&#125; String 可以通过 trimMargin() 方法来删除多余的空白。 2.3 Kotlin 条件控制IF 表达式一个 if 语句包含一个布尔表达式和一条或多条语句。 1234567891011121314// 传统用法var max = a if (a &lt; b) max = b// 使用 else var max: Intif (a &gt; b) &#123; max = a&#125; else &#123; max = b&#125; // 作为表达式val max = if (a &gt; b) a else b 我们也可以把 IF 表达式的结果赋值给一个变量。 1234567val max = if (a &gt; b) &#123; print(&quot;Choose a&quot;) a&#125; else &#123; print(&quot;Choose b&quot;) b&#125; 这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现： 1val c = if (condition) a else b 实例 123456789101112131415fun main(args: Array&lt;String&gt;) &#123; var x = 0 if(x&gt;0)&#123; println(&quot;x 大于 0&quot;) &#125;else if(x==0)&#123; println(&quot;x 等于 0&quot;) &#125;else&#123; println(&quot;x 小于 0&quot;) &#125; var a = 1 var b = 2 val c = if (a&gt;=b) a else b println(&quot;c 的值为 $c&quot;)&#125; 输出结果为： 12x 等于 0c 的值为 2 使用区间使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ： 实例 1234567fun main(args: Array&lt;String&gt;) &#123; val x = 5 val y = 9 if (x in 1..8) &#123; println(&quot;x 在区间内&quot;) &#125;&#125; 输出结果为： 1x 在区间内 When 表达式when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。 when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。 when 类似其他语言的 switch 操作符。其最简单的形式如下： 1234567when (x) &#123; 1 -&gt; print(&quot;x == 1&quot;) 2 -&gt; print(&quot;x == 2&quot;) else -&gt; &#123; // 注意这个块 print(&quot;x 不是 1 ，也不是 2&quot;) &#125;&#125; 在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支。 如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔： 1234when (x) &#123; 0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;) else -&gt; print(&quot;otherwise&quot;)&#125; 我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中： 123456when (x) &#123; in 1..10 -&gt; print(&quot;x is in the range&quot;) in validNumbers -&gt; print(&quot;x is valid&quot;) !in 10..20 -&gt; print(&quot;x is outside the range&quot;) else -&gt; print(&quot;none of the above&quot;)&#125; 另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。 1234fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith(&quot;prefix&quot;) else -&gt; false&#125; when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支： 12345when &#123; x.isOdd() -&gt; print(&quot;x is odd&quot;) x.isEven() -&gt; print(&quot;x is even&quot;) else -&gt; print(&quot;x is funny&quot;)&#125; 实例 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; var x = 0 when (x) &#123; 0, 1 -&gt; println(&quot;x == 0 or x == 1&quot;) else -&gt; println(&quot;otherwise&quot;) &#125; when (x) &#123; 1 -&gt; println(&quot;x == 1&quot;) 2 -&gt; println(&quot;x == 2&quot;) else -&gt; &#123; // 注意这个块 println(&quot;x 不是 1 ，也不是 2&quot;) &#125; &#125; when (x) &#123; in 0..10 -&gt; println(&quot;x 在该区间范围内&quot;) else -&gt; println(&quot;x 不在该区间范围内&quot;) &#125;&#125; 输出结果： 123x == 0 or x == 1x 不是 1 ，也不是 2x 在该区间范围内 when 中使用 in 运算符来判断集合内是否包含某实例： 1234567fun main(args: Array&lt;String&gt;) &#123; val items = setOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;) when &#123; &quot;orange&quot; in items -&gt; println(&quot;juicy&quot;) &quot;apple&quot; in items -&gt; println(&quot;apple is fine too&quot;) &#125;&#125; 输出结果： 1apple is fine too 2.4 Kotlin 循环控制For 循环for 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下: 1for (item in collection) print(item) 循环体可以是一个代码块: 123for (item: Int in ints) &#123; // ……&#125; 如上所述，for 可以循环遍历任何提供了迭代器的对象。 如果你想要通过索引遍历一个数组或者一个 list，你可以这么做： 123for (i in array.indices) &#123; print(array[i])&#125; 注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。 或者你可以用库函数 withIndex： 123for ((index, value) in array.withIndex()) &#123; println(&quot;the element at $index is $value&quot;)&#125; 实例 对集合进行迭代： 12345678910fun main(args: Array&lt;String&gt;) &#123; val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;) for (item in items) &#123; println(item) &#125; for (index in items.indices) &#123; println(&quot;item at $index is $&#123;items[index]&#125;&quot;) &#125;&#125; 输出结果： 123456applebananakiwiitem at 0 is appleitem at 1 is bananaitem at 2 is kiwi while 与 do…while 循环while是最基本的循环，它的结构为： 123while( 布尔表达式 ) &#123; //循环内容&#125; do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 123do &#123; //代码语句&#125;while(布尔表达式); 实例 123456789101112fun main(args: Array&lt;String&gt;) &#123; println(&quot;----while 使用-----&quot;) var x = 5 while (x &gt; 0) &#123; println( x--) &#125; println(&quot;----do...while 使用-----&quot;) var y = 5 do &#123; println(y--) &#125; while(y&gt;0)&#125; 输出结果： 123456789101154321----do...while 使用-----54321 返回和跳转Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。 在循环中 Kotlin 支持传统的 break 和 continue 操作符。 1234567fun main(args: Array&lt;String&gt;) &#123; for (i in 1..10) &#123; if (i==3) continue // i 为 3 时跳过当前循环，继续下一次循环 println(i) if (i&gt;5) break // i 为 6 时 跳出循环 &#125;&#125; 输出结果： 1234512456 Break 和 Continue 标签在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。 123loop@ for (i in 1..100) &#123; // ……&#125; 现在，我们可以用标签限制 break 或者continue： 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。 标签处返回Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候： 123456fun foo() &#123; ints.forEach &#123; if (it == 0) return print(it) &#125;&#125; 这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。 123456fun foo() &#123; ints.forEach lit@ &#123; if (it == 0) return@lit print(it) &#125;&#125; 现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。 123456fun foo() &#123; ints.forEach &#123; if (it == 0) return@forEach print(it) &#125;&#125; 或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回 123456fun foo() &#123; ints.forEach(fun(value: Int) &#123; if (value == 0) return print(value) &#125;)&#125; 当要返一个回值的时候，解析器优先选用标签限制的 return，即 1return@a 1 意为”从标签 @a 返回 1”，而不是”返回一个标签标注的表达式 (@a 1)”。]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 第一个Kotlin程序]]></title>
    <url>%2F2018%2F05%2F10%2FhelloKotlin-01%2F</url>
    <content type="text"><![CDATA[Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。 Kotlin 程序文件以 .kt 结尾，如：hello.kt 、app.kt。 12345package hello // 可选的包头 fun main(args: Array&lt;String&gt;) &#123; // 包级可见的函数，接受一个字符串数组作为参数 println(&quot;Hello World!&quot;) // 分号可以省略&#125; 为什么选择 Kotlin？ 简洁: 大大减少样板代码的数量。 安全: 避免空指针异常等整个类的错误。 互操作性: 充分利用 JVM、Android 和浏览器的现有库。 工具友好: 可用任何 Java IDE 或者使用命令行构建。 参考链接]]></content>
      <categories>
        <category>Kotlin入坑小结</category>
      </categories>
      <tags>
        <tag>Kotlin入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode刷题]]></title>
    <url>%2F2018%2F04%2F14%2Fcrazyleetcode%2F</url>
    <content type="text"><![CDATA[LeetCode 刷题 Two Sum]]></content>
  </entry>
  <entry>
    <title><![CDATA[网易2019实习生招聘编程题集合]]></title>
    <url>%2F2018%2F04%2F06%2Fnetease-intern-2019%2F</url>
    <content type="text"><![CDATA[1.牛牛找工作为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。 2.被3整除小Q得到一个神奇的数列: 1, 12, 123,…12345678910,1234567891011…。并且小Q对于能否被3整除这个性质很感兴趣。小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。 3.安置路灯小Q正在给一条长度为n的道路设计路灯安置方案。为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。 4.迷路的牛牛牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。 5.数对牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。牛牛希望你能帮他计算一共有多少个可能的数对。 6.矩形重叠平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。 7.牛牛的闹钟牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床 8.牛牛的背包问题牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。]]></content>
      <categories>
        <category>笔试算法题</category>
      </categories>
      <tags>
        <tag>网易2019实习生招聘编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp实现全局过期token自动刷新]]></title>
    <url>%2F2018%2F03%2F28%2Fokhttp-interceptor%2F</url>
    <content type="text"><![CDATA[问题一次面试遇到的一个问题，其实也是实际开发中很容易遇到的问题，特此记录一下。 当请求某个接口的时候，我们会在请求的header中携带token消息，但是发现token失效，接口请求报错，怎么马上刷新token，然后重复请求方才那个接口呢？这个过程应该说对用户来说是无感的。 这个过程用流程图可以这样表示： 要实现上述需求的话，大家会如何实现呢？ 首先讲一下Token和Cookie吧- cookiecookie是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 cookie的组成有：名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”\”)、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。 - tokentoken的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。 解决方案 通过拦截器，获取返回的数据 判断token是否过期 如果token过期则刷新token 使用最新的token，重新请求网络数据 自定义自动刷新token的拦截器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import android.util.Log;import java.io.IOException;import okhttp3.Interceptor;import okhttp3.Request;import okhttp3.Response;/** * 自动刷新token的拦截器 * * @author shijiacheng * @version 1.0 */public class TokenInterceptor implements Interceptor &#123; private static final String TAG = &quot;TokenInterceptor&quot;; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); Log.d(TAG, &quot;response.code=&quot; + response.code()); //根据和服务端的约定判断token过期 if (isTokenExpired(response)) &#123; Log.d(TAG, &quot;自动刷新Token,然后重新请求数据&quot;); //同步请求方式，获取最新的Token String newToken = getNewToken(); //使用新的Token，创建新的请求 Request newRequest = chain.request() .newBuilder() .header(&quot;Authorization&quot;, &quot;Basic &quot; + newToken) .build(); //重新请求 return chain.proceed(newRequest); &#125; return response; &#125; /** * 根据Response，判断Token是否失效 * * @param response * @return */ private boolean isTokenExpired(Response response) &#123; if (response.code() == 301) &#123; return true; &#125; return false; &#125; /** * 同步请求方式，获取最新的Token * * @return */ private String getNewToken() throws IOException &#123; // 通过获取token的接口，同步请求接口 String newToken = &quot;&quot;; return newToken; &#125;&#125; 配置下OkHttpUtils 1234567891011121314151617/** * 初始化OkHttpUtils */public OkHttpUtils()&#123; /** * 配置OkHttpClient */ OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .readTimeout(3000, TimeUnit.SECONDS) .writeTimeout(3000, TimeUnit.SECONDS)// .cache(new Cache())// .addInterceptor(interceptor)//这里可以继续添加多种拦截器 .addInterceptor(new TokenInterceptor())//添加获取token的拦截器 .build(); &#125;]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android启动页解决攻略]]></title>
    <url>%2F2017%2F09%2F09%2Fandroid-splash-demo%2F</url>
    <content type="text"><![CDATA[相信很多人都在网上查过关于启动白屏或者黑屏的问题。 一般的App应该是分为两种： 有闪屏页或者启动页(SplashActivity)，页面大概会持续2到3秒 没有闪屏页和启动页，打开应用后会直接跳转到应用主界面 不管有没有启动页，如果你不处理，你会发现当你点击桌面上那个icon图标的时候会先闪白屏或者黑屏一下，然后才会进入我们设定的页面。 但是我们手机上的常用应用，比如美团，今日头条，微信等，点击app icon的时候，其实感觉是一瞬间秒开的，没有白屏的过程，那么这是如何处理的呢？ 先说一说为什么会出现白屏或者黑屏吧！当打开一个Activity时，如果这个Activity所属的应用还没有在运行，系统会为这个Activity所属的应用创建一个进程，但进程的创建与初始化都需要时间，如果没有任何反应的话，如果程序初始化的时间很长，用户可能还以为没有点到相应的位置。但此时所启动的程序还没初始化完，既无法显示程序，又不能停在原处不做任何动作，这就有了Starting Window的概念，也可以称之为Preview Window。 Starting Window就是一个用于在应用程序进程创建并初始化成功前显示的临时窗口，拥有的Window Type是TYPE_APPLICATION_STARTING。在程序初始化完成前显示这个窗口，以告知用户系统已经知道了他要打开这个应用并做出了响应，当程序初始化完成后显示用户UI并移除这个窗口。 显示白屏或者黑屏，是由你的启动Activity或者Application来决定的。如果你使用的是Light主题，那么就可能出现白屏；如果你使用的是Black主题，那么就可能出现黑屏。当你设置Light或者Black主题时，Starting Window显示的就是你启动Activity的android:windowBackground属性，所以才会出现白屏或者黑屏的情况。 网上有很多教程，说是把主题的背景设为透明，这样子的确实没有白屏了，但是你会发现点击完app的icon之后，会有一小会的停顿，给用户一种卡顿的感觉，体验非常不好，不能为了实现功能而实现功能，软件开发用户体验至上！ 那么好的体验该如何开发呢？我们以实现一个今日头条app的启动页作为案例。 我们先来看一看常规情况下app启动的黑白屏。 为了让白屏或者黑屏明显的显示，在SplashActivity的onCreate方法中setContentView之前加入一个休眠1秒的操作。 123456/*还没有加载布局是睡眠1秒，确保黑屏或白屏效果明显*/try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; 12345678910/**闪屏页持续1s然后进入主页*/mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Intent intent = new Intent(activity,AdsActivity.class); startActivity(intent); finish(); overridePendingTransition(R.anim.fade,R.anim.hold); &#125; &#125;, 1000); 效果是： 接下来我们来消灭白屏。第一步 消灭白屏1.我们需要删除原来的闪屏页的布局activity_splash.xml，同时删除SplashActivity中setContentView(R.layout.activity_splash)方法。 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); /*还没有加载布局是睡眠1秒，确保黑屏或白屏效果明显*/ try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;// setContentView(R.layout.activity_splash);&#125; 2.为了让闪屏页持续时间长一点，我们用handler模拟耗时操作，1秒后进行跳转。 123456789mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; //这块耗时操作可以进行初始化，或者网络请求等，1秒结束后跳转到广告页面 Intent intent = new Intent(activity,AdsActivity.class); startActivity(intent); finish(); &#125; &#125;, 1000); 3.我们删除了闪屏页的布局文件，想法是将闪屏的背景作为Activity的主题背景，要做到这一点，首先要在 res/drawable创建一个XML drawable文件。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@color/white&quot; /&gt; &lt;item android:bottom=&quot;20dp&quot;&gt; &lt;bitmap android:gravity=&quot;bottom&quot; android:src=&quot;@mipmap/icon_logo&quot; /&gt; &lt;/item&gt;&lt;/layer-list&gt; 4.接下来在style.xml中创建一个闪屏页的主题，将创建的xml设置为window的背景。并且在AndroidManifest.xml中给SplashActivity配置style。 123&lt;style name=&quot;AppTheme.Splash&quot; parent =&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/drawable_splash&lt;/item&gt;&lt;/style&gt; 12345678&lt;activity android:name=&quot;.SplahActivity&quot; android:theme=&quot;@style/AppTheme.Splash&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 这个时候运行程序，我们发现其实已经没有白屏了。 第二步，我们实现广告加载页面 1.广告页是一个倒计时的显示，布局中放入一个TextView来显示倒计时信息，放入一个ImageView来显示加载动画。点击跳过广告的时候显示加载动画。 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_logo&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/icon_logo&quot; android:layout_marginBottom=&quot;20dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot;/&gt; &lt;RelativeLayout android:layout_marginBottom=&quot;20dp&quot; android:layout_above=&quot;@+id/iv_logo&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_ads&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳过广告&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;12sp&quot; android:background=&quot;@drawable/bg_ad_text&quot; android:padding=&quot;5dp&quot;/&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt; 2.页面实现中，我们定义一个CountDownTimer，这个类是Android SDK提供用来进行倒计时的。CountDownTimer(long millisInFuture, long countDownInterval)有两个参数，第一个是计时的总时长，第二个是间隔。 12345678910111213141516171819202122232425262728293031323334353637383940public class AdsActivity extends Activity &#123; private Activity activity; private TextView tvAds; private CountDownTimer countDownTimer; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_ads); activity =this; tvAds = (TextView) findViewById(R.id.tv_ads); countDownTimer = new CountDownTimer(4000,1000) &#123; @Override public void onTick(long millisUntilFinished) &#123; tvAds.setText(&quot;跳过广告&quot;+(millisUntilFinished/1000)+&quot;秒&quot;); &#125; @Override public void onFinish() &#123; Intent intent = new Intent(activity,MainActivity.class); startActivity(intent); finish(); &#125; &#125;.start(); /** * 跳过广告 */ tvAds.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; countDownTimer.cancel(); Intent intent = new Intent(activity,MainActivity.class); startActivity(intent); finish(); &#125; &#125;); &#125;&#125; 第三步，优化1.我们运行起来，发现页面之间的跳转有些不美观，从右向左进入的动画感觉有些生硬。因此我们给页面之间加入转场动画。 123456#fade.xml 页面退出动画&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;0.0&quot; android:duration=&quot;400&quot; /&gt; 123456#hold.xml 页面进入动画&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;0&quot; android:duration=&quot;400&quot; /&gt; 在每个Intent跳转的地方加入转场效果 1234Intent intent = new Intent(activity,AdsActivity.class);startActivity(intent);finish();overridePendingTransition(R.anim.fade,R.anim.hold); 最终的效果是： 有两点注意： overridePendingTransition方法要写在finish后面 overridePendingTransition方法一定要写在主线程中，在子线程是没有作用的。 源码地址：http://download.csdn.net/download/u012771445/9971093]]></content>
      <categories>
        <category>Android基础教程</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Google VR教你打造全景图片展示]]></title>
    <url>%2F2017%2F09%2F07%2FGoogleVRImage%2F</url>
    <content type="text"><![CDATA[本文章主要参考Google VR中的文档，如果您能流利的读懂英文开发文档，可以去官网自行查看。 1.介绍VR View VR view allows you to embed 360 degree VR media into websites on desktop and mobile, and native apps on Android and iOS. This technology is designed to enable developers of traditional apps to enhance the apps with immersive content. VR视图允许你将360度的VR媒体嵌入桌面和移动的网站，以及Android和iOS上的原生应用。这项技术旨在使传统应用程序的开发者能够通过沉浸式的内容来增强应用程序。 VR view supports mono and stereo 360 images and videos. Images and video need to be stored in the equirectangular-panoramic (equirect-pano) format, which is a common format supported by many capture solutions. VR视图支持mono和立体图像和视频。图像和视频需要存储在equi矩形-全景(equirect - pano)格式中，这是许多捕获解决方案支持的公共格式。 Image规格 VR查看图像可以保存为PNG，JPEG或GIF。Google建议使用JPEG改进压缩。 为了获得最大的兼容性和性能，图像尺寸应该是2的倍数（例如，2048或4096）。 单个图像应为2：1纵横比（例如4096×2048）。 立体图像应为1：1纵横比（例如4096×4096）。 mono单个图像 stereo立体图像 先来看看效果： 2.使用VrPanoramaView嵌入全景图像1.build.gradle在app下的build.gradle中添加panowidget库 123dependencies &#123; compile &apos;com.google.vr:sdk-panowidget:1.10.0&apos;&#125; 2.AndroiManifest.xml在使用VrPanoramaView的Acitivity的intent-filter节点添加过滤分类：com.google.intent.category.CARDBOARD ： 兼容Cardboard纸盒 12345&lt;activity android:name=&quot;.VrPanoramaActivity&quot; &gt; &lt;intent-filter&gt; &lt;category android:name=&quot;com.google.intent.category.CARDBOARD&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 3.布局文件只需在布局中添加一个控件 123456&lt;com.google.vr.sdk.widgets.pano.VrPanoramaView android:id=&quot;@+id/pano_view&quot; android:layout_margin=&quot;5dip&quot; android:layout_width=&quot;match_parent&quot; android:scrollbars=&quot;@null&quot; android:layout_height=&quot;250dip&quot; /&gt; 4.加载全景图A.初始化控件 1VrPanoramaView vrPanView = (VrPanoramaView) findViewById(R.id.vr_pan_view); B.读取图片 我们提前将一张选择好的全景图放在assets目录中，aa.jpg,将图片转为bitmap 12345678/**获取assets中的图片，转为流**/InputStream open = null;try &#123; open = getAssets().open(&quot;aa.jpg&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;Bitmap bitmap = BitmapFactory.decodeStream(open); C.设置VrPanoramaView.Options 123/**VrPanoramaView.Options 设置**/VrPanoramaView.Options options = new VrPanoramaView.Options();options.inputType = VrPanoramaView.Options.TYPE_MONO; VrPanoramaView.Options有两种类型： TYPE_MONO 360度单图(2：1纵横比)图像被预期以覆盖沿着其水平轴360度，而垂直范围是根据图像的宽高比来计算。例如，如果一个1000x250像素的图像，给出所述全景将覆盖360x90度与垂直范围是-45至+45度。 TYPE_STEREO_OVER_UNDER 立体图(1：1纵横比)包含两个大小相等的投影 全景图垂直叠加。顶部图像被显示给左眼、底部图像被显示给右眼。图像将覆盖沿水平轴360度，而垂直范围是根据图像的宽高比来计算。例如，如果一个1000x500像素的图像中给出（即1000x250像素每个眼睛），全景将覆盖360x90度与垂直范围是-45至+45度。 D.加载全景图 1vrPanView.loadImageFromBitmap(bitmap, options); E.设置加载监听VrPanoramaEventListener 1234567891011121314151617181920212223242526272829303132333435363738394041/**设置加载图片监听**/vrPanView.setEventListener(new VrPanoramaEventListener() &#123; /** * 显示模式改变回调 * 1.默认 * 2.全屏模式 * 3.VR观看模式，即横屏分屏模式 */ @Override public void onDisplayModeChanged(int newDisplayMode) &#123; super.onDisplayModeChanged(newDisplayMode); Log.d(TAG, &quot;onDisplayModeChanged()-&gt;newDisplayMode=&quot; + newDisplayMode); &#125; /** * 加载VR图片失败回调 */ @Override public void onLoadError(String errorMessage) &#123; super.onLoadError(errorMessage); Log.d(TAG, &quot;onLoadError()-&gt;errorMessage=&quot; + errorMessage); &#125; /** * 加载VR图片成功回调 */ @Override public void onLoadSuccess() &#123; super.onLoadSuccess(); Log.d(TAG, &quot;onLoadSuccess-&gt;图片加载成功&quot;); &#125; /** * 点击VR图片回调 */ @Override public void onClick() &#123; super.onClick(); Log.d(TAG, &quot;onClick()&quot;); &#125;&#125;); F.在onPause、onResume、onDestroy中做出相应处理 1234567891011121314151617@Overrideprotected void onPause() &#123; super.onPause(); vrPanView.pauseRendering();//暂停3D渲染和跟踪&#125;@Overrideprotected void onResume() &#123; super.onResume(); vrPanView.resumeRendering();//恢复3D渲染和跟踪&#125;@Overrideprotected void onDestroy() &#123; vrPanView.shutdown();//关闭渲染下并释放相关的内存 super.onDestroy();&#125; G.一些其他方法 //是否隐藏左下角信息的按钮vrPanView.setInfoButtonEnabled(boolean enabled); //是否隐藏全屏按钮vrPanView.setFullscreenButtonEnabled(boolean enabled); 未完，如果遇到新的继续添加 最后附上完整代码：VrPanoramaActivity.java]]></content>
      <categories>
        <category>Android提高</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>Google VR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First RecyclerView (RecyclerView使用详解)]]></title>
    <url>%2F2017%2F06%2F30%2Ffirst-RecyclerView%2F</url>
    <content type="text"><![CDATA[1. RecyclerView是什么？根据Google官方给出的说明： A flexible view for providing a limited window into a large data set. 能够在有限的窗口中展示大数据集合的灵活视图。 所以我们能够理解为，RecyclerView的一个恰当的使用场景是：由于尺寸限制，用户的设备不能一次性展现所有条目，用户需要上下滚动以查看更多条目。滚出可见区域的条目将被回收，并在下一个条目可见的时候被复用。 对于减少内存开销和CPU的计算，缓存条目是一个非常有用的方法，因为这意味着我们不必每次都创建新的条目，从而减小内存开销和CPU的计算，而且还能够有效降低屏幕的卡顿，保证滑动的顺滑。 RecyclerView不关心视觉效果（visuals） 但是和ListView有什么区别呀？我们已经使用ListView很长一段时间了呀，它一样可以做到呀。从它的类名上看，RecyclerView代表的意义是，我只管Recycler View，也就是说RecyclerView只管回收与复用View，其他的开发者可以自己去设置。你想要另一个布局？插入另一个LayoutManager。你想要不同的动画吗？插入一个ItemAnimator，等等。可以看出其高度的解耦，给予你充分的定制自由（所以你才可以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果）。 2. 引入RecyclerViewRecyclerView 是Support Library的一部分。所以只需要在app/build.gradle中添加以下依赖，便能立即使用： 123dependencies &#123; compile &apos;com.android.support:recyclerview-v7:25.3.1&apos;&#125; 在布局文件中加入： 1234&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后在页面中引入RecyclerView即可： 1RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); OK，从现在开始，让我们一步一步，开始了解它。 3. 使用RecyclerView下面的表格中就是使用RecyclerView来显示数据中用到的几个最重要的类，这些类都是RecyclerView的内部类，如果你想使用RecyclerView，需要做以下操作： Class 功能 Adapter 处理数据集合并负责绑定视图 ViewHolder 持有所有的用于绑定数据或者需要操作的View LayoutManager 负责摆放视图等相关操作 ItemDecoration 负责绘制Item附近的分割线 ItemAnimator 为Item的一般操作添加动画效果，如，增删条目等 我们可以从下图更直观的了解到RecyclerView的基本结构： 接下来，我将要描述每个类或接口的内容以及如何使用它。 3.1 RecyclerView.ViewHolderViewHolder的基本用法是用来存放View对象。Android团队很早之前就推荐使用“ViewHolder设计模式”，但是没有要求开发者在Adapter中必须使用ViewHolder模式。那么现在对于这种新型的RecyclerView.Adapter，我们必须实现并使用这种模式。 Google官方等了这么长时间才强制使用ViewHolder模式，这有点奇怪，但迟做总比不做好。如果您不了解ViewHolder模式，请查看一下Android training Hold View Objects in a View Holder。另外网上有大量关于ListView优化的文章。面试重点。 有一件事是专门针对RecyclerView的。ViewHolder子类可以通过访问公共成员itemView来访问ViewHolder的根视图。所以不需要在ViewHolder子类中存储。 下面是示例的ViewHolder的代码，ViewHolder是示例Adapter的内部类： 123456789public static class MyViewHolder extends RecyclerView.ViewHolder&#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = (TextView) itemView.findViewById(R.id.tv); &#125;&#125; 3.2 AdapterAdapter扮演着两个角色。一是，根据不同ViewType创建与之相应的的Item-Layout，二是，访问数据集合并将数据绑定到正确的View上。这就需要我们重写以下3个方法： public VH onCreateViewHolder(ViewGroup parent, int viewType) 创建Item视图，并返回相应的ViewHolder public void onBindViewHolder(VH holder, int position) 绑定数据到正确的Item视图上。 public int getItemCount() 返回该Adapter所持有的item数量 示例代码如下所示： 12345678910111213141516@Overridepublic MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context) .inflate(R.layout.item_recycler_view,parent,false)); return holder;&#125;@Overridepublic void onBindViewHolder(MyViewHolder holder, int position) &#123; holder.tv.setText(mDatas.get(position));&#125;@Overridepublic int getItemCount() &#123; return mDatas.size();&#125; 因此，一个基本的RecyclerView.Adapter如下： 123456789101112131415161718192021222324252627282930313233343536public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecyclerAdapter.MyViewHolder&gt; &#123; private Context context; private List&lt;String&gt; mDatas; public RecyclerAdapter(Context context, List&lt;String&gt; mDatas) &#123; this.context = context; this.mDatas = mDatas; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context) .inflate(R.layout.item_recycler_view, parent, false)); return holder; &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; holder.tv.setText(mDatas.get(position)); &#125; @Override public int getItemCount() &#123; return mDatas == null ? 0 : mDatas.size(); &#125; public static class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = (TextView) itemView.findViewById(R.id.tv); &#125; &#125;&#125; 3.3 RecyclerView.LayoutManagerLayoutManager的职责是摆放Item的位置，并且负责决定何时回收和重用Item。它有一个默认的实现：LinearLayoutManager，它可以用于垂直和水平列表。 RecyclerView.LayoutManager是一个抽象类，RecyclerView为我们提供3个实现类： LinearLayoutManager 现行管理器，支持横向、纵向。 GridLayoutManager 网格布局管理器 StaggeredGridLayoutManager 瀑布流式布局管理器 3.3.1 LinearlayoutManagerLinearlayoutManager是LayoutManager的默认实现。你可以使用这个类来创建垂直或水平列表。 1234// 设置RecyclerView布局方式为纵向布局LinearLayoutManager layoutManager = new LinearLayoutManager(context);layoutManager.setOrientation(LinearLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); 1234// 设置RecyclerView布局方式为横向布局LinearLayoutManager layoutManager= new LinearLayoutManager(this);layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);recyclerView.setLayoutManager(layoutManager); 运行程序，我们看到如下效果： 我们发现和ListView有一些不同，没有分割线让这个列表看起来很不美观，给RecyclerView设置分割线这个我们在下一小节说明。 当然LinearlayoutManager中还有一些很实用的API： findFirstVisibleItemPosition() 返回当前第一个可见Item的position findFirstCompletelyVisibleItemPosition() 返回当前第一个完全可见Item的position findLastVisibleItemPosition() 返回当前最后一个可见Item的position findLastCompletelyVisibleItemPosition() 返回当前最后一个完全可见Item的position 3.3.2 GridLayoutManager有两个构造方法： 123456789101112131415161718192021/*** Creates a vertical GridLayoutManager** @param context Current context, will be used to access resources.* @param spanCount 设置行数，因为默认是纵向的*/public GridLayoutManager(Context context, int spanCount) &#123; super(context); setSpanCount(spanCount);&#125;/*** @param context Current context, will be used to access resources.* @param spanCount 设置行数或者列数，根据方向* @param orientation 布局方向 HORIZONTAL or VERTICAL.* @param reverseLayout 是否反向显示 When set to true, layouts from end to start.*/public GridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) &#123; super(context, orientation, reverseLayout); setSpanCount(spanCount);&#125; 我们按如下代码设置： 1234567// 设置纵向的4列的表格布局GridLayoutManager layoutManager = new GridLayoutManager(this,4,GridLayoutManager.VERTICAL,false);recyclerView.setLayoutManager(layoutManager);// 设置横向的3行的表格布局GridLayoutManager layoutManager = new GridLayoutManager(this,3,GridLayoutManager.HORIZONTAL,false);recyclerView.setLayoutManager(layoutManager); 3.3.3 StaggeredGridLayoutManager我们来看StaggeredGridLayoutManager的构造方法，只有一个方法 1234567/*** Creates a StaggeredGridLayoutManager with given parameters.** @param spanCount 设置行数或者列数，根据方向，纵向就是列数，横向就是行数* @param orientation 方向*/public StaggeredGridLayoutManager(int spanCount, int orientation) &#123;&#125; 因此我们这样设置： 123// 设置纵向的瀑布流布局StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); 我们看效果和GridLayoutManager没有什么区别呢，那我们来小小的修改一下，你就可以看到它的强大。 我们给每个item的布局加入margin： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; android:background=&quot;@color/colorAccent&quot;&gt; &lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:textColor=&quot;#fff&quot; /&gt;&lt;/LinearLayout&gt; 然后我们在适配器的onBindViewHolder方法中为我们的item设置个随机的高度： 123456789101112131415161718//贴上部分代码，其余的请看附件 private List&lt;Integer&gt; mHeights; public RecyclerAdapter(Context context, List&lt;String&gt; mDatas) &#123; this.context = context; this.mDatas = mDatas; mHeights = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; mDatas.size(); i++) &#123; mHeights.add((int) (100 + Math.random() * 300)); &#125; &#125; @Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; ViewGroup.LayoutParams lp = holder.tv.getLayoutParams(); lp.height = mHeights.get(position); holder.tv.setLayoutParams(lp); &#125; 运行，我们可以看到效果，是不是很炫！ 3.4 RecyclerView.ItemDecoration通过设置 1recyclerView.addItemDecoration(new DividerDecoration(Context context, int orientation)); 来改变Item之间的偏移量或者对Item进行装饰。 例如，在上面的设置LinearlayoutManager之后加入以下代码，那么列表的效果就会发生改变： 1234// 给纵向显示RecyclerView设置分割线recyclerView.addItemDecoration(new DividerItemDecoration(activity,DividerItemDecoration.VERTICAL));// 给横向显示RecyclerView设置分割线recyclerView.addItemDecoration(new DividerItemDecoration(activity,DividerItemDecoration.HORIZONTAL)); 当然，你也可以对RecyclerView设置多个ItemDecoration，列表展示的时候会遍历所有的ItemDecoration并调用里面的绘制方法，对Item进行装饰。 RecyclerView.ItemDecoration是一个抽象类，可以通过重写以下三个方法，来实现Item之间的偏移量或者装饰效果： public void onDraw(Canvas c, RecyclerView parent) 装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡 public void onDrawOver(Canvas c, RecyclerView parent) 装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上 public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) 与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。 当然了，如果我们使用GridLayoutManager后，对于分割线，前面的DividerItemDecoration就不适用了，主要是因为它在绘制的时候，比如水平线，针对每个child的取值为： 12final int left = parent.getPaddingLeft();final int right = parent.getWidth() - parent.getPaddingRight(); 因为每个Item一行，这样是没问题的。而GridLayoutManager时，一行有多个childItem，这样就多次绘制了，并且GridLayoutManager时，Item如果为最后一列（则右边无间隔线）或者为最后一行（底部无分割线）。 按照上述的方法，我们可以自定义一个DividerGridItemDecoration。由于代码篇幅过长，我们在附件中给出。我们给GridLayoutManager设置DividerGridItemDecoration，运行效果如下： 3.5 RecyclerView.ItemAnimatorItemAnimator能够帮助Item实现独立的动画。 ItemAnimator作触发于以下三种事件： 某条数据被插入到数据集合中 从数据集合中移除某条数据 更改数据集合中的某条数据 幸运的是，在Android中默认实现了一个DefaultItemAnimator，我们可以通过以下代码为Item增加动画效果： 1recyclerView.setItemAnimator(new DefaultItemAnimator()); 在之前的版本中，当时据集合发生改变时，我们通过调用.notifyDataSetChanged()，来刷新列表，因为这样做会触发列表的重绘，所以并不会出现任何动画效果，因此需要调用一些以notifyItem*()作为前缀的特殊方法，比如： public final void notifyItemInserted(int position) 向指定位置插入Item public final void notifyItemRemoved(int position) 移除指定位置Item public final void notifyItemChanged(int position) 更新指定位置Item 下面我们使用DefaultItemAnimator来展示一下动画效果，修改代码如下： 在Activity中添加两个按钮add和remove负责动态插入和移除item 12345678910111213btnAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; adapter.addData(1); &#125; &#125;);btnRemove.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; adapter.removeData(2); &#125; &#125;); 在Adapter中添加两个方法： 12345678910public void addData(int position) &#123; mDatas.add(position, &quot;Insert&quot;); mHeights.add( (int) (100 + Math.random() * 300)); notifyItemInserted(position);&#125;public void removeData(int position) &#123; mDatas.remove(position); notifyItemRemoved(position);&#125; 运行结果如下： 3.6 Listeners很遗憾，RecyclerView并没有像ListView那样提供以下两个Item的点击监听事件 public void setOnItemClickListener(@Nullable OnItemClickListener listener) Item点击事件监听 public void setOnItemLongClickListener(OnItemLongClickListener listener) Item长按事件监听 但是这并不能阻拦我们的脚步，我可以定义这样的两个方法。 12345678910public interface OnItemClickLitener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position);&#125;private OnItemClickLitener litener;public void setLitener(OnItemClickLitener litener) &#123; this.litener = litener;&#125; 在onBindViewHolder方法中给需要响应点击事件的控件设置监听器： 12345678910111213141516171819// 如果设置了回调，则响应点击事件holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (litener != null) &#123; litener.onItemClick(v, position); &#125; &#125;&#125;);holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; if (litener != null) &#123; litener.onItemLongClick(v, position); &#125; return false; &#125;&#125;); 在Activity中设置这个方法： 1234567891011adapter.setLitener(new RecyclerAdapter.OnItemClickLitener() &#123; @Override public void onItemClick(View view, int position) &#123; Toast.makeText(activity,&quot;第&quot;+position+&quot;项被点击了&quot;,Toast.LENGTH_SHORT).show(); &#125; @Override public void onItemLongClick(View view, int position) &#123; Toast.makeText(activity,&quot;第&quot;+position+&quot;项被长按了&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;); 效果如图： 源码地址：http://download.csdn.net/detail/u012771445/9885640]]></content>
      <categories>
        <category>Android基础教程</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 列表生成式]]></title>
    <url>%2F2017%2F06%2F23%2Fpython-junior-9%2F</url>
    <content type="text"><![CDATA[生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)： 12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？ 方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)... &gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。 写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 任务请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, …, 99x100] 提示：range(1, 100, 2) 可以生成list [1, 3, 5, 7, 9,…] 12#Listcomprehensions1.pyprint [x*(x+1) for x in range(1, 100, 2)] 复杂表达式使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。 假设有如下的dict： 1d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125; 完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： 12345tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()]print &apos;&lt;table&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 注：字符串可以通过 % 进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个 list 拼接成一个字符串。 把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了： 123456&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 任务在生成的表格中，对于没有及格的同学，请把分数标记为红色。 提示：红色可以用 实现。 123456789101112#Listcomprehensions2.pyd = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;def generate_tr(name, score): if score &lt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score)tds = [generate_tr(name,score) for name, score in d.iteritems()]print &apos;&lt;table border=&quot;1&quot;&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 任务请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。 提示： isinstance(x, str) 可以判断变量 x 是否是字符串； 字符串的 upper() 方法可以返回大写的字母。 1234#Listcomprehensions3.pydef uperList(L): return [s.upper() for s in L if isinstance(s, str)]print uperList([&apos;Hello&apos;, &apos;world&apos;, 101]) 多层表达式for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。 对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： 12&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;][&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;] 翻译成循环代码就像下面这样： 1234L = []for m in &apos;ABC&apos;: for n in &apos;123&apos;: L.append(m + n) 任务利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。 123#Listcomprehensions4.pyL= [100*a+10*b+c for a in range(1,10) for b in range(10) for c in range(10) if a == c]print L]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 迭代]]></title>
    <url>%2F2017%2F06%2F23%2Fpython-junior-8%2F</url>
    <content type="text"><![CDATA[什么是迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。 在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码： 123for (i=0; i&lt;list.length; i++) &#123; n = list[i];&#125; 可以看出，Python的for循环抽象程度要高于Java的for循环。 因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。 因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。 1234注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：1. 有序集合：list，tuple，str和unicode；2. 无序集合：set3. 无序集合并且具有 key-value 对：dict 而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。 迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。 任务请用for循环迭代数列 1-100 并打印出7的倍数。 12345#Iteration1.pyL = range(1,101)for num in L: if num %7==0: print num 索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。 对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 enumerate() 函数： 12345678&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul 使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 变成了类似： 1[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)] 因此，迭代的每一个元素实际上是一个tuple： 1234for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 任务zip()函数可以把两个 list 变成一个 list： 12&gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 提示：考虑使用zip()函数和range()函数 1234Iteration2.pyL = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]for index,name in zip(range(1,len(L)+1),L): print index,&apos;-&apos;,name 迭代dict的value我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。 如果我们希望迭代 dict 对象的value，应该怎么做？ dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个itervalues() 方法，用itervalues() 方法替代 values() 方法，迭代效果完全一样： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 任务给定一个dict： d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 请计算所有同学的平均分。 123456#Iteration3.pyd = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for i in d.itervalues(): sum = sum +iprint sum/len(d) 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。 首先，我们看看 dict 对象的 items() 方法返回的值： 123&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; print d.items()[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value： 123456&gt;&gt;&gt; for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 任务请根据dict： d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 打印出 name : score，最后再打印出平均分 average : score。 1234567#Iteration4.pyd = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for name,score in d.iteritems(): print name,&apos;:&apos;,score sum = sum + scoreprint &quot;average&quot;,&apos;:&apos;,sum/len(d)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 切片]]></title>
    <url>%2F2017%2F06%2F22%2Fpython-junior-7%2F</url>
    <content type="text"><![CDATA[对list进行切片取一个list的部分元素是非常常见的操作。比如，一个list如下： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 取前3个元素，应该怎么做？ 笨办法： 12&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 之所以是笨办法是因为扩展一下，取前N个元素就没辙了。 取前N个元素，也就是索引为0-(N-1)的元素，可以用循环： 1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 12&gt;&gt;&gt; L[0:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： 12&gt;&gt;&gt; L[1:3][&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个:，表示从头到尾： 12&gt;&gt;&gt; L[:][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。 切片操作还可以指定第三个参数： 12&gt;&gt;&gt; L[::2][&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 任务range()函数可以创建一个数列： 12&gt;&gt;&gt; range(1, 101)[1, 2, 3, ..., 100] 请利用切片，取出： 前10个数； 3的倍数； 不大于50的5的倍数。 12345#SliceQues1.pyL = range(1,101)print L[:10]print L[2::3]print L[4:51:5] 倒序切片对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 12345678910111213&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L[-2:][&apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L[:-2][&apos;Adam&apos;, &apos;Lisa&apos;]&gt;&gt;&gt; L[-3:-1][&apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L[-4:-1:2][&apos;Adam&apos;, &apos;Bart&apos;] 记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。 任务利用倒序切片对 1 - 100 的数列取出： * 最后10个数； * 最后10个5的倍数。 1234#SliceQues2.pyL = range(1,101)print L[-10:]print L[4::5][-10:] 对字符串切片字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 123456&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[-3:]&apos;EFG&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。 任务字符串有个方法 upper() 可以把字符变成大写字母： 12&gt;&gt;&gt; &apos;abc&apos;.upper()&apos;ABC&apos; 但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。 12345SliceQues3.pydef upperFirstChar(s): return s[:1].upper()+s[1:]print upperFirstChar(&apos;hello&apos;)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 函数]]></title>
    <url>%2F2017%2F06%2F22%2Fpython-junior-6%2F</url>
    <content type="text"><![CDATA[Python之什么是函数我们知道圆的面积计算公式为： 1S = πr² 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积： 123456r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 * r1 * r1s2 = 3.14 * r2 * r2s3 = 3.14 * r3 * r3 当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 x x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。 有了函数，我们就不再每次写s = 3.14 x x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle 本身只需要写一次，就可以多次调用。 抽象是数学中非常常见的概念。举个例子： 计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作： 123100∑nn=1 这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。 而且，这种抽象记法是可扩展的，比如： 123100∑(n²+1)n=1 还原成加法运算就变成了： 1(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1) 可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。 写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。 Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。 Python之调用函数Python内置了很多有用的函数，我们可以直接调用。 要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。 12可以直接从Python的官方网站查看文档：http://docs.python.org/2/library/functions.html#abs 也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。 调用 abs 函数： 123456&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： 1234&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： 1234&gt;&gt;&gt; abs(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): &apos;str&apos; 而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x==y，返回 0，如果 x&gt;y，返回 1： 123456&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0 Python内置的常用函数还包括数据类型转换函数，比如 int()函数可以把其他数据类型转换为整数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(12.34)12 str()函数把其他类型转换成 str： 1234&gt;&gt;&gt; str(123)&apos;123&apos;&gt;&gt;&gt; str(1.23)&apos;1.23&apos; Python之编写函数在Python中，定义一个函数要使用def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。 我们以自定义一个求绝对值的 my_abs 函数为例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。 return None可以简写为return。 Python函数之返回多值函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： # math包提供了sin()和 cos()函数，我们先用import引用它： 12345import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 这样我们就可以同时获得返回值： 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0) 用print打印返回结果，原来返回值是一个tuple！ 但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 Python之递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘 n! = 1 * 2 3 … * n，用函数 fact(n)表示，可以看出： 1fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n 所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一个递归函数。可以试试： 123456&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 任务汉诺塔 (http://baike.baidu.com/view/191666.htm) 的移动也可以看做是递归函数。 我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为： 如果a只有一个圆盘，可以直接移动到c； 如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。 请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤： move(n, a, b, c) 例如，输入 move(2, ‘A’, ‘B’, ‘C’)，打印出： A –&gt; BA –&gt; CB –&gt; C 12345678910#HanoiTower.pydef move(n,a,b,c): if n == 1: print a,&quot;--&gt;&quot;,c return move(n-1, a, c, b) print a,&quot;--&gt;&quot;,c move(n-1, b, c, a) move(4, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;); Python之定义默认参数定义函数的时候，还可以有默认参数。 例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(&apos;123&apos;, 8)83 int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。 可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。 我们来定义一个计算 x 的N次方的函数: 123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样一来，计算平方就不需要传入两个参数了： 12&gt;&gt;&gt; power(5)25 由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面： 123456# OK:def fn1(a, b=1, c=2): pass# Error:def fn2(a=1, b): pass 任务请定义一个 greet() 函数，它包含一个默认参数，如果没有传入，打印 ‘Hello, world.’，如果传入，打印 ‘Hello, xxx.’ 123456#VariableParams.pydef greet(a=&apos;world&apos;): print &apos;Hello,&apos;+a+&apos;.&apos; greet()greet(&apos;python&apos;) Python之定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： 12def fn(*args): print args 可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数： 12345678&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn(&apos;a&apos;)(&apos;a&apos;,)&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;b&apos;)&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数： 12def average(*args): ... 这样，在调用的时候，可以这样写： 123456&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4 任务请编写接受可变参数的 average() 函数。 12345678910111213#VariableParams.pydef average(*args): if len(args)==0: print 0 else: sum = 0.0 for s in args: sum = sum+s print sum/len(args) average()average(1,2)average(1,2,3,4)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 Dict和Set类型]]></title>
    <url>%2F2017%2F06%2F18%2Fpython-junior-5%2F</url>
    <content type="text"><![CDATA[Python之什么是dict我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 或者考试的成绩列表： 1[95, 85, 59] 但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。 如果把名字和分数关联起来，组成类似的查找表： 123&apos;Adam&apos; ==&gt; 95&apos;Lisa&apos; ==&gt; 85&apos;Bart&apos; ==&gt; 59 给定一个名字，就可以直接查到分数。 Python的 dict 就是专门干这件事的。用 dict 表示“名字”-“成绩”的查找表如下： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。 花括号 {} 表示这是一个dict，然后按照key: value, 写出来即可。最后一个 key: value 的逗号可以省略。 由于dict也是集合，len() 函数可以计算任意集合的大小： 12&gt;&gt;&gt; len(d)3 注意: 一个 key-value 算一个，因此，dict大小为3。 Python之访问dict我们已经能创建一个dict，用于表示名字和成绩的对应关系： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 那么，如何根据名字来查找对应的成绩呢？ 可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key： 1234567&gt;&gt;&gt; print d[&apos;Adam&apos;]95&gt;&gt;&gt; print d[&apos;Paul&apos;]Traceback (most recent call last): File &quot;index.py&quot;, line 11, in &lt;module&gt; print d[&apos;Paul&apos;]KeyError: &apos;Paul&apos; 注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。 要避免 KeyError 发生，有两个办法： 一是先判断一下 key 是否存在，用 in 操作符： 12if &apos;Paul&apos; in d: print d[&apos;Paul&apos;] 如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。 二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None： 1234&gt;&gt;&gt; print d.get(&apos;Bart&apos;)59&gt;&gt;&gt; print d.get(&apos;Paul&apos;)None Python中dict的特点dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。 不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。 由于dict是按 key 查找，所以，在一个dict中，key不能重复。 dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 当我们试图打印这个dict时： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。 dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。 可以试试用list作为key时会报什么样的错误。 不可变这个限制仅作用于key，value是否可变无所谓： 12345&#123; &apos;123&apos;: [1, 2, 3], # key 是 str，value是list 123: &apos;123&apos;, # key 是 int，value 是 str (&apos;a&apos;, &apos;b&apos;): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean&#125; 最常用的key还是字符串，因为用起来最方便。 Python更新dictdict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 要把新同学’Paul’的成绩 72 加进去，用赋值语句： 1&gt;&gt;&gt; d[&apos;Paul&apos;] = 72 再看看dict的内容： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value： 123&gt;&gt;&gt; d[&apos;Bart&apos;] = 60&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 60&#125; Python之 遍历dict由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。 直接使用for循环可以遍历 dict 的 key： 1234567&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; for key in d:... print key... LisaAdamBart 由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。 Python中什么是setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。 有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。 set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。 创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： 1&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) 可以查看 set 的内容： 12&gt;&gt;&gt; print sset([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;]) 请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。 因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？ 12345&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;C&apos;])&gt;&gt;&gt; print sset([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])&gt;&gt;&gt; len(s)3 结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。 Python之 访问set由于set存储的是无序集合，所以我们没法通过索引来访问。 访问 set中的某个元素实际上就是判断一个元素是否在set中。 例如，存储了班里同学名字的set： 1&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]) 我们可以用 in 操作符判断： Bart是该班的同学吗？ 12&gt;&gt;&gt; &apos;Bart&apos; in sTrue Bill是该班的同学吗？ 12&gt;&gt;&gt; &apos;Bill&apos; in sFalse bart是该班的同学吗？ 12&gt;&gt;&gt; &apos;bart&apos; in sFalse 看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。 Python之 set的特点set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。 set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。 最后，set存储的元素也是没有顺序的。 set的这些特点，可以应用在哪些地方呢？ 星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。 假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？ 可以用 if 语句判断，但这样做非常繁琐： 12345x = &apos;???&apos; # 用户输入的字符串if x!= &apos;MON&apos; and x!= &apos;TUE&apos; and x!= &apos;WED&apos; ... and x!= &apos;SUN&apos;: print &apos;input error&apos;else: print &apos;input ok&apos; 注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。 如果事先创建好一个set，包含’MON’ ~ ‘SUN’： 1weekdays = set([&apos;MON&apos;, &apos;TUE&apos;, &apos;WED&apos;, &apos;THU&apos;, &apos;FRI&apos;, &apos;SAT&apos;, &apos;SUN&apos;]) 再判断输入是否有效，只需要判断该字符串是否在set中： 12345x = &apos;???&apos; # 用户输入的字符串if x in weekdays: print &apos;input ok&apos;else: print &apos;input error&apos; 这样一来，代码就简单多了。 Python之 遍历set由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。 直接使用 for 循环可以遍历 set 的元素： 1234567&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;])&gt;&gt;&gt; for name in s:... print name... LisaAdamBart 注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。 Python之 更新set由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事： 一是把新的元素添加到set中，二是把已有元素从set中删除。 添加元素时，用set的add()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4]) 如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; print sset([1, 2, 3]) 删除set中的元素时，用set的remove()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3]) 如果删除的元素不存在set中，remove()会报错： 12345&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.remove(4)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 4 所以用add()可以直接添加，而remove()前需要判断。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 条件判断和循环]]></title>
    <url>%2F2017%2F06%2F18%2Fpython-junior-4%2F</url>
    <content type="text"><![CDATA[Python之if语句计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现： 12345age = 20if age &gt;= 18: print &apos;your age is&apos;, age print &apos;adult&apos;print &apos;END&apos; 注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。 缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。 注意: if 语句后接表达式，然后用:表示代码块开始。 如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车： 1234567&gt;&gt;&gt; age = 20&gt;&gt;&gt; if age &gt;= 18:... print &apos;your age is&apos;, age... print &apos;adult&apos;...your age is 20adult Python之 if-else当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块： 12if age &gt;= 18: print &apos;adult&apos; 如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，方法是再写一个 if: 12if age &lt; 18: print &apos;teenager&apos; 或者用 not 运算： 12if not age &gt;= 18: print &apos;teenager&apos; 这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if … else … 语句把它们统一起来： 1234if age &gt;= 18: print &apos;adult&apos;else: print &apos;teenager&apos; 利用 if … else … 语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。 注意: else 后面有个“:”。 Python之 if-elif-else有的时候，一个 if … else … 还不够用。比如，根据年龄的划分： 123条件1：18岁或以上：adult条件2：6岁或以上：teenager条件3：6岁以下：kid 我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3： 1234567if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: print &apos;kid&apos; 这样写出来，我们就得到了一个两层嵌套的 if … else … 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby： 12345678910if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: if age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; 这种缩进只会越来越多，代码也会越来越难看。 要避免嵌套结构的 if … else …，我们可以用 if … 多个elif … else … 的结构，一次写完所有的规则： 12345678if age &gt;= 18: print &apos;adult&apos;elif age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 3: print &apos;kid&apos;else: print &apos;baby&apos; elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。 特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。 Python之 for循环list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list： 1234L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]print L[0]print L[1]print L[2] 如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。 这时，循环就派上用场了。 Python的 for 循环就可以依次把list或tuple的每个元素迭代出来： 123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]for name in L: print name 注意: name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。 这样一来，遍历一个list或tuple就非常容易了。 Python之 while循环和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。 比如要从 0 开始打印不大于 N 的整数： 12345N = 10x = 0while x &lt; N: print x x = x + 1 while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。 在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。 如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。 Python之 break退出循环用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。 比如计算1至100的整数和，我们用while来实现： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。 Python之 continue继续循环在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。 假设我们已经写好了利用for循环计算平均分的代码： 1234567L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: sum = sum + x n = n + 1print sum / n 现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环： 12345for x in L: if x &lt; 60: continue sum = sum + x n = n + 1 Python之 多重循环在循环内部，还可以嵌套循环，我们来看一个例子： 123for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]: print x + y x 每循环一次，y 就会循环 3 次，这样，我们可以打印出一个全排列： A1A2A3B1B2B3C1C2C3]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 List和Tuple类型]]></title>
    <url>%2F2017%2F06%2F18%2Fpython-junior-3%2F</url>
    <content type="text"><![CDATA[Python创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。 构造list非常简单，按照上面的代码，直接用[ ]把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list： 123&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; classmates # 打印classmates变量的内容[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] 由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据： 1&gt;&gt;&gt; L = [&apos;Michael&apos;, 100, True] 一个元素也没有的list，就是空list： 1&gt;&gt;&gt; empty_list = [] Python按照索引访问list由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 通过索引来获取list中的指定元素。 需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。 因此，要打印第一名同学的名字，用 L[0]: 12&gt;&gt;&gt; print L[0]Adam 要打印第二名同学的名字，用 L[1]: 12&gt;&gt;&gt; print L[1]Lisa 要打印第三名同学的名字，用 L[2]: 12&gt;&gt;&gt; print L[2]Bart 要打印第四名同学的名字，用 L[3]: 1234&gt;&gt;&gt; print L[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。 所以，使用索引时，千万注意不要越界。 Python之倒序访问list我们还是用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 我们可以用 -1 这个索引来表示最后一个元素： 12&gt;&gt;&gt; print L[-1]Bart 类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示： 12345678&gt;&gt;&gt; print L[-2]Lisa&gt;&gt;&gt; print L[-3]Adam&gt;&gt;&gt; print L[-4]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。 使用倒序索引时，也要注意不要越界。 Python之添加新元素现在，班里有3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？ 第一个办法是用 list 的append()方法，把新同学追加到 list 的末尾： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.append(&apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] append()总是把新的元素添加到 list 的尾部。 如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？ 方法是用list的insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.insert(0, &apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Paul&apos;, &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。 Python从list删除元素我们怎么把Paul 从现有的list中删除呢？ 如果Paul同学排在最后一个，我们可以用list的pop()方法删除： 12345&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L.pop()&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。 如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;] 要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用pop(2)把Paul删掉： 1234&gt;&gt;&gt; L.pop(2)&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] Python中替换元素假设现在班里仍然是3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。 另一个办法是直接用Paul把Bart给替换掉： 123&gt;&gt;&gt; L[2] = &apos;Paul&apos;&gt;&gt;&gt; print LL = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;] 对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。 由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作： 1&gt;&gt;&gt; L[-1] = &apos;Paul&apos; Python之创建tupletuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。 同样是表示班里同学的名称，用tuple表示如下： 1&gt;&gt;&gt; t = (&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;) 创建tuple和创建list唯一不同之处是用( )替代了[ ]。 现在，这个t就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素。 1234&gt;&gt;&gt; t[0] = &apos;Paul&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment Python之创建单元素tupletuple和list一样，可以包含 0 个、1个和任意多个元素。 包含多个元素的 tuple，前面我们已经创建过了。 包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示： 123&gt;&gt;&gt; t = ()&gt;&gt;&gt; print t() 创建包含1个元素的 tuple 呢？来试试： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; print t1 好像哪里不对！t 不是 tuple ，而是整数1。 因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。 正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; print t(1,) Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。 多元素 tuple 加不加这个额外的“,”效果是一样的： 123&gt;&gt;&gt; t = (1, 2, 3,)&gt;&gt;&gt; print t(1, 2, 3) Python之“可变”的tuple前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple： 1&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;]) 注意到 t 有 3 个元素：‘a’，’b’和一个list：[‘A’, ‘B’]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到： 1&gt;&gt;&gt; L = t[2] 然后，我们把list的两个元素改一改： 12&gt;&gt;&gt; L[0] = &apos;X&apos;&gt;&gt;&gt; L[1] = &apos;Y&apos; 再看看tuple的内容： 12&gt;&gt;&gt; print t(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 不是说tuple一旦定义后就不可变了吗？怎么现在又变了？ 别急，我们先看看定义的时候tuple包含的3个元素： 当我们把list的元素‘A’和’B’修改为‘X’和’Y’后，tuple变为： 表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。 tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 Python中变量和数据类型]]></title>
    <url>%2F2017%2F06%2F17%2Fpython-junior-2%2F</url>
    <content type="text"><![CDATA[Python中数据类型计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种： 一、整数 Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 二、浮点数 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 三、字符串 字符串是以&#39;&#39;或&quot;&quot;括起来的任意文本，比如‘abc’，“xyz”等等。请注意，‘’或“”本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。 四、布尔值 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为 True，and运算结果才是 True。 or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。 not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。 五、空值 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 Python之print语句print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下： 1&gt;&gt;&gt; print &apos;hello, world&apos; print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出： 12&gt;&gt;&gt; print &apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;The quick brown fox jumps over the lazy dog print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的： print也可以打印整数，或者计算结果： 1234&gt;&gt;&gt; print 300300 #运行结果&gt;&gt;&gt; print 100 + 200300 #运行结果 因此，我们可以把计算100 + 200的结果打印得更漂亮一点： 12&gt;&gt;&gt; print &apos;100 + 200 =&apos;, 100 + 200100 + 200 = 300 #运行结果 Python的注释Python的注释以#开头，后面的文字直到行尾都算注释 12# 这一行全部都是注释...print &apos;hello&apos; # 这也是注释 Python中什么是变量在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如： 1a = 1 变量a是一个整数。 1t_007 = &apos;T007&apos; 变量t_007是一个字符串。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： 1234a = 123 # a是整数print aa = &apos;imooc&apos; # a变为字符串print a 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： 12int a = 123; // a是整数类型变量a = &quot;mooc&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 最后，理解变量在计算机内存中的表示也非常重要。当我们写：a = &#39;ABC&#39;时，Python解释器干了两件事情： 在内存中创建了一个&#39;ABC&#39;的字符串； 在内存中创建了一个名为a的变量，并把它指向&#39;ABC&#39;。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： 1234a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print b 最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事： 执行a = &#39;ABC&#39;，解释器创建了字符串 ‘ABC’和变量 a，并把a指向 ‘ABC’： 执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串’ABC’： 执行a = &#39;XYZ&#39;，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改： 所以，最后打印变量b的结果自然是&#39;ABC&#39;了。 Python中定义字符串字符串可以用&#39;&#39;或者&quot;&quot;括起来表示。 如果字符串本身包含&#39;怎么办？比如我们要表示字符串I&#39;m OK，这时，可以用&quot; &quot;括起来表示： 1&quot;I&apos;m OK&quot; 类似的，如果字符串包含&quot;，我们就可以用&#39; &#39;括起来表示： 1&apos;Learn &quot;Python&quot; in imooc&apos; 如果字符串既包含&#39;又包含&quot;，就需要对字符串的某些特殊字符进行“转义”，Python字符串用\进行转义。 要表示字符串 Bob said &quot;I&#39;m OK&quot;.由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 1&apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; 注意：转义字符 \ 不计入字符串的内容中。 常用的转义字符还有： 123\n 表示换行\t 表示一个制表符\\ 表示 \ 字符本身 Python中raw字符串与多行字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀r，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： 1r&apos;\(~_~)/ \(~_~)/&apos; 但是r&#39;...&#39;表示法不能表示多行字符串，也不能表示包含&#39;和 &quot;的字符串。 如果要表示多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： 123&apos;&apos;&apos;Line 1Line 2Line 3&apos;&apos;&apos; 上面这个字符串的表示方法和下面的是完全一样的： ‘Line 1\nLine 2\nLine 3’ 还可以在多行字符串前面添加r，把这个多行字符串也变成一个raw字符串： 123r&apos;&apos;&apos;Python is created by &quot;Guido&quot;.It is free and easy to learn.Let&apos;s start learn Python in imooc!&apos;&apos;&apos; Python中Unicode字符串Python在添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： 12print u&apos;中文&apos;中文 注意: 不加 u ，中文就不能正常显示。 Unicode字符串除了多了一个u之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效： 转义： 1u&apos;中文\n日文\n韩文&apos; 多行： 12u&apos;&apos;&apos;第一行第二行&apos;&apos;&apos; raw+多行： 123ur&apos;&apos;&apos;Python的Unicode字符串支持&quot;中文&quot;,&quot;日文&quot;,&quot;韩文&quot;等多种语言&apos;&apos;&apos; 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1# -*- coding: utf-8 -*- Python中整数和浮点数Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。 基本的运算： 1231 + 2 + 3 # ==&gt; 64 * 5 - 6 # ==&gt; 147.5 / 8 + 2.1 # ==&gt; 3.0375 使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层： 12(1 + 2) * 3 # ==&gt; 9(2.2 + 3.3) / (1.5 * (9 - 0.3)) # ==&gt; 0.42145593869731807 和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数： 121 + 2 # ==&gt; 整数 31.0 + 2.0 # ==&gt; 浮点数 3.0 但是整数和浮点数混合运算的结果就变成浮点数了： 11 + 2.0 # ==&gt; 浮点数 3.0 Python中布尔类型我们已经了解了Python支持布尔类型的数据，布尔类型只有True和False两种值，但是布尔类型有以下几种运算： 与运算：只有两个布尔值都为 True 时，计算结果才为 True。 1234True and True # ==&gt; TrueTrue and False # ==&gt; FalseFalse and True # ==&gt; FalseFalse and False # ==&gt; False 或运算：只要有一个布尔值为 True，计算结果就是 True。 1234True or True # ==&gt; TrueTrue or False # ==&gt; TrueFalse or True # ==&gt; TrueFalse or False # ==&gt; False 非运算：把True变为False，或者把False变为True： 12not True # ==&gt; Falsenot False # ==&gt; True 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： 12a = Trueprint a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串&#39;&#39;和None看成 False，其他数值和非空字符串都看成 True，所以： 12True and &apos;a=T&apos; 计算结果是 &apos;a=T&apos;继续计算 &apos;a=T&apos; or &apos;a=F&apos; 计算结果还是 &apos;a=T&apos; 要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 在计算a and b时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算a or b时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 python基本配置]]></title>
    <url>%2F2017%2F06%2F17%2Fpython-junior-1%2F</url>
    <content type="text"><![CDATA[写在前面我是一个Android开发工程师，对于python也属于初学者，我希望通过记录笔记的方式记录我学习python的过程，对自己是一种整理与升华的过程，希望能够对其他python入门学习的开发者也能起到一点作用。 我的这套笔记中使用的python版本是python2.7，至于为什么不用python3，我觉得现在对于python2的教程更多一些，方便学习。另外我也属于第一次接触python，如果有哪里写的不对不严谨的地方，请您在评论区指正，我会虚心接受。 同时，如果你也对python开发感兴趣，不妨我们一起交流，互相学习，共同进步。 安装python通过安装包安装如果你想更新至最新的2.7.x或3.x版本，你可以直接从python官网下载二进制安装文件。 点击上面的链接，然后选择需要的版本。Python 2和3的最新版本就在页面的顶部。选择好Python版本之后，你就能看到针对不同操作系统的安装包下载链接了。 我建议你下载相应系统的安装器，因为它会处理好所有的安装事宜，只需要确保下载了自己电脑CPU架构（32位或64位）对应的文件即可。笔者下载的则是python2.7.13-Mac OS X 64-bit/32-bit installer。 双击安装器之后，只要按照提示操作，一路下一步，就可以顺利安装Python。 安装成功后，打开mac终端，输入python回车，然后就会出现安装的Python的版本信息。键入： 1&gt;&gt;&gt; print &apos;hello,Python!&apos; 输出如下图所示 mac配置Python集成开发环境（Eclipse +Python+Pydev) 下载Mac版64位的Eclipse。 进入到Eclipse官方网站的下载页面（http://www.eclipse.org/downloads/） 下载JDK以及安装 进入到java开发语言包JDK的官方下载页面（http://www.oracle.com/technetwork/java/javase/downloads/index.html） 下载后运行安装文件，按步骤安装jdk。因为本套教程不是讲解java开发，所以这里不详细介绍jdk的安装和配置了。在终端键入 java -version 出现以下jdk信息： 下载安装Pydev插件 打开eclipse，菜单栏Help-Install New Software… 打开页面后，1点击Add…，2输入Location值为“http://www.pydev.org/updates” ，name值任意。输入完成后点击ok按钮。 在install中选中第一项，然后点击next，一路next。同意它所有的申请。 配置eclipse的python开发环境 对eclipse进行设置，具体步骤如下图所示： 第一个python工程，步骤如下： 在src文件夹new file，输入文件名为hello.py，点击finish 在文件中输入如图所示的代码，然后执行，环境正常搭建完成。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[博客我来啦！]]></content>
  </entry>
  <entry>
    <title><![CDATA[2016-2017 毕业1年总结]]></title>
    <url>%2F2017%2F05%2F28%2Fgraduation-1st%2F</url>
    <content type="text"><![CDATA[​ 自2016年6月本科毕业论文答辩之后正式离开学校，如今已经1年，本人Android攻城狮一枚，23岁，身处帝都，定位西二旗，互联网软件公司，这一年，经历的事情太多，本来要做一款App，但是实在是没有什么时间，算了，写几个字吧，算是对这一年的总结和回顾，同时也对下一年做一个准备。 ​ 先说说这一年的变化吧。 变化 这一年Android系统版本从Android6.0到7.0，前些日子又来了8.0。Google把之前挖的坑填平了一些，但是又继续挖了更多的坑。其实Google一向如此。 这一年电脑内存从4G升到6G升到12G，硬盘加固。 开发工具从Eclipse转向Android Studio，AS原来就是谷歌的巨坑，不过最近几个版本优化的十分不错，现在AS用的很溜。 开发语言目前主要还是Java，java能力我觉得可以从40%的水平提升到60%，前路漫漫，同时也涉猎html、js、jsp还有一些Java后台框架，还有Python也在不断学习中。对了，有一个事情不可不提，今年Google I/O大会竟然提出Kotlin，然后现在网上各种Kotlin将作为Android第一开发语言的言论铺天盖地而来，然后Kotlin官网就多了一句Now official on Android，我已是无力吐槽，我周围的人都在说学会了Kotlin万一把Java Api给整混乱就犯不上了。 认识的人也越多了，各种社交软件零零散散加起来应该多了两百多人吧。 薪资也有一丢丢提高，隐私就不说了。 不变的 这一年，我还是早上7点之前起床，不睡懒觉。 我用的还是那款手机，MI NOTE LTE。 依然还有一颗热爱生活、积极向上的心态。 总结一下 工作上 一入编程深似海啊，面对着每天至少8个小时的工作，也许8小时都是奢望，确实是充实。长时间的工作，成长贼快，面对如浩瀚汪洋般的Coding世界，只有不断学习，不断查阅资料，这点度娘不行，还得Google。话说起来柯洁0：3负于AlphaGo还是有点小小遗憾，不过我觉的就算再智能，也得加上“人工”两个字。 这一年主要负责和参与的企业级项目有7个，目前都在迭代，都可以在AppStore去下载玩玩看，大概修复缺陷和新增功能加一起大概500+个，你要知道每个人写的代码风格不尽相同，阅读别人的代码你都恨不得每行加上注释SB。最怕那种不谈什么底层原理、运行效率、算法优化什么的主，老夫Coding就是一把梭！真想一脚踹飞他！ 总的来说我觉的进步还是不小的，原来网上的一些慕课只来的还需去看视频，现在查阅一下资料就能懂，被人教会和主动学会的感觉是不一样的。我下一步的计划就是要教会别人。 生活中 这一年，我长了一岁，家人也老了一岁，希望家人都健健康康。想想从初中开始就没怎么陪伴过家人，现在是真的觉得应该时常陪在家人身边，家庭最重要！还是觉的小时候好，不是因为小时候的自己可以无忧无虑，而是小时候亲人都在，长大之后慢慢就会有亲人要离开我们。小时候真好。 这一年，我和她在一起第4个念头，这一年我们都在北京，我们基本走遍北京的所有景点，吃了很多美食。下一步我觉的还要发掘一些新的玩处，玩出水平。 说说我的工作吧 说说工作就不可避免的要谈到大学生活。 这一年，可以说是在为大学买单，大学不如名校，其实已经被人家落下了，如果你不够十二分的努力，那么就被拉的更远，不说别的，单单说基础编程能力，你以为你在大学如何如何，殊不知人家已经起飞，而自己还在跑道上滑行。这个时候就要付出更多努力，加大马力，同时还要掌握正确的方法方式，追上人家，超越不是随便讲出来的，但并不是不可能完成。 我不觉的我的第一份工作有多好，但是我把这个当作是充电与追赶的跳板。出身不好就要更加努力，基础打牢。 接下来的一年，我要系统学习其他几种编程语言还有一些其他的技术，目前来说应该是python和Java后台，同时要从架构和底层的角度多多考虑。 接下来的一年，我要用更多的时间陪伴家人和爱人。 接下来的一年，我要继续保持阳光的心态，保证健康的身体。 ​ 不求能成为榜样，但求能以自己的绵薄之力为社会、为家人、为他人做出那么一点点贡献。 ​ 好了，就写这么多了，端午的假期得早点睡！ ​ 2017年5月28日 夜 ​ 北京 昌平]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
</search>
