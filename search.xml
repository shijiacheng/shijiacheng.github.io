<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>MVC vs. MVP vs. MVVM on Android</title>
      <link href="/2018/07/01/mvx/"/>
      <url>/2018/07/01/mvx/</url>
      <content type="html"><![CDATA[<p>在过去的几年里，将Android应用程序转变成逻辑组件的方法已经逐渐成熟。很大程度上摆脱了MVC模式，转而采用更模块化、可测试的模式。</p><p>Model View Presenter (MVP) &amp; Model View ViewModel (MVVM)是最广泛被采用的两种替代方案。本文不去讨论哪种方式更适合于Android应用开发，只是通过案例来看到每种模式是如何编写的。</p><a id="more"></a><p>本文通过实现一个井字游戏，分别通过MVC、MVP、MVVM三种模式实现游戏效果。源代码已经上传到<a href="https://coding.net/u/shijiacheng/p/MVX/git" target="_blank" rel="external">仓库</a>中。</p><p><img src="https://coding.net/u/shijiacheng/p/MVX/git/raw/master/images/井字游戏效果图.png" alt=""></p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>Model, View, Controller将应用程序在宏观层面分为3中职责。</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model模型是应用程序中的数据+状态+业务逻辑。可以说是应用程序的大脑，不受View视图和Controller控制器的束缚，因此很多情况下是可以复用的。</p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View视图是Model的展现，负责呈现UI并在用户与应用程序交互时与Controller通信。在MVC架构中，视图通常很“愚蠢”，因为他们不了解底层模型，也没有对状态的理解，或者当用户通过单击按钮，键入值等进行交互时要做什么。这个想法是越少他们知道他们对模型的耦合越松散，因此他们要改变的就越灵活。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller是将app粘在一起的胶水，它是应用程序中的主控制器。当View告诉Controller用户单击按钮时，Controller决定如何与Model进行相应的交互。根据Model中的数据更改， Controller可以根据需要更新View的状态。在Android应用程序中，Controller几乎总是由Activity或Fragment来担任的。</p><p><strong>这就是我们的井字游戏中每个类扮演的角色</strong></p><p><img src="https://coding.net/u/shijiacheng/p/MVX/git/raw/master/images/mvc模型角色图.png" alt=""></p><p>让我们更详细地检查Controller。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public class MVCTicTacToeActivity extends AppCompatActivity &#123;</div><div class="line">    private static String TAG = MVCTicTacToeActivity.class.getName();</div><div class="line"></div><div class="line">    private Board model;</div><div class="line"></div><div class="line">    private ViewGroup buttonGrid;</div><div class="line">    private View winnerPlayerViewGroup;</div><div class="line">    private TextView winnerPlayerLabel;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_mvc_tictactoe);</div><div class="line">        winnerPlayerLabel = (TextView) findViewById(R.id.winnerPlayerLabel);</div><div class="line">        winnerPlayerViewGroup = findViewById(R.id.winnerPlayerViewGroup);</div><div class="line">        buttonGrid = (ViewGroup) findViewById(R.id.buttonGrid);</div><div class="line"></div><div class="line">        model = new Board();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onCreateOptionsMenu(Menu menu) &#123;</div><div class="line">        MenuInflater inflater = getMenuInflater();</div><div class="line">        inflater.inflate(R.menu.menu_tictactoe, menu);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public boolean onOptionsItemSelected(MenuItem item) &#123;</div><div class="line">        switch (item.getItemId()) &#123;</div><div class="line">            case R.id.action_reset:</div><div class="line">                reset();</div><div class="line">                return true;</div><div class="line">            default:</div><div class="line">                return super.onOptionsItemSelected(item);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onCellClicked(View v) &#123;</div><div class="line"></div><div class="line">        Button button = (Button) v;</div><div class="line"></div><div class="line">        String tag = button.getTag().toString();</div><div class="line">        int row = Integer.valueOf(tag.substring(0,1));</div><div class="line">        int col = Integer.valueOf(tag.substring(1,2));</div><div class="line">        Log.i(TAG, &quot;Click Row: [&quot; + row + &quot;,&quot; + col + &quot;]&quot;);</div><div class="line"></div><div class="line">        Player playerThatMoved = model.mark(row, col);</div><div class="line"></div><div class="line">        if(playerThatMoved != null) &#123;</div><div class="line">            button.setText(playerThatMoved.toString());</div><div class="line">            if (model.getWinner() != null) &#123;</div><div class="line">                winnerPlayerLabel.setText(playerThatMoved.toString());</div><div class="line">                winnerPlayerViewGroup.setVisibility(View.VISIBLE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void reset() &#123;</div><div class="line">        winnerPlayerViewGroup.setVisibility(View.GONE);</div><div class="line">        winnerPlayerLabel.setText(&quot;&quot;);</div><div class="line"></div><div class="line">        model.restart();</div><div class="line"></div><div class="line">        for( int i = 0; i &lt; buttonGrid.getChildCount(); i++ ) &#123;</div><div class="line">            ((Button) buttonGrid.getChildAt(i)).setText(&quot;&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><p>MVC在分离模型和视图方面做得很好。当然，该模型可以很容易地进行测试，因为它不依赖于任何东西，并且视图在单元测试级别上没有什么可测试的。然而，控制器有一些问题。</p><h4 id="Controller关注"><a href="#Controller关注" class="headerlink" title="Controller关注"></a>Controller关注</h4><ul><li><em>可测试性</em> - Controller与Android API紧密联系，难以进行单元测试。</li><li><em>模块化和灵活性</em> - Controller与View紧密耦合。它也可能是View的扩展。如果我们更改View，我们必须返回并更改Controller。</li><li><em>维护</em> - 随着时间的推移，越来越多的代码开始转移到Controller中，使它们变得臃肿和脆弱。</li></ul><p>我们如何解决这个问题？MVP来拯救！</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP将Controller断开，以便自然View/Activity耦合可以发生，而不会与其他“Controller”责任相关联。让我们再次从MVC对比开始。</p><h4 id="Model-1"><a href="#Model-1" class="headerlink" title="Model"></a>Model</h4><p>与MVC相同/无变化</p><h4 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h4><p>这里唯一的变化是Activity/Fragment现在被视为View的一部分。让Activity实现一个视图界面，以便Presnenter有一个可以编码的界面。这消除了将它耦合到任何特定的页面，并允许使用视图的mock实现进行简单的单元测试。</p><h4 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h4><p>这实质上是MVC的Controller，除了它完全不依赖于View，只是一个接口。这解决了可测试性问题以及我们在MVC中遇到的模块化/灵活性问题。<em>实际上，MVP纯粹主义者认为Presenter不应该对任何Android API或代码有任何引用。</em></p><p>我们再来看看在我们的应用程序中在MVP中的分解。</p><p><img src="https://coding.net/u/shijiacheng/p/MVX/git/raw/master/images/mvp模型角色图.png" alt=""></p><p>在下面更详细地看看Presenter，你会注意到的第一件事是每个动作的意图是多么简单和清晰。它不是告诉View如何显示某些东西，而只是告诉它要显示什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class TicTacToePresenter implements Presenter &#123;</div><div class="line">    private TicTacToeView view;</div><div class="line">    private Board model;</div><div class="line"></div><div class="line">    public TicTacToePresenter(TicTacToeView view)&#123;</div><div class="line">        this.view = view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate() &#123;</div><div class="line">        model = new Board();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPause() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResume() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onDestroy() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void onButtonSelected(int row, int col) &#123;</div><div class="line">        Player playerThatMoved = model.mark(row, col);</div><div class="line"></div><div class="line">        if(playerThatMoved != null) &#123;</div><div class="line">            view.setButtonText(row, col, playerThatMoved.toString());</div><div class="line"></div><div class="line">            if (model.getWinner() != null) &#123;</div><div class="line">                view.showWinner(playerThatMoved.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onResetSelected() &#123;</div><div class="line">        view.clearWinnerDisplay();</div><div class="line">        view.clearButtons();</div><div class="line">        model.restart();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了在不将Activity与Presenter绑定的情况下进行这项工作，我们创建了一个Activity实现的接口。在测试中，我们将基于此接口创建一个mock来测试与Presenter和View的交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface TicTacToeView &#123;</div><div class="line">    void showWinner(String winnerLabel);</div><div class="line">    void clearWinnerDisplay();</div><div class="line">    void clearButtons();</div><div class="line">    void setButtonText(int row,int col,String text);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="评估-1"><a href="#评估-1" class="headerlink" title="评估"></a>评估</h4><p>我们可以很容易地对Presenter逻辑进行单元测试，因为它没有绑定到任何Android特定的View和API，并且只要View实现<strong>*TicTacToeView*</strong>界面，我们也可以使用任何其他View。</p><h4 id="Presenter的关注"><a href="#Presenter的关注" class="headerlink" title="Presenter的关注"></a>Presenter的关注</h4><ul><li><em>维护</em> - 与Controller一样，Presenter随着时间的推移，倾向于收集额外的业务逻辑。在某些时候，开发者经常会发现自己拥有难以分开的笨重的Presenter。</li></ul><p>当然，开发人员可以谨慎的防止这种情况发生。但是，MVVM可以更好的解决这个问题。</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">Android上</a>具有<a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">数据绑定功能的</a> MVVM具有易于测试和模块化的优点，同时还减少了我们必须编写的连接View +Model的代码数量。</p><p>我们来看看MVVM的各个部分。</p><h4 id="Model-2"><a href="#Model-2" class="headerlink" title="Model"></a>Model</h4><p>与MVC相同/无变化</p><h4 id="View-2"><a href="#View-2" class="headerlink" title="View"></a>View</h4><p>该View以一种灵活的方式绑定到由viewModel来监控可观察的变量和操作。</p><h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><p>ViewModel负责包装Model并准备View所需的可观察数据。它还为View提供了将事件传递给Model的hocks。然而，ViewModel并不依赖于View。</p><p>我们的程序早MVVM模式中分解。</p><p><img src="https://coding.net/u/shijiacheng/p/MVX/git/raw/master/images/mvvm模型角色图.png" alt=""></p><p>让我们仔细看看这里的代码，从ViewModel开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class TicTacToeViewModel implements ViewModel &#123;</div><div class="line">    private Board model;</div><div class="line">    public final ObservableArrayMap&lt;String,String&gt; cells = new ObservableArrayMap&lt;&gt;();</div><div class="line">    public final ObservableField&lt;String&gt; winner = new ObservableField&lt;&gt;();</div><div class="line"></div><div class="line">    public TicTacToeViewModel()&#123;</div><div class="line">        model = new Board();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPause() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResume() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onDestroy() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onResetClick()&#123;</div><div class="line">        model.restart();</div><div class="line">        winner.set(null);</div><div class="line">        cells.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onCellClick(int row, int col)&#123;</div><div class="line">        Player player = model.mark(row,col);</div><div class="line">        cells.put(&quot;&quot;+row+col,player == null?null:player.toString());</div><div class="line">        winner.set(model.getWinner()==null?null:model.getWinner().toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>查看xml文件，看看这些变量和事件是如何绑定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</div><div class="line"></div><div class="line">    &lt;data&gt;</div><div class="line">        &lt;import type=&quot;android.view.View&quot; /&gt;</div><div class="line">        &lt;variable</div><div class="line">            name=&quot;player&quot;</div><div class="line">            type=&quot;com.shijc.mvx.mvvm.viewmodel.TicTacToeViewModel&quot;/&gt;</div><div class="line">    &lt;/data&gt;</div><div class="line"></div><div class="line">    &lt;LinearLayout</div><div class="line">        android:id=&quot;@+id/tictactoe&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:gravity=&quot;center_horizontal&quot;</div><div class="line">        android:orientation=&quot;vertical&quot;</div><div class="line">        tools:context=&quot;com.acme.tictactoe.view.TicTacToeActivity&quot;&gt;</div><div class="line"></div><div class="line">        &lt;GridLayout</div><div class="line">            android:id=&quot;@+id/buttonGrid&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:columnCount=&quot;3&quot;</div><div class="line">            android:rowCount=&quot;3&quot;&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(0,0)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;00&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(0,1)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;01&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(0,2)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;02&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(1,0)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;10&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(1,1)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;11&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(1,2)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;12&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(2,0)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;20&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(2,1)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;21&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">            &lt;Button</div><div class="line">                style=&quot;@style/tictactoebutton&quot;</div><div class="line">                android:onClick=&quot;@&#123;() -&gt; player.onCellClick(2,2)&#125;&quot;</div><div class="line">                android:text=&apos;@&#123;player.cells[&quot;22&quot;]&#125;&apos; /&gt;</div><div class="line"></div><div class="line">        &lt;/GridLayout&gt;</div><div class="line"></div><div class="line"></div><div class="line">        &lt;LinearLayout</div><div class="line">            android:id=&quot;@+id/winnerPlayerViewGroup&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;match_parent&quot;</div><div class="line">            android:gravity=&quot;center&quot;</div><div class="line">            android:orientation=&quot;vertical&quot;</div><div class="line">            android:visibility=&quot;@&#123;player.winner == null ? View.GONE:View.VISIBLE&#125;&quot;</div><div class="line">            tools:visibility=&quot;visible&quot;&gt;</div><div class="line"></div><div class="line">            &lt;TextView</div><div class="line">                android:id=&quot;@+id/winnerPlayerLabel&quot;</div><div class="line">                android:layout_width=&quot;wrap_content&quot;</div><div class="line">                android:layout_height=&quot;wrap_content&quot;</div><div class="line">                android:layout_margin=&quot;20dp&quot;</div><div class="line">                android:textSize=&quot;40sp&quot;</div><div class="line">                android:text=&quot;@&#123;player.winner&#125;&quot;</div><div class="line">                tools:text=&quot;X&quot; /&gt;</div><div class="line"></div><div class="line">            &lt;TextView</div><div class="line">                android:layout_width=&quot;wrap_content&quot;</div><div class="line">                android:layout_height=&quot;wrap_content&quot;</div><div class="line">                android:text=&quot;Winner&quot;</div><div class="line">                android:textSize=&quot;30sp&quot; /&gt;</div><div class="line"></div><div class="line">        &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line"></div><div class="line">&lt;/layout&gt;</div></pre></td></tr></table></figure><h4 id="评估-2"><a href="#评估-2" class="headerlink" title="评估"></a>评估</h4><p>单元测试现在更容易，因为你真的不依赖于View。测试时，您只需要验证Model更改时是否正确设置了可观察变量。没有必要mock测试View，因为有MVP模式。</p><h4 id="MVVM关注"><a href="#MVVM关注" class="headerlink" title="MVVM关注"></a>MVVM关注</h4><ul><li><em>维护</em> - 由于View可以绑定到变量和表达式，因此无关的表示逻辑可能会随着时间的推移而变动，从而有效地将代码添加到我们的XML中。为了避免这种情况，总是直接从ViewModel获取值，而不是试图在视图绑定表达式中计算或派生它们。这样计算可以适当地进行单元测试。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>MVP和MVVM在将应用程序分解为模块化单一用途组件方面比MVC做得更好，但它们也增加了应用程序的复杂性。对于只有一个或两个屏幕的非常简单的应用程序，MVC可能工作得很好。带有数据绑定的MVVM具有吸引力，因为它遵循更加反应式的编程模型，并且生成的代码更少。</p><p>如果您有兴趣在实践中看到MVP和MVVM的更多示例，我鼓励您查看<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Google Architecture Blueprints</a>项目。还有很多博客文章深入探讨这几种模式</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://academy.realm.io/posts/eric-maxwell-mvc-mvp-and-mvvm-on-android" target="_blank" rel="external">https://academy.realm.io/posts/eric-maxwell-mvc-mvp-and-mvvm-on-android</a></p><p><a href="https://coding.net/u/shijiacheng/p/MVX/git" target="_blank" rel="external">源码地址</a></p>]]></content>
      
      <categories>
          
          <category> Android进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>京东2018秋招笔试编程题集合</title>
      <link href="/2018/05/20/jd-autumn-recruit-2018/"/>
      <url>/2018/05/20/jd-autumn-recruit-2018/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/AlgorithmProblems/blob/master/images/jd-logo.jpeg?raw=true" alt=""></p><a id="more"></a><h3 id="1-括号匹配方案"><a href="#1-括号匹配方案" class="headerlink" title="1.括号匹配方案"></a><a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/jd_autumn_recruit_2018/BracketMatch.java" target="_blank" rel="external">1.括号匹配方案</a></h3><p>合法的括号匹配序列被定义为:</p><ol><li>空串””是合法的括号序列</li><li>如果”X”和”Y”是合法的序列,那么”XY”也是一个合法的括号序列</li><li>如果”X”是一个合法的序列,那么”(X)”也是一个合法的括号序列</li><li>每个合法的括号序列都可以由上面的规则生成</li></ol><p>例如””, “()”, “()()()”, “(()())”, “(((())))”都是合法的。 东东现在有一个合法的括号序列s,一次移除操作分为两步:</p><ol><li>移除序列s中第一个左括号</li><li>移除序列s中任意一个右括号.保证操作之后s还是一个合法的括号序列</li></ol><p>东东现在想知道使用上述的移除操作有多少种方案可以把序列s变为空</p><p>如果两个方案中有一次移除操作移除的是不同的右括号就认为是不同的方案。</p><p>例如: s = “()()()()()”,输出1, 因为每次都只能选择被移除的左括号所相邻的右括号.</p><p>s = “(((())))”,输出24, 第一次有4种情况, 第二次有3种情况, … ,依次类推, 4 <em> 3 </em> 2 * 1 = 24 </p><p><strong>输入描述:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输入包括一行,一个合法的括号序列s,序列长度length(2 ≤ length ≤ 20).</div></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出一个整数,表示方案数</div></pre></td></tr></table></figure><p><strong>输入例子1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(((())))</div></pre></td></tr></table></figure><p><strong>输出例子1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">24</div></pre></td></tr></table></figure><p><strong>思路：</strong></p><ol><li>遍历字符串，每次把左括号都压入栈，每次遇到右括号，先统计栈中有几个左括号，统计数与上次统计数相乘</li><li>接着弹出栈中的一个左括号</li><li>直到遍历结束，结果即为方案数</li></ol><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.Scanner;</div><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class BracketMatch &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Scanner sc = new Scanner(System.in);</div><div class="line">        String s = sc.next();</div><div class="line"></div><div class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</div><div class="line">        int result = 1;</div><div class="line">        char c;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</div><div class="line">            c = s.charAt(i);</div><div class="line">            if (c == &apos;(&apos;) &#123;</div><div class="line">                stack.push(c);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            if (c == &apos;)&apos;) &#123;</div><div class="line">                int size = stack.size();</div><div class="line">                result *= size;</div><div class="line">                stack.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-神奇数"><a href="#2-神奇数" class="headerlink" title="2.神奇数"></a><a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/jd_autumn_recruit_2018/MagicNumber.java" target="_blank" rel="external">2.神奇数</a></h3><p>东东在一本古籍上看到有一种神奇数,如果能够将一个数的数字分成两组,其中一组数字的和等于另一组数字的和,我们就将这个数称为神奇数。例如242就是一个神奇数,我们能够将这个数的数字分成两组,分别是{2,2}以及{4},而且这两组数的和都是4.东东现在需要统计给定区间中有多少个神奇数,即给定区间[l, r],统计这个区间中有多少个神奇数,请你来帮助他。 </p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输入包括一行,一行中两个整数l和r(1 ≤ l, r ≤ 10^9, 0 ≤ r - l ≤ 10^6),以空格分割</div></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出一个整数,即区间内的神奇数个数</div></pre></td></tr></table></figure><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 50</div></pre></td></tr></table></figure><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4</div></pre></td></tr></table></figure><p><strong>思路：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">首先判断数组能否被平分，即数组分割问题，</div><div class="line">dp[i][j]表示数组前i个数字能否求和得到 j</div><div class="line">则dp[i][j]=dp[i−1][j]||dp[i−1][j−array[i]]，其中||是逻辑或运算。</div><div class="line">优化：</div><div class="line">1、若sum（array）为奇数，直接返回false</div><div class="line">2、使用逆序循环将dp数组简化为一维数组</div></pre></td></tr></table></figure></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import java.util.Arrays;</div><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line">public class MagicNumber &#123;</div><div class="line">    public static boolean isMagic(int[] nums, int sum) &#123;</div><div class="line">        int len = nums.length;</div><div class="line"></div><div class="line">        if (sum % 2 != 0)</div><div class="line">            return false;</div><div class="line"></div><div class="line">        int mid = sum / 2;</div><div class="line"></div><div class="line">        int[] dp = new int[mid + 1];</div><div class="line">        dp[0] = 1;</div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            for (int j = mid; j &gt; 0; j--) &#123;</div><div class="line">                if (j &gt;= nums[i] &amp;&amp; nums[i] != -1)</div><div class="line">                    dp[j] = Math.max(dp[j], dp[j - nums[i]]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (dp[mid] &gt; 0)</div><div class="line">            return true;</div><div class="line">        else</div><div class="line">            return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Scanner sc = new Scanner(System.in);</div><div class="line">        int l = sc.nextInt();</div><div class="line">        int r = sc.nextInt();</div><div class="line"></div><div class="line">        int result = 0;</div><div class="line"></div><div class="line">        for (int i = l; i &lt;= r; i++) &#123;</div><div class="line"></div><div class="line">            int num = i;</div><div class="line">            int[] nums = new int[10];</div><div class="line">            int sum = 0;</div><div class="line">            Arrays.fill(nums, -1);</div><div class="line">            int index = 0;</div><div class="line">            while (num &gt; 0) &#123;</div><div class="line">                int temp = num % 10;</div><div class="line">                nums[index++] = temp;</div><div class="line">                sum += temp;</div><div class="line">                num = num / 10;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (isMagic(nums, sum)) &#123;</div><div class="line">                result++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 笔试算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 京东2018秋招笔试编程题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin入坑小结-HelloKotlin</title>
      <link href="/2018/05/10/helloKotlin/"/>
      <url>/2018/05/10/helloKotlin/</url>
      <content type="html"><![CDATA[<blockquote><p>有困难要上，没困难制造困难也要上。</p></blockquote><p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><p>曾几何时，一觉醒来发现Kotlin成为了Android的官方语言，怎么又有新语言出来啊，WTF。</p><p>不管你看不看好Kotlin，这个时候还是需要了解一下，万一哪天突然改用Kotlin呢？其实现在北京很多大厂都开始使用Kotlin了。我问其中的一些朋友由Java转换成Kotlin困难不，他们却说3天，只要3天就可以转变过来。其实并不难，对于有一定编程能力的猿猿来说，读懂一门语言并不复杂，也很好上手。我用了下班之余的部分时间，看了几本书，总结了一下，算是一个读书笔记吧。</p><p>这个笔记包括三个部分：</p><ul><li>Kotlin基本语法</li><li>用Kotlin实现一个天气App</li><li>附录，一些不错的博客收集</li></ul><h2 id="第一部分-Kotlin基本语法"><a href="#第一部分-Kotlin基本语法" class="headerlink" title="第一部分 Kotlin基本语法"></a>第一部分 Kotlin基本语法</h2><h3 id="第1章-第一个-Kotlin-程序"><a href="#第1章-第一个-Kotlin-程序" class="headerlink" title="第1章 第一个 Kotlin 程序"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-01/">第1章 第一个 Kotlin 程序</a></h3><h3 id="第2章-Kotlin基础知识"><a href="#第2章-Kotlin基础知识" class="headerlink" title="第2章 Kotlin基础知识"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-02/">第2章 Kotlin基础知识</a></h3><h3 id="第3章-类和接口"><a href="#第3章-类和接口" class="headerlink" title="第3章 类和接口"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-03/">第3章 类和接口</a></h3><h3 id="第4章-枚举类和扩展"><a href="#第4章-枚举类和扩展" class="headerlink" title="第4章 枚举类和扩展"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-04/">第4章 枚举类和扩展</a></h3><h3 id="第5章-数据类与封闭类"><a href="#第5章-数据类与封闭类" class="headerlink" title="第5章 数据类与封闭类"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-05/">第5章 数据类与封闭类</a></h3><h3 id="第6章-泛型"><a href="#第6章-泛型" class="headerlink" title="第6章 泛型"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-06/">第6章 泛型</a></h3><h3 id="第7章-对象和委托"><a href="#第7章-对象和委托" class="headerlink" title="第7章 对象和委托"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-07/">第7章 对象和委托</a></h3><h3 id="第8章-高阶函数与Lambda表达式"><a href="#第8章-高阶函数与Lambda表达式" class="headerlink" title="第8章 高阶函数与Lambda表达式"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-08/">第8章 高阶函数与Lambda表达式</a></h3><h3 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-09/">第9章 函数</a></h3><h3 id="第10章-其他Kotlin技术（1）"><a href="#第10章-其他Kotlin技术（1）" class="headerlink" title="第10章 其他Kotlin技术（1）"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-10/">第10章 其他Kotlin技术（1）</a></h3><h3 id="第11章-其他Kotlin技术（2）"><a href="#第11章-其他Kotlin技术（2）" class="headerlink" title="第11章 其他Kotlin技术（2）"></a><a href="http://shijiacheng.studio/2018/05/10/helloKotlin-11/">第11章 其他Kotlin技术（2）</a></h3><h2 id="第二部分-用Kotlin实现一个天气App"><a href="#第二部分-用Kotlin实现一个天气App" class="headerlink" title="第二部分 用Kotlin实现一个天气App"></a>第二部分 用Kotlin实现一个天气App</h2><p>所有笔记中的代码我都传到Github中了，地址是：<a href="https://github.com/shijiacheng/HelloKotlin" target="_blank" rel="external">HelloKotlin</a></p>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第11章 其他Kotlin技术(2)</title>
      <link href="/2018/05/10/helloKotlin-11/"/>
      <url>/2018/05/10/helloKotlin-11/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="11-1null值安全性"><a href="#11-1null值安全性" class="headerlink" title="11.1null值安全性"></a>11.1null值安全性</h2><p>在Kotlin中，类型系统明确区分可以指向null的引用和不可以指向null的引用。例如，一个通常的String变量不可以指向null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s:String = null //编译错误，a不可为null</div><div class="line">var b:String = &quot;abc&quot;</div><div class="line">b = null //编译错误，b不可为null</div></pre></td></tr></table></figure><p>要允许null值，我们可以将变量声明可为null的字符串类型：String?。</p><p>第二个方案是使用安全调用操作符:?。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var b:String?=&quot;abc&quot;</div><div class="line">b = null</div><div class="line">println(b?.length) //输出null</div></pre></td></tr></table></figure><p>如果b不是null，这个表达式就会返回b.length，否则返回null。这个表达式本身的类型为Int?。</p><p>安全调用在链式调用的情况下非常有用，只要属性链中任何一个属性为null，整个表达式就会返回null。</p><h3 id="Elvis表达式"><a href="#Elvis表达式" class="headerlink" title="Elvis表达式"></a>Elvis表达式</h3>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第10章 其他Kotlin技术（1）</title>
      <link href="/2018/05/10/helloKotlin-10/"/>
      <url>/2018/05/10/helloKotlin-10/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="10-1数据解构"><a href="#10-1数据解构" class="headerlink" title="10.1数据解构"></a>10.1数据解构</h2><p>数据解构就是讲对象中的数据解析成相应的独立变量，也就是脱离原来的对象存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data class Person(var name:String,var age:Int,var salary:Float)</div></pre></td></tr></table></figure><p>这行代码是一个Person数据类，该数据类有3个参数，下面的代码要将这3个参数对应的属性值赋给相应的3个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var person = Person(&quot;Bill&quot;,30,1200F)</div><div class="line">    var(name,age,salary) = person</div><div class="line">    println(&quot;name=$&#123;name&#125; age=$&#123;age&#125; salary=$&#123;salary&#125;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=Bill age=30 salary=1200.0</div></pre></td></tr></table></figure><p>如果想让一个函数返回多个值。并能解构这些值，也需要返回数据类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun deletePerson(id:Int):Person&#123;</div><div class="line">    println(&quot;已经成功删除指定Person&quot;)</div><div class="line">    var person = Person(&quot;Bill&quot;,30,1200F)</div><div class="line">    return person</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用deletePerson函数，并解构其返回值的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var(name,age,salary) = deletePerson(20)</div><div class="line">println(&quot;name=$&#123;name&#125; age=$&#123;age&#125; salary=$&#123;salary&#125;&quot;)</div></pre></td></tr></table></figure><p>有很多对象，可以保存一组值。例如Map。下面的代码创建MutableMap对象，并保存了两个key-value值对，然后通过for语句将其解构出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var map = mutableMapOf&lt;Int,String&gt;()</div><div class="line">    map.put(10,&quot;Bill&quot;)</div><div class="line">    map.put(20,&quot;Mike&quot;)</div><div class="line"></div><div class="line">    for ((key,value) in map)&#123;</div><div class="line">        println(&quot;key=$&#123;key&#125; value=$&#123;value&#125;&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">key=10 value=Bill</div><div class="line">key=20 value=Mike</div></pre></td></tr></table></figure><p>其中这些对象都是通过数据类实现的。例如，我们也可以自己来实现类似的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">data class MyArrayItem(var key:Int,var value:String,var comment:String)</div><div class="line"></div><div class="line">fun valueArray():Collection&lt;MyArrayItem&gt;&#123;</div><div class="line">    var result = arrayListOf&lt;MyArrayItem&gt;(MyArrayItem(20,&quot;A&quot;,&quot;Comment1&quot;),</div><div class="line">            MyArrayItem(30,&quot;B&quot;,&quot;Comment2&quot;),</div><div class="line">            MyArrayItem(40,&quot;C&quot;,&quot;Comment3&quot;))</div><div class="line">    return result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ((key,value,comment) in valueArray())&#123;</div><div class="line">        println(&quot;key=$&#123;key&#125; value=$&#123;value&#125; comment=$&#123;comment&#125;&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">key=20 value=A comment=Comment1</div><div class="line">key=30 value=B comment=Comment2</div><div class="line">key=40 value=C comment=Comment3</div></pre></td></tr></table></figure><h2 id="10-2集合"><a href="#10-2集合" class="headerlink" title="10.2集合"></a>10.2集合</h2><p>Kotlin标准库将集合分为可修改和不可修改的。不可修改的集合API包括List、Set、Map，可修改的集合的API包括MutableList、MutableSet、MutableMap等。这些API都是接口，而且他们都是Collection的子接口。</p><p>如果泛型用out声明，那么该泛型只能用于读操作。</p><p>下面是一些集合常用的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line"></div><div class="line">    // 创建可读写的列表对象</div><div class="line">    val numbers:MutableList&lt;Int&gt; = mutableListOf(1,2,3)</div><div class="line">    // 将读写列表变成字段列表</div><div class="line">    val readOnlyView:List&lt;Int&gt; = numbers</div><div class="line">    // 输出[1,2,3]</div><div class="line">    println(numbers)</div><div class="line">    //向numbers添加一个新元素</div><div class="line">    numbers.add(4)</div><div class="line">    // 输出[1,2,3,4]</div><div class="line">    println(readOnlyView)</div><div class="line">    //readOnlyView.clear()//编译出错，没有clear函数</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面是一些常用的创建集合对象的函数。</p><ul><li>listOf：用于创建List对象</li><li>setOf：用于创建Set对象</li><li>mapOf：用于创建Map对象</li><li>mutableListOf：用于创建mutable对象</li><li>mutableSetOf：用于创建mutableSetOf对象</li><li>mutableMapOf：用于创建mutableMapOf对象</li></ul><p>对于可读写的集合，可以通过toXxx函数将其转换为只读的版本，其中Xxx是List、Set和Map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var mutableList:MutableList&lt;String&gt; = mutableListOf()</div><div class="line">var list:List&lt;String&gt; = mutableList.toList()</div></pre></td></tr></table></figure><h2 id="10-3值范围"><a href="#10-3值范围" class="headerlink" title="10.3值范围"></a>10.3值范围</h2><p>值范围表达式使用rangeTo函数实现，该函数的操作符形式是两个点（..），另外还有两个相关操作符in和!in。任何可比较大小的数据类型都可以定义值范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var n = 20</div><div class="line">if (n in 1..100)&#123;</div><div class="line">    println(&quot;满足要求&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (n !in 30..80)&#123;</div><div class="line">    println(&quot;符合条件&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>整数的值范围（IntRange、LongRange、CharRange）还有一种额外的功能，就是可以对这些值范围进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i in 1..10)&#123;</div><div class="line">    println(i*i)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行这段代码会输出1到100内的10个数。</p><p>如果按照倒序输出，只需要使用标准库中的downTo函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i in 10 downTo 1)&#123;</div><div class="line">    println(i*i)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果要修改步长，就要使用step函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (i in 1..10 step 2)&#123;</div><div class="line">    println(i*i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(i in 10 downTo 1 step 3)&#123;</div><div class="line">    println(i*i)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>前面的代码中，使用的都是闭区间，1&lt;=i&lt;=10。如果要表示1&lt;=i&lt;10，需要使用until函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i in 1 until 10)&#123;</div><div class="line">    println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="10-4类型检查和类型转换"><a href="#10-4类型检查和类型转换" class="headerlink" title="10.4类型检查和类型转换"></a>10.4类型检查和类型转换</h2><h3 id="is与-is操作符"><a href="#is与-is操作符" class="headerlink" title="is与!is操作符"></a>is与!is操作符</h3><p>is操作符：在运行时检查一个对象与一个给定的类型是否一致。!is与之相反。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var obj:Any = 456</div><div class="line">    var obj1 = 123</div><div class="line">    var obj2 = &quot;hello&quot;</div><div class="line"></div><div class="line">    if(obj is String)&#123;</div><div class="line">        println(&quot;obj是字符串&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (obj is Int)&#123;</div><div class="line">        println(&quot;obj是Int类型&quot;)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (obj!is Int)&#123;</div><div class="line">        println(&quot;obj不是Int类型&quot;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>如果is表达式满足条件，Kotlin编译器会自动转换is前面的对象到后面的数据类型，也就是说上面一个if语句中，obj已经是String类型了。</p><p>要注意的是，对象和is后面的类型要兼容，否则无法编译通过。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>如果类型强制转换，而且类型不兼容，类型转换操作符通常会抛出一个异常。因此，我们称之为不安全的，在Kotlin中，不安全的类型转换使用中缀操作符as。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var y:Any = &quot;abcd&quot;</div><div class="line">var x:Int = y as Int // abcd无法转换为数值，因此会抛出异常</div></pre></td></tr></table></figure><p>注意：null不能被转换为String，因为这个类型不是可为null的。我们需要在类型转换操作符的右侧使用可为null的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var y:Any? = &quot;abcd&quot;</div><div class="line">var x:Int? = y as? Int // 转换错误，但不会抛出异常，x的值是null</div><div class="line">println(x) // 输出null</div></pre></td></tr></table></figure><h2 id="10-5this表达式"><a href="#10-5this表达式" class="headerlink" title="10.5this表达式"></a>10.5this表达式</h2><p>为了表示当前函数的接收者。可以使用this表达式。在类的成员函数中，this指向这个类的当前对象实例。在扩展函数中或者带接受者的函数字面值中，this代表调用函数时，在点号左侧传递的接收者参数。</p><p>如果this没有限定值，那么它指向包含当前代码的最内层范围，如果想要指向其他范围内的this，需要使用标签限定符。</p><p>为了访问更外层范围内的this，使用this@label，其中@label是一个标签，代表我们想要访问的this所属的范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    inner class B&#123;</div><div class="line">        fun Int.foo()&#123;</div><div class="line">            var a = this@A //指向A的this</div><div class="line">            var b = this@B</div><div class="line"></div><div class="line">            var c = this // 指向foo()函数的接收者，一个Int值</div><div class="line">            var c1 = this@foo // 指向foo()函数的接收者，一个Int值</div><div class="line"></div><div class="line">            val finLit = lambda@ fun String.()&#123;</div><div class="line">                val d = this // 指向funLit的接收者</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            val finLit2 = &#123; s : String -&gt;</div><div class="line">                val d1 = this // 函数的接收者，因为包含当前代码的Lambda表达式没有接收者</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="10-6相等判断"><a href="#10-6相等判断" class="headerlink" title="10.6相等判断"></a>10.6相等判断</h2><p>在Kotlin中有两种相等判断。</p><ul><li>引用相等，也即是两个引用指向同一个对象，使用”===”(以及他的相反操作!==)</li><li>结构相等，使用equals函数判断,使用”==”(以及他的相反操作!=)</li></ul>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第9章 函数</title>
      <link href="/2018/05/10/helloKotlin-09/"/>
      <url>/2018/05/10/helloKotlin-09/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="9-1函数基本用法"><a href="#9-1函数基本用法" class="headerlink" title="9.1函数基本用法"></a>9.1函数基本用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 函数的标准定义</div><div class="line">fun double(x:Int):Int&#123;</div><div class="line">    return 2*x</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    // 调用函数</div><div class="line">    double(3)</div><div class="line">    println(double(4))</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="9-2使用中辍标记法调用函数"><a href="#9-2使用中辍标记法调用函数" class="headerlink" title="9.2使用中辍标记法调用函数"></a>9.2使用中辍标记法调用函数</h2><p>中辍表达式：指将函数名称放到两个操作数中间。这两个操作数，左侧是包含函数的对象或值，右侧是函数的参数值。</p><p>满足中辍标记法调用的函数满足的条件：</p><ul><li>成员函数或者扩展函数</li><li>只有一个参数</li><li>使用infix关键字声明函数</li></ul><p>例子：字符串除法，就是去除分子字符中包含的所有分母字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*字符串除法*/</div><div class="line">infix fun String.div(str:String):String&#123;</div><div class="line">    // 将当前字符串中的所有str替换成&quot;&quot;</div><div class="line">    return this.replace(str,&quot;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一般方式调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    /*一般方式调用*/</div><div class="line">    var str = &quot;hello world&quot;</div><div class="line">    println(str.div(&quot;l&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">heo word</div></pre></td></tr></table></figure><p>使用中辍表达式调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var str = &quot;hello world&quot;</div><div class="line"></div><div class="line">    /*使用中辍表达式调用*/</div><div class="line">    println(str div &quot;l&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">heo word</div></pre></td></tr></table></figure><p>中辍表达式可以连续使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var str = &quot;hello world&quot;</div><div class="line"></div><div class="line">    /* 中辍表达式可以连续使用*/</div><div class="line">    println(str div &quot;l&quot; div &quot;o&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">he wrd</div></pre></td></tr></table></figure><h2 id="9-3单表达式函数"><a href="#9-3单表达式函数" class="headerlink" title="9.3单表达式函数"></a>9.3单表达式函数</h2><p>如果一个函数的函数体只要一条语句，而且是return语句，那么可以省略函数体的大括号，以及return关键字。return后面的表达式可以直接写在函数声明的后面，用等号与函数声明分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun double1(x:Int):Int = x*2</div></pre></td></tr></table></figure><p>如果Kotlin编译器能够推断出等号右侧的表达式类型，那么可以省略函数的返回值类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun double2(x:Int) = x*2</div></pre></td></tr></table></figure><h2 id="9-4函数参数和返回值"><a href="#9-4函数参数和返回值" class="headerlink" title="9.4函数参数和返回值"></a>9.4函数参数和返回值</h2><p>可变参数：可以有任意多个参数</p><p>一个函数的一个参数（一般是最后一个参数）标记为vararg，这样可以作为可变参数处理。在函数内部，会按照数组来处理这些参数值。</p><p>asList功能是将一组值转换为List<t>对象，并返回改对象：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; asList(vararg ts:T):List&lt;T&gt;&#123;</div><div class="line">    var result=  ArrayList&lt;T&gt;()</div><div class="line">    for (t in ts)</div><div class="line">        result.add(t)</div><div class="line">    return result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用asList函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var list = asList(1,2,&quot;a&quot;,4,5)</div><div class="line">    println(list)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1, 2, a, 4, 5]</div></pre></td></tr></table></figure><p>只有一个参数可以标记vararg，如果vararg参数不是函数的最后一个参数，那么对于vararg参数之后的其他参数可以使用命名参数来传递参数值。</p><p>例子：下面的asList2有3个参数，第1个是可变参数，后面两个value1和value2，由于最后一个参数不是可变参数，因此传递value1和value2参数的时候后需要使用命名参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; asList2(vararg ts:T,value1:Int,value2:String):List&lt;T&gt;&#123;</div><div class="line">    var result=  ArrayList&lt;T&gt;()</div><div class="line">    for (t in ts)</div><div class="line">        result.add(t)</div><div class="line">    println(&quot;value1=$&#123;value1&#125; value2=$&#123;value2&#125;&quot;)</div><div class="line">    return result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用asList2函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    var list2 = asList2(1,2,&quot;a&quot;,value1 = 4,value2 = &quot;5&quot;)</div><div class="line">    println(list2)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value1=4 value2=5</div><div class="line">[1, 2, a]</div></pre></td></tr></table></figure><p>如果我们已经有了一个数组，将数组的内容传递给asList函数，可以使用展开操作符，在数组之前加*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun main(args:Array&lt;String&gt;)&#123;</div><div class="line">    val a = arrayOf(1,2,3)</div><div class="line">    var list = asList(-1,0,*a,4,5)</div><div class="line">    println(list)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[-1, 0, 1, 2, 3, 4, 5]</div></pre></td></tr></table></figure><p>返回值类型：</p><p>如果函数体为多行语句组成的代码段，那么就必须明确返回值类型，除非这个函数不返回任何值（Unit），对于多行语句的函数，Kotlin不会推断其返回值类型。</p><h2 id="9-5函数的范围"><a href="#9-5函数的范围" class="headerlink" title="9.5函数的范围"></a>9.5函数的范围</h2><p>在Kotlin中，函数可以定义在源代码的顶级范围内，这就意味着可以不必像java中创建一个类来容纳函数。除顶级函数外，kotlin函数还可以定义为局部函数、成员函数和扩展函数。</p><h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><p>kotlin支持局部函数，就是嵌套在另一个函数内的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun saveFile()&#123;</div><div class="line">    fun getFullName(fn:String):String&#123;</div><div class="line">        return &quot;/user/$&#123;fn&#125;&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var fileName = getFullName(&quot;test.txt&quot;)</div><div class="line">    println(&quot;$&#123;fileName&#125;已经保存成功&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用saveFile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    saveFile()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/user/test.txt已经保存成功</div></pre></td></tr></table></figure><p>局部函数可以访问外部函数的局部变量，例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun saveFile2()&#123;</div><div class="line">    var fn = &quot;text.txt&quot;</div><div class="line">    fun getFullName():String&#123;</div><div class="line">        return &quot;/user/$&#123;fn&#125;&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var fileName = getFullName()</div><div class="line">    println(&quot;$&#123;fileName&#125;已经保存成功&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用saveFile2运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/user/test.txt已经保存成功</div></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>成员函数是指定义在类或者对象内的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Sample()&#123;</div><div class="line">    //成员函数</div><div class="line">    fun foo()&#123;</div><div class="line">        println(&quot;foo&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对成员函数的调用使用点号标记法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    // 创建Sample实例，并调用foo方法</div><div class="line">    Sample().foo()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo</div></pre></td></tr></table></figure><h2 id="9-6泛型函数"><a href="#9-6泛型函数" class="headerlink" title="9.6泛型函数"></a>9.6泛型函数</h2><p>函数可以带泛型参数，泛型参数通过函数名前的尖括号指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; SingletionList(item:T):List&lt;T&gt;&#123;</div><div class="line">    //……</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="9-7内联函数"><a href="#9-7内联函数" class="headerlink" title="9.7内联函数"></a>9.7内联函数</h2><p>要想让函数支持内联，需要在定义函数时使用inline关键字。</p><p>未使用inline关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun processProduct(area:(name:String)-&gt;String):String&#123;</div><div class="line">    return area(&quot;iphone&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(processProduct &#123; name -&gt; &quot;$&#123;name&#125; 美国&quot; &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iphone 美国</div></pre></td></tr></table></figure><p>使用inline关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inline fun processProduct2(area:(name:String)-&gt;String):String&#123;</div><div class="line">    return area(&quot;iphone&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内联部分Lambda表达式</p><p>如果一个需要内联的函数，多个参数都是函数类型，使用inline后，会将所有的Lambda表达式的参数值都内联进当前函数。<br>如果参数前面加了noinline，那么即使函数加了inline，这个参数也不会内联进调用函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inline fun processProduct3(area1:(name:String)-&gt;String,noinline area2:(name:String)-&gt;String):String&#123;</div><div class="line">    return area1(&quot;iphone&quot;) +&quot; &quot;+ area2(&quot;埃菲尔铁塔&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iphone 美国 埃菲尔铁塔 法国</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第8章 高阶函数与Lambda表达式</title>
      <link href="/2018/05/10/helloKotlin-08/"/>
      <url>/2018/05/10/helloKotlin-08/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="8-1-高阶函数"><a href="#8-1-高阶函数" class="headerlink" title="8.1 高阶函数"></a>8.1 高阶函数</h2><p>高阶函数是一种特殊的函数，它接受函数作为函数，或者返回一个函数。在下面的例子中，processProduct是一个高阶函数，该函数的第1个参数是一个对象（Product类型），第2个参数是一个函数类型。这个函数类型需要传递一个name参数（String类型），并返回一个String类型。processProduct函数会通过第2个参数area为产品添加产地。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">interface Product&#123;</div><div class="line">    var area:String</div><div class="line">    fun sell(name:String)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MobilePhone:Product&#123;</div><div class="line"></div><div class="line">    override var area: String = &quot;&quot;</div><div class="line"></div><div class="line">    override fun sell(name: String) &#123;</div><div class="line">        println(&quot;销售$&#123;name&#125;&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun toString(): String &#123;</div><div class="line">        return area</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">fun mobilePhoneArea(name: String):String&#123;</div><div class="line">    return &quot;$&#123;name&#125; 美国&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun processProduct(product: Product,area:(name:String)-&gt;String):Product&#123;</div><div class="line">    //调用第二个参数指定的函数</div><div class="line">    product.area = area(&quot;iphone&quot;)</div><div class="line">    return product</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var product = MobilePhone()</div><div class="line">    //将函数作为函数值传入高阶函数，需要在函数名前加两个冒号，作为标记</div><div class="line">    processProduct(product,::mobilePhoneArea)</div><div class="line">    println(product)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iphone 美国</div></pre></td></tr></table></figure><h2 id="8-2-Lambda表达式与匿名函数"><a href="#8-2-Lambda表达式与匿名函数" class="headerlink" title="8.2 Lambda表达式与匿名函数"></a>8.2 Lambda表达式与匿名函数</h2><p>Lambda表达式，或者称为匿名函数，是一种”函数字面值“，也就是一个没有声明的函数，但是可以作为表达式传递出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">max(strings,&#123;a,b-&gt;a.length &lt; b.length&#125;)</div></pre></td></tr></table></figure><p>函数max是一个高阶函数，也就是说，它接受一个函数值作为第二个参数。第二个参数是一个表达式，本身又是另一个函数，也就是说，它是一个函数字面量。作为函数等价于下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun compare(a:String,b:String):Boolean = a.length&lt;b.length</div></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>对于接受另一个函数作为自己参数的函数，我们必须针对这个参数指定一个函数类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; max(collection: Collection&lt;T&gt;,less:(T,T) -&gt; Boolean):T?&#123;</div><div class="line">    var max:T? = null</div><div class="line">    for (it in collection)</div><div class="line">        if (max == null || less(max,it))</div><div class="line">            max = it</div><div class="line">    return max</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参数less的类型是(T,T) -&gt; Boolean，也就是说，它是一个函数，接受两个T类型参数，并且返回一个Boolean类型结果。</p><h3 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h3><p>Lambda表达式的完整语法形式，也就是函数类型的字面值，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val sum = &#123;x:Int,y:Int -&gt; x+y&#125;</div></pre></td></tr></table></figure><p>Lambda表达式包含在大括号之内，在完整语法形式中，参数声明在小括号内，参数类型的声明可选，函数体在-&gt;之后。如果Lambda表达式自动推断返回值类型不是Unit，那么在Lambda表达式函数体中，最后一条表达式的值会被当作整个Lambda表达式的返回值。</p><p>如果我们把所有可选内容去掉，那么剩余的部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val sum2 :(Int,Int) -&gt;Int = &#123;x,y-&gt;x+y&#125;</div></pre></td></tr></table></figure><p>很多情况下，Lambda表达式只有唯一一个参数，如果Kotlin能够自行判断出Lambda表达式的参数定义，那么它将允许我们省略唯一一个参数的定义（”-&gt;”也可以一同省略），并且会为我们隐含的定义这个参数，使用能够函数名为it，例如，8.1节调用processProduct函数的代码可以改成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">processProduct(product)&#123;</div><div class="line">    &quot;$&#123;it&#125;美国&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果使用带标签限定的return语句，那么可以在Lambda表达式内明确的返回一个结果值。否则，会隐含的返回Lambda表达式内最后一条表达式的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">processProduct2(product)&#123;</div><div class="line">    return &quot;$&#123;it&#125;美国&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    fun(x:Int,y:Int):Int = x+y</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>匿名函数省略了函数名，函数体可以是一个表达式，也可以是多条语句组成的代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    fun(x:Int,y:Int):Int&#123;</div><div class="line">        return x+y</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参数和返回值类型的声明与通常的函数一样，但如果参数类型可以通过上下文推断得到，那么类型声明可以省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    ints.filter(fun(item) = item&gt;0)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于匿名函数，返回值类型的自动推断方式与通常的函数一样：如果函数体是一个表达式，那么返回值类型可以自动推断得到；如果函数体是多条语句组成的代码段，则返回值类型必须明确指出，否则认为是（Unit）</p><p>注意：匿名函数参数一定要在小括号内传递。允许将函数类型参数写在小括号之外的语法，仅对Lambda表达式有效。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Lambda表达式、匿名函数可以访问他/她的闭包，也就是定义在外层范围中的变量。与Java不同，闭包中捕获的变量是可以修改的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var sum = 0</div><div class="line">    ints.filter&#123;it&gt;0&#125;.forEach&#123;</div><div class="line">        sum+=it</div><div class="line">    &#125;  </div><div class="line">    println(sum)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第7章 对象和委托</title>
      <link href="/2018/05/10/helloKotlin-07/"/>
      <url>/2018/05/10/helloKotlin-07/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="7-1-Kotlin-对象表达式和对象声明"><a href="#7-1-Kotlin-对象表达式和对象声明" class="headerlink" title="7.1 Kotlin 对象表达式和对象声明"></a>7.1 Kotlin 对象表达式和对象声明</h2><p>Kotlin 用对象表达式和对象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类。</p><h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>通过对象表达式实现一个匿名内部类的对象用于方法的参数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.addMouseListener(object : MouseAdapter() &#123;</div><div class="line">    override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">    override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>对象可以继承于某个基类，或者实现其他接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">open class A(x: Int) &#123;</div><div class="line">    public open val y: Int = x</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface B &#123;……&#125;</div><div class="line"></div><div class="line">val ab: A = object : A(1), B &#123;</div><div class="line">    override val y = 15</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔。</p><p>通过对象表达式可以越过类的定义直接得到一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val site = object &#123;</div><div class="line">        var name: String = &quot;石嘉成的博客&quot;</div><div class="line">        var url: String = &quot;www.shijiacheng.studio&quot;</div><div class="line">    &#125;</div><div class="line">    println(site.name)</div><div class="line">    println(site.url)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    // 私有函数，所以其返回类型是匿名对象类型</div><div class="line">    private fun foo() = object &#123;</div><div class="line">        val x: String = &quot;x&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 公有函数，所以其返回类型是 Any</div><div class="line">    fun publicFoo() = object &#123;</div><div class="line">        val x: String = &quot;x&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun bar() &#123;</div><div class="line">        val x1 = foo().x        // 没问题</div><div class="line">        val x2 = publicFoo().x  // 错误：未能解析的引用“x”</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在对象表达中可以方便的访问到作用域中的其他变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fun countClicks(window: JComponent) &#123;</div><div class="line">    var clickCount = 0</div><div class="line">    var enterCount = 0</div><div class="line"></div><div class="line">    window.addMouseListener(object : MouseAdapter() &#123;</div><div class="line">        override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">            clickCount++</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">            enterCount++</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>Kotlin 使用 object 关键字来声明一个对象。</p><p>Kotlin 中我们可以方便的通过对象声明来获得一个单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">object DataProviderManager &#123;</div><div class="line">    fun registerDataProvider(provider: DataProvider) &#123;</div><div class="line">        // ……</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    val allDataProviders: Collection&lt;DataProvider&gt;</div><div class="line">        get() = // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>引用该对象，我们直接使用其名称即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataProviderManager.registerDataProvider(……)</div></pre></td></tr></table></figure><p>当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var data1 = DataProviderManager</div><div class="line">var data2 = DataProviderManager</div><div class="line">data1.name = &quot;test&quot;</div><div class="line">print(&quot;data1 name = $&#123;data2.name&#125;&quot;)</div></pre></td></tr></table></figure><p>实例</p><p>以下实例中，两个对象都输出了同一个 url 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">object Site &#123;</div><div class="line">    var url:String = &quot;&quot;</div><div class="line">    val name: String = &quot;石嘉成的博客&quot;</div><div class="line">&#125;</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var s1 =  Site</div><div class="line">    var s2 = Site</div><div class="line">    s1.url = &quot;www.shijiacheng.studio&quot;</div><div class="line">    println(s1.url)</div><div class="line">    println(s2.url)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">www.shijiacheng.studio</div><div class="line">www.shijiacheng.studio</div></pre></td></tr></table></figure><p>对象可以有超类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">object DefaultListener : MouseAdapter() &#123;</div><div class="line">    override fun mouseClicked(e: MouseEvent) &#123;</div><div class="line">        // ……</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun mouseEntered(e: MouseEvent) &#123;</div><div class="line">        // ……</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Site &#123;</div><div class="line">    var name = &quot;石嘉成的博客&quot;</div><div class="line">    object DeskTop&#123;</div><div class="line">        var url = &quot;www.shijiacheng.studio&quot;</div><div class="line">        fun showName()&#123;</div><div class="line">            print&#123;&quot;desk legs $name&quot;&#125; // 错误，不能访问到外部类的方法和变量</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var site = Site()</div><div class="line">    site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象</div><div class="line">    Site.DeskTop.url // 正确</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object Factory &#123;</div><div class="line">        fun create(): MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">val instance = MyClass.create()   // 访问到对象的内部元素</div></pre></td></tr></table></figure><p>我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">val x = MyClass.Companion</div></pre></td></tr></table></figure><p><strong>注意：</strong>一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。</p><p>请伴生对象的成员看起来像其他语言的静态成员，但在运行时他们仍然是真实对象的实例成员。例如还可以实现接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface Factory&lt;T&gt; &#123;</div><div class="line">    fun create(): T</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class MyClass &#123;</div><div class="line">    companion object : Factory&lt;MyClass&gt; &#123;</div><div class="line">        override fun create(): MyClass = MyClass()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h3><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方立即执行的</li><li>对象声明是在第一次被访问到时延迟初始化的</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配</li></ul><h2 id="7-2-kotlin-委托"><a href="#7-2-kotlin-委托" class="headerlink" title="7.2 kotlin 委托"></a>7.2 kotlin 委托</h2><p>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p><p>Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p><h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p><p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 创建接口</div><div class="line">interface Base &#123;   </div><div class="line">    fun print()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现此接口的被委托的类</div><div class="line">class BaseImpl(val x: Int) : Base &#123;</div><div class="line">    override fun print() &#123; print(x) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过关键字 by 建立委托类</div><div class="line">class Derived(b: Base) : Base by b</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val b = BaseImpl(10)</div><div class="line">    Derived(b).print() // 输出 10</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p><h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p><p>属性委托语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</div></pre></td></tr></table></figure><ul><li>var/val：属性类型(可变/只读)</li><li>属性名：属性名称</li><li>类型：属性的数据类型</li><li>表达式：委托代理类</li></ul><p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</p><h3 id="定义一个被委托的类"><a href="#定义一个被委托的类" class="headerlink" title="定义一个被委托的类"></a>定义一个被委托的类</h3><p>该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import kotlin.reflect.KProperty</div><div class="line">// 定义包含属性委托的类</div><div class="line">class Example &#123;</div><div class="line">    var p: String by Delegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 委托的类</div><div class="line">class Delegate &#123;</div><div class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</div><div class="line">        return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</div><div class="line">        println(&quot;$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val e = Example()</div><div class="line">    println(e.p)     // 访问该属性，调用 getValue() 函数</div><div class="line"></div><div class="line">    e.p = &quot;Shijiacheng&quot;   // 调用 setValue() 函数</div><div class="line">    println(e.p)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Example@433c675d, 这里委托了 p 属性</div><div class="line">Example@433c675d 的 p 属性赋值为 Shijiacheng</div><div class="line">Example@433c675d, 这里委托了 p 属性</div></pre></td></tr></table></figure><h3 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h3><p>Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。</p><h3 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h3><p>lazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <t> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val lazyValue: String by lazy &#123;</div><div class="line">    println(&quot;computed!&quot;)     // 第一次调用输出，第二次调用不执行</div><div class="line">    &quot;Hello&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(lazyValue)   // 第一次执行，执行两次输出表达式</div><div class="line">    println(lazyValue)   // 第二次执行，只输出返回值</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">computed!</div><div class="line">Hello</div><div class="line">Hello</div></pre></td></tr></table></figure><h3 id="可观察属性-Observable"><a href="#可观察属性-Observable" class="headerlink" title="可观察属性 Observable"></a>可观察属性 Observable</h3><p>observable 可以用于实现观察者模式。</p><p>Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。</p><p>在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import kotlin.properties.Delegates</div><div class="line"></div><div class="line">class User &#123;</div><div class="line">    var name: String by Delegates.observable(&quot;初始值&quot;) &#123;</div><div class="line">        prop, old, new -&gt;</div><div class="line">        println(&quot;旧值：$old -&gt; 新值：$new&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val user = User()</div><div class="line">    user.name = &quot;第一次赋值&quot;</div><div class="line">    user.name = &quot;第二次赋值&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">旧值：初始值 -&gt; 新值：第一次赋值</div><div class="line">旧值：第一次赋值 -&gt; 新值：第二次赋值</div></pre></td></tr></table></figure><h3 id="把属性储存在映射中"><a href="#把属性储存在映射中" class="headerlink" title="把属性储存在映射中"></a>把属性储存在映射中</h3><p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他”动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Site(val map: Map&lt;String, Any?&gt;) &#123;</div><div class="line">    val name: String by map</div><div class="line">    val url: String  by map</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    // 构造函数接受一个映射参数</div><div class="line">    val site = Site(mapOf(</div><div class="line">        &quot;name&quot; to &quot;石嘉成的博客&quot;,</div><div class="line">        &quot;url&quot;  to &quot;www.shijiacheng.studio&quot;</div><div class="line">    ))</div><div class="line">    </div><div class="line">    // 读取映射值</div><div class="line">    println(site.name)</div><div class="line">    println(site.url)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">石嘉成的博客</div><div class="line">www.shijiacheng.studio</div></pre></td></tr></table></figure><p>如果使用 var 属性，需要把 Map 换成 MutableMap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Site(val map: MutableMap&lt;String, Any?&gt;) &#123;</div><div class="line">    val name: String by map</div><div class="line">    val url: String by map</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line"></div><div class="line">    var map:MutableMap&lt;String, Any?&gt; = mutableMapOf(</div><div class="line">            &quot;name&quot; to &quot;石嘉成的博客&quot;,</div><div class="line">            &quot;url&quot; to &quot;www.shijiacheng.studio&quot;</div><div class="line">    )</div><div class="line"></div><div class="line">    val site = Site(map)</div><div class="line"></div><div class="line">    println(site.name)</div><div class="line">    println(site.url)</div><div class="line"></div><div class="line">    println(&quot;--------------&quot;)</div><div class="line">    map.put(&quot;name&quot;, &quot;Google&quot;)</div><div class="line">    map.put(&quot;url&quot;, &quot;www.google.com&quot;)</div><div class="line"></div><div class="line">    println(site.name)</div><div class="line">    println(site.url)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">石嘉成的博客</div><div class="line">www.shijiacheng.studio</div><div class="line">--------------</div><div class="line">Google</div><div class="line">www.google.com</div></pre></td></tr></table></figure><h3 id="Not-Null"><a href="#Not-Null" class="headerlink" title="Not Null"></a>Not Null</h3><p>notNull 适用于那些无法在初始化阶段就确定属性值的场合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">    var notNullBar: String by Delegates.notNull&lt;String&gt;()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.notNullBar = &quot;bar&quot;</div><div class="line">println(foo.notNullBar)</div></pre></td></tr></table></figure><p>需要注意，如果属性在赋值前就被访问的话则会抛出异常。</p><h3 id="局部委托属性"><a href="#局部委托属性" class="headerlink" title="局部委托属性"></a>局部委托属性</h3><p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun example(computeFoo: () -&gt; Foo) &#123;</div><div class="line">    val memoizedFoo by lazy(computeFoo)</div><div class="line"></div><div class="line">    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;</div><div class="line">        memoizedFoo.doSomething()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p><h3 id="属性委托要求"><a href="#属性委托要求" class="headerlink" title="属性委托要求"></a>属性委托要求</h3><p>对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数：</p><ul><li>thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li><li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型</li></ul><p>这个函数必须返回与属性相同的类型（或其子类型）。</p><p>对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数:</p><h3 id="翻译规则"><a href="#翻译规则" class="headerlink" title="翻译规则"></a>翻译规则</h3><p>在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    var prop: Type by MyDelegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这段是由编译器生成的相应代码：</div><div class="line">class C &#123;</div><div class="line">    private val prop$delegate = MyDelegate()</div><div class="line">    var prop: Type</div><div class="line">        get() = prop$delegate.getValue(this, this::prop)</div><div class="line">        set(value: Type) = prop$delegate.setValue(this, this::prop, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。</p><h3 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h3><p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p><p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。</p><p>例如，如果要在绑定之前检查属性名称，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123;</div><div class="line">    operator fun provideDelegate(</div><div class="line">            thisRef: MyUI,</div><div class="line">            prop: KProperty&lt;*&gt;</div><div class="line">    ): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</div><div class="line">        checkProperty(thisRef, prop.name)</div><div class="line">        // 创建委托</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;</div><div class="line"></div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource(ResourceID.image_id)</div><div class="line">    val text by bindResource(ResourceID.text_id)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>provideDelegate 的参数与 getValue 相同：</p><ul><li>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型</li><li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。</li></ul><p>在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。</p><p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 检查属性名称而不使用“provideDelegate”功能</div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource(ResourceID.image_id, &quot;image&quot;)</div><div class="line">    val text by bindResource(ResourceID.text_id, &quot;text&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; MyUI.bindResource(</div><div class="line">        id: ResourceID&lt;T&gt;,</div><div class="line">        propertyName: String</div><div class="line">): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</div><div class="line">   checkProperty(this, propertyName)</div><div class="line">   // 创建委托</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    var prop: Type by MyDelegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这段代码是当“provideDelegate”功能可用时</div><div class="line">// 由编译器生成的代码：</div><div class="line">class C &#123;</div><div class="line">    // 调用“provideDelegate”来创建额外的“delegate”属性</div><div class="line">    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)</div><div class="line">    val prop: Type</div><div class="line">        get() = prop$delegate.getValue(this, this::prop)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第6章 泛型</title>
      <link href="/2018/05/10/helloKotlin-06/"/>
      <url>/2018/05/10/helloKotlin-06/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h3 id="Kotlin-泛型"><a href="#Kotlin-泛型" class="headerlink" title="Kotlin 泛型"></a>Kotlin 泛型</h3><p>泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</p><p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p><p>声明一个泛型类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Box&lt;T&gt;(t: T) &#123;</div><div class="line">    var value = t</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>创建类的实例时我们需要指定类型参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)</div><div class="line">// 或者</div><div class="line">val box = Box(1) // 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。</div></pre></td></tr></table></figure><p>以下实例向泛型类 Box 传入整型数据和字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Box&lt;T&gt;(t : T) &#123;</div><div class="line">    var value = t</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var boxInt = Box&lt;Int&gt;(10)</div><div class="line">    var boxString = Box&lt;String&gt;(&quot;Shijiacheng&quot;)</div><div class="line"></div><div class="line">    println(boxInt.value)</div><div class="line">    println(boxString.value)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">Shijiacheng</div></pre></td></tr></table></figure><p>定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。</p><p>Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; boxIn(value: T) = Box(value)</div><div class="line"></div><div class="line">// 以下都是合法语句</div><div class="line">val box4 = boxIn&lt;Int&gt;(1)</div><div class="line">val box5 = boxIn(1)     // 编译器会进行类型推断</div></pre></td></tr></table></figure><p>在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。</p><p>以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val age = 23</div><div class="line">    val name = &quot;runoob&quot;</div><div class="line">    val bool = true</div><div class="line"></div><div class="line">    doPrintln(age)    // 整型</div><div class="line">    doPrintln(name)   // 字符串</div><div class="line">    doPrintln(bool)   // 布尔型</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; doPrintln(content: T) &#123;</div><div class="line"></div><div class="line">    when (content) &#123;</div><div class="line">        is Int -&gt; println(&quot;整型数字为 $content&quot;)</div><div class="line">        is String -&gt; println(&quot;字符串转换为大写：$&#123;content.toUpperCase()&#125;&quot;)</div><div class="line">        else -&gt; println(&quot;T 不是整型，也不是字符串&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">整型数字为 23</div><div class="line">字符串转换为大写：RUNOOB</div><div class="line">T 不是整型，也不是字符串</div></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p><p>Kotlin 中使用 : 对泛型的的类型上限进行约束。</p><p>最常见的约束是上界(upper bound)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123;</div><div class="line">    // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Comparable 的子类型可以替代 T。 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sort(listOf(1, 2, 3)) // OK。Int 是 Comparable&lt;Int&gt; 的子类型</div><div class="line">sort(listOf(HashMap&lt;Int, String&gt;())) // 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</div></pre></td></tr></table></figure><p>默认的上界是 Any?。</p><p>对于多个上界约束条件，可以用 where 子句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;</div><div class="line">    where T : CharSequence,</div><div class="line">          T : Comparable&lt;T&gt; &#123;</div><div class="line">    return list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h3><p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。</p><h3 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h3><p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p><p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 定义一个支持协变的类</div><div class="line">class Runoob&lt;out A&gt;(val a: A) &#123;</div><div class="line">    fun foo(): A &#123;</div><div class="line">        return a</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var strCo: Runoob&lt;String&gt; = Runoob(&quot;a&quot;)</div><div class="line">    var anyCo: Runoob&lt;Any&gt; = Runoob&lt;Any&gt;(&quot;b&quot;)</div><div class="line">    anyCo = strCo</div><div class="line">    println(anyCo.foo())   // 输出 a</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 定义一个支持逆变的类</div><div class="line">class Runoob&lt;in A&gt;(a: A) &#123;</div><div class="line">    fun foo(a: A) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var strDCo = Runoob(&quot;a&quot;)</div><div class="line">    var anyDCo = Runoob&lt;Any&gt;(&quot;b&quot;)</div><div class="line">    strDCo = anyDCo</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h3><p>有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓”安全地使用”是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。</p><p>对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection):</p><ul><li>假如类型定义为 Foo<out t=""> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo&lt;<em>&gt; 等价于 Foo<out tupper=""> . 它表示, 当 T 未知时, 你可以安全地从 Foo&lt;</out></em>&gt; 中 读取TUpper 类型的值.</out></li><li>假如类型定义为 Foo<in t=""> , 其中 T 是一个反向协变的类型参数, Foo&lt;<em>&gt; 等价于 Foo<innothing> . 它表示, 当 T 未知时, 你不能安全地向 Foo&lt;</innothing></em>&gt; 写入 任何东西.</in></li><li>假如类型定义为 Foo<t> , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo&lt;*&gt; 等价于 Foo<out tupper=""> , 对于写入值的场合, 等价于 Foo<in nothing=""> .</in></out></t></li></ul><p>如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function<in t,="" out="" u=""> , 那么可以出现以下几种星号投射:</in></p><ol><li>Function&lt;*, String&gt; , 代表 Function<in nothing,="" string=""> ;</in></li><li>Function<int, *=""> , 代表 Function<int, out="" any?=""> ;</int,></int,></li><li>Function&lt;<em>,</em> &gt; , 代表 Function<in nothing,="" out="" any?=""> .</in></li></ol><p>注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用</p>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第5章 数据类与封闭类</title>
      <link href="/2018/05/10/helloKotlin-05/"/>
      <url>/2018/05/10/helloKotlin-05/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="5-1-数据类"><a href="#5-1-数据类" class="headerlink" title="5.1 数据类"></a>5.1 数据类</h2><p>Kotlin 可以创建一个只包含数据的类，关键字为 data：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data class User(val name: String, val age: Int)</div></pre></td></tr></table></figure><p>编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：</p><ul><li><code>equals()</code> / <code>hashCode()</code></li><li><code>toString()</code> 格式如 <code>&quot;User(name=John, age=42)&quot;</code></li><li><code>componentN() functions</code> 对应于属性，按声明顺序排列</li><li><code>copy()</code> 函数 </li></ul><p>如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。</p><p>为了保证生成代码的一致性以及有意义，数据类需要满足以下条件：</p><ul><li><p>主构造函数至少包含一个参数。 </p></li><li><p>所有的主构造函数的参数必须标识为<code>val</code> 或者 <code>var</code> ;</p></li><li><p>数据类不可以声明为 <code>abstract</code>, <code>open</code>, <code>sealed</code> 或者 <code>inner</code>;</p></li><li><p>数据类不能继承其他类 (但是可以实现接口)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun copy(name: String = this.name, age: Int = this.age) = User(name, age)</div></pre></td></tr></table></figure></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun copy(name: String = this.name, age: Int = this.age) = User(name, age)</div></pre></td></tr></table></figure><p>实例</p><p>使用 copy 类复制 User 数据类，并修改 age 属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data class User(val name: String, val age: Int)</div><div class="line"></div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val jack = User(name = &quot;Jack&quot;, age = 1)</div><div class="line">    val olderJack = jack.copy(age = 2)</div><div class="line">    println(jack)</div><div class="line">    println(olderJack)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User(name=Jack, age=1)</div><div class="line">User(name=Jack, age=2)</div></pre></td></tr></table></figure><h3 id="数据类以及解构声明"><a href="#数据类以及解构声明" class="headerlink" title="数据类以及解构声明"></a>数据类以及解构声明</h3><p>组件函数允许数据类在解构声明中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val jane = User(&quot;Jane&quot;, 35)</div><div class="line">val (name, age) = jane</div><div class="line">println(&quot;$name, $age years of age&quot;) // prints &quot;Jane, 35 years of age&quot;</div></pre></td></tr></table></figure><h3 id="标准数据类"><a href="#标准数据类" class="headerlink" title="标准数据类"></a>标准数据类</h3><p>标准库提供了  Pair 和  Triple 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。</p><h2 id="5-2-封闭类"><a href="#5-2-封闭类" class="headerlink" title="5.2 封闭类"></a>5.2 封闭类</h2><p>封闭类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而封闭类 的一个子类可以有可包含状态的多个实例。</p><p>声明一个封闭类，使用 sealed 修饰类，封闭类可以有子类，但是所有的子类都必须要内嵌在封闭类中。</p><p>sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sealed class Expr</div><div class="line">data class Const(val number: Double) : Expr()</div><div class="line">data class Sum(val e1: Expr, val e2: Expr) : Expr()</div><div class="line">object NotANumber : Expr()</div><div class="line"></div><div class="line">fun eval(expr: Expr): Double = when (expr) &#123;</div><div class="line">    is Const -&gt; expr.number</div><div class="line">    is Sum -&gt; eval(expr.e1) + eval(expr.e2)</div><div class="line">    NotANumber -&gt; Double.NaN</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第4章 枚举类和扩展</title>
      <link href="/2018/05/10/helloKotlin-04/"/>
      <url>/2018/05/10/helloKotlin-04/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="4-1-Kotlin-枚举类"><a href="#4-1-Kotlin-枚举类" class="headerlink" title="4.1 Kotlin 枚举类"></a>4.1 Kotlin 枚举类</h2><p>枚举类最基本的用法是实现一个类型安全的枚举。</p><p>枚举常量用逗号分隔,每个枚举常量都是一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum class Color&#123;</div><div class="line">    RED,BLACK,BLUE,GREEN,WHITE</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="枚举初始化"><a href="#枚举初始化" class="headerlink" title="枚举初始化"></a>枚举初始化</h3><p>每一个枚举都是枚举类的实例，它们可以被初始化： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum class Color(val rgb: Int) &#123;</div><div class="line">    RED(0xFF0000),</div><div class="line">    GREEN(0x00FF00),</div><div class="line">    BLUE(0x0000FF)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认名称为枚举字符名，值从0开始。若需要指定值，则可以使用其构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">enum class Shape(value:Int)&#123;</div><div class="line">    ovel(100),</div><div class="line">    rectangle(200)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>枚举还支持以声明自己的匿名类及相应的方法、以及覆盖基类的方法。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">enum class ProtocolState &#123;</div><div class="line">    WAITING &#123;</div><div class="line">        override fun signal() = TALKING</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    TALKING &#123;</div><div class="line">        override fun signal() = WAITING</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    abstract fun signal(): ProtocolState</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开</p><h3 id="使用枚举常量"><a href="#使用枚举常量" class="headerlink" title="使用枚举常量"></a>使用枚举常量</h3><p>Kotlin 中的枚举类具有合成方法，允许遍历定义的枚举常量，并通过其名称获取枚举常数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EnumClass.valueOf(value: String): EnumClass  // 转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentException</div><div class="line">EnumClass.values(): Array&lt;EnumClass&gt;        // 以数组的形式，返回枚举值</div></pre></td></tr></table></figure><p>获取枚举相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val name: String //获取枚举名称</div><div class="line">val ordinal: Int //获取枚举值在所有枚举数组中定义的顺序</div></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">enum class Color&#123;</div><div class="line">    RED,BLACK,BLUE,GREEN,WHITE</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var color:Color=Color.BLUE</div><div class="line"></div><div class="line">    println(Color.values())</div><div class="line">    println(Color.valueOf(&quot;RED&quot;))</div><div class="line">    println(color.name)</div><div class="line">    println(color.ordinal)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>自 Kotlin 1.1 起，可以使用 <code>enumValues&lt;T&gt;()</code> 和 <code>enumValueOf&lt;T&gt;()</code> 函数以泛型的方式访问枚举类中的常量 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">enum class RGB &#123; RED, GREEN, BLUE &#125;</div><div class="line"></div><div class="line">inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123;</div><div class="line">    print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    printAllValues&lt;RGB&gt;() // 输出 RED, GREEN, BLUE</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-Kotlin-扩展"><a href="#4-2-Kotlin-扩展" class="headerlink" title="4.2 Kotlin 扩展"></a>4.2 Kotlin 扩展</h2><p>Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。</p><p>扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。</p><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun receiverType.functionName(params)&#123;</div><div class="line">    body</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>receiverType：表示函数的接收者，也就是函数扩展的对象</li><li>functionName：扩展函数的名称</li><li>params：扩展函数的参数，可以为NULL</li></ul><p>以下实例扩展 User 类 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class User(var name:String)</div><div class="line"></div><div class="line">/**扩展函数**/</div><div class="line">fun User.Print()&#123;</div><div class="line">    print(&quot;用户名 $name&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(arg:Array&lt;String&gt;)&#123;</div><div class="line">    var user = User(&quot;Shijiacheng&quot;)</div><div class="line">    user.Print()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">用户名 Shijiacheng</div></pre></td></tr></table></figure><p>下面代码为 MutableList 添加一个swap 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 扩展函数 swap,调换不同位置的值</div><div class="line">fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123;</div><div class="line">    val tmp = this[index1]     //  this 对应该列表</div><div class="line">    this[index1] = this[index2]</div><div class="line">    this[index2] = tmp</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line"></div><div class="line">    val l = mutableListOf(1, 2, 3)</div><div class="line">    // 位置 0 和 2 的值做了互换</div><div class="line">    l.swap(0, 2) // &apos;swap()&apos; 函数内的 &apos;this&apos; 将指向 &apos;l&apos; 的值</div><div class="line"></div><div class="line">    println(l.toString())</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[3, 2, 1]</div></pre></td></tr></table></figure><p>this关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。</p><h3 id="扩展函数是静态解析的"><a href="#扩展函数是静态解析的" class="headerlink" title="扩展函数是静态解析的"></a>扩展函数是静态解析的</h3><p>扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">open class C</div><div class="line"></div><div class="line">class D: C()</div><div class="line"></div><div class="line">fun C.foo() = &quot;c&quot;   // 扩展函数 foo</div><div class="line"></div><div class="line">fun D.foo() = &quot;d&quot;   // 扩展函数 foo</div><div class="line"></div><div class="line">fun printFoo(c: C) &#123;</div><div class="line">    println(c.foo())  // 类型是 C 类</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(arg:Array&lt;String&gt;)&#123;</div><div class="line">    printFoo(D())</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c</div></pre></td></tr></table></figure><p>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    fun foo() &#123; println(&quot;成员函数&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun C.foo() &#123; println(&quot;扩展函数&quot;) &#125;</div><div class="line"></div><div class="line">fun main(arg:Array&lt;String&gt;)&#123;</div><div class="line">    var c = C()</div><div class="line">    c.foo()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">成员函数</div></pre></td></tr></table></figure><h3 id="扩展一个空对象"><a href="#扩展一个空对象" class="headerlink" title="扩展一个空对象"></a>扩展一个空对象</h3><p>在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun Any?.toString(): String &#123;</div><div class="line">    if (this == null) return &quot;null&quot;</div><div class="line">    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()</div><div class="line">    // 解析为 Any 类的成员函数</div><div class="line">    return toString()</div><div class="line">&#125;</div><div class="line">fun main(arg:Array&lt;String&gt;)&#123;</div><div class="line">    var t = null</div><div class="line">    println(t.toString())</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">null</div></pre></td></tr></table></figure><h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>除了函数，Kotlin 也支持属性对属性进行扩展:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int</div><div class="line">    get() = size - 1</div></pre></td></tr></table></figure><p>扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val Foo.bar = 1 // 错误：扩展属性不能有初始化器</div></pre></td></tr></table></figure><p>扩展属性只能被声明为 val。</p><h3 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h3><p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。</p><p>伴生对象通过”类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">    companion object &#123; &#125;  // 将被称为 &quot;Companion&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun MyClass.Companion.foo() &#123;</div><div class="line">    println(&quot;伴随对象的扩展函数&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">val MyClass.Companion.no: Int</div><div class="line">    get() = 10</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(&quot;no:$&#123;MyClass.no&#125;&quot;)</div><div class="line">    MyClass.foo()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">no:10</div><div class="line">伴随对象的扩展函数</div></pre></td></tr></table></figure><h3 id="扩展的作用域"><a href="#扩展的作用域" class="headerlink" title="扩展的作用域"></a>扩展的作用域</h3><p>通常扩展函数或属性定义在顶级包下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">package foo.bar</div><div class="line"></div><div class="line">fun Baz.goo() &#123; …… &#125;</div></pre></td></tr></table></figure><p>要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.example.usage</div><div class="line"></div><div class="line">import foo.bar.goo // 导入所有名为 goo 的扩展</div><div class="line">                   // 或者</div><div class="line">import foo.bar.*   // 从 foo.bar 导入一切</div><div class="line"></div><div class="line">fun usage(baz: Baz) &#123;</div><div class="line">    baz.goo()</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="扩展声明为成员"><a href="#扩展声明为成员" class="headerlink" title="扩展声明为成员"></a>扩展声明为成员</h3><p>在一个类内部你可以为另一个类声明扩展。</p><p>在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class D &#123;</div><div class="line">    fun bar() &#123; println(&quot;D bar&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C &#123;</div><div class="line">    fun baz() &#123; println(&quot;C baz&quot;) &#125;</div><div class="line"></div><div class="line">    fun D.foo() &#123;</div><div class="line">        bar()   // 调用 D.bar</div><div class="line">        baz()   // 调用 C.baz</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun caller(d: D) &#123;</div><div class="line">        d.foo()   // 调用扩展函数</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val c: C = C()</div><div class="line">    val d: D = D()</div><div class="line">    c.caller(d)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D bar</div><div class="line">C baz</div></pre></td></tr></table></figure><p>在 C 类内，创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。</p><p>假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class D &#123;</div><div class="line">    fun bar() &#123; println(&quot;D bar&quot;) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C &#123;</div><div class="line">    fun bar() &#123; println(&quot;C bar&quot;) &#125;  // 与 D 类 的 bar 同名</div><div class="line"></div><div class="line">    fun D.foo() &#123;</div><div class="line">        bar()         // 调用 D.bar()，扩展接收者优先</div><div class="line">        this@C.bar()  // 调用 C.bar()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun caller(d: D) &#123;</div><div class="line">        d.foo()   // 调用扩展函数</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val c: C = C()</div><div class="line">    val d: D = D()</div><div class="line">    c.caller(d)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D bar</div><div class="line">C bar</div></pre></td></tr></table></figure><p>以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">open class D &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class D1 : D() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">open class C &#123;</div><div class="line">    open fun D.foo() &#123;</div><div class="line">        println(&quot;D.foo in C&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open fun D1.foo() &#123;</div><div class="line">        println(&quot;D1.foo in C&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun caller(d: D) &#123;</div><div class="line">        d.foo()   // 调用扩展函数</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class C1 : C() &#123;</div><div class="line">    override fun D.foo() &#123;</div><div class="line">        println(&quot;D.foo in C1&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun D1.foo() &#123;</div><div class="line">        println(&quot;D1.foo in C1&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    C().caller(D())   // 输出 &quot;D.foo in C&quot;</div><div class="line">    C1().caller(D())  // 输出 &quot;D.foo in C1&quot; —— 分发接收者虚拟解析</div><div class="line">    C().caller(D1())  // 输出 &quot;D.foo in C&quot; —— 扩展接收者静态解析</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">D.foo in C</div><div class="line">D.foo in C1</div><div class="line">D.foo in C</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第3章 类和接口</title>
      <link href="/2018/05/10/helloKotlin-03/"/>
      <url>/2018/05/10/helloKotlin-03/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="3-1类的声明"><a href="#3-1类的声明" class="headerlink" title="3.1类的声明"></a>3.1类的声明</h2><p>和Java一样，类的声明使用class关键字，如果声明一个空类，Kotlin和Java没有任何区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class MyClass&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2构造器"><a href="#3-2构造器" class="headerlink" title="3.2构造器"></a>3.2构造器</h2><p>类允许定义一个主构造器和若干个第二构造器。</p><h3 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h3><p>主构造器是类头的一部分，紧跟在类名后面，构造器参数是可选的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Person constructor(firstName:String)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果主构造器没有任何注释和修饰器，constructor关键字可省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Person (firstName:String)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主构造器需要在init块中进行初始化，在init块中可以直接使用主构造器的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person (firstName:String)&#123;</div><div class="line">    init &#123;</div><div class="line">        println(firstName)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主构造器的参数不仅可以用在init块中，还可以用于对类属性进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Person (firstName:String)&#123;</div><div class="line">    var name = firstName</div><div class="line">    init &#123;</div><div class="line">        println(firstName)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意：即使在构造器内部使用var声明变量，修改参数变量值后，并不会把修改的值传到对象外部。</p><h3 id="第二构造器"><a href="#第二构造器" class="headerlink" title="第二构造器"></a>第二构造器</h3><p>Kotlin可以声明若干个第二构造器。第二构造器需要在类中声明，前面必须要加constructor关键字。</p><p>如果类中声明了主构造器，那么所有的第二构造器都需要在声明后面调用主构造器，或者通过另外一个第二构造器间接地调用主构造器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class QACommunity(var url:String)&#123;</div><div class="line">    //主构造器实现</div><div class="line">    init &#123;</div><div class="line">        println(url)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 第二构造器（通过this直接调用了主构造器）</div><div class="line">    constructor(value:Int):this(&quot;shijiacheng.studio&quot;)&#123;</div><div class="line">        println(value)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 第二构造器（通过this直接调用了主构造器）</div><div class="line">    constructor(desc:String,url: String):this(&quot;(&quot;+url+&quot;)&quot;)&#123;</div><div class="line">        println(desc+&quot;:&quot;+url)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 第二构造器（通过this调用了第二构造器，间接的调用了主构造器）</div><div class="line">    constructor():this(20)&#123;</div><div class="line">        println(&quot;&lt;http://shijiacheng.studio&gt;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用QACommunity类的每个构造器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(&quot;*****第1个*****&quot;)</div><div class="line">    QACommunity(&quot;http://shijiacheng.studio&quot;)</div><div class="line">    println(&quot;*****第2个*****&quot;)</div><div class="line">    QACommunity(20)</div><div class="line">    println(&quot;*****第3个*****&quot;)</div><div class="line">    QACommunity(&quot;我的博客&quot;,&quot;http://shijiacheng.studio&quot;)</div><div class="line">    println(&quot;*****第4个*****&quot;)</div><div class="line">    QACommunity()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">*****第1个*****</div><div class="line">http://shijiacheng.studio</div><div class="line">*****第2个*****</div><div class="line">shijiacheng.studio</div><div class="line">20</div><div class="line">*****第3个*****</div><div class="line">(http://shijiacheng.studio)</div><div class="line">我的博客:http://shijiacheng.studio</div><div class="line">*****第4个*****</div><div class="line">shijiacheng.studio</div><div class="line">20</div><div class="line">&lt;http://shijiacheng.studio&gt;</div></pre></td></tr></table></figure><p>注意：在主构造器参数中可以使用可以使用var和val，但在第二构造器参数中不能使用var和val。这就意味着第二构造器的参数都是只读的，不能在构造器内部改变参数的值。</p><h3 id="Kotlin中的Singleton模式"><a href="#Kotlin中的Singleton模式" class="headerlink" title="Kotlin中的Singleton模式"></a>Kotlin中的Singleton模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Singleton private constructor() &#123;</div><div class="line">    public var value: Singleton? = null</div><div class="line"></div><div class="line">    private object mHolder &#123;</div><div class="line">        val INSTANCE = Singleton()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    companion object Factory &#123;</div><div class="line">        fun getInstance(): Singleton &#123;</div><div class="line">            return mHolder.INSTANCE</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行下面代码，访问Singleton类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var obj1 = Singleton.getInstance()</div><div class="line">    var obj2 = Singleton.getInstance()</div><div class="line"></div><div class="line">    println(obj1)</div><div class="line">    println(obj2)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">com.shijc.hellokotlin.unit03.Singleton@355da254</div><div class="line">com.shijc.hellokotlin.unit03.Singleton@355da254</div></pre></td></tr></table></figure><p>执行这段代码后，会输出如下内容，我们会发现。obj1和obj2的输出结果完全一样。这就证明了obj1和obj2是完全一样的。</p><h3 id="Kotlin函数中的默认参数"><a href="#Kotlin函数中的默认参数" class="headerlink" title="Kotlin函数中的默认参数"></a>Kotlin函数中的默认参数</h3><p>Kotlin函数支持默认参数，例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class Customer(var customerName:String = &quot;Bill&quot;,var value: Float = 20.4F)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果创建Customer的实例，可以直接使用Customer()。customerName和value的参数值就会使用Bill和20.4。</p><h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>在Kotlin中创建类的实例不需要使用new关键字。因此，调用函数和创建类的实例在语法上没有区别。只能通过上下文来区分。</p><h2 id="3-3类成员"><a href="#3-3类成员" class="headerlink" title="3.3类成员"></a>3.3类成员</h2><h3 id="属性的基本用法"><a href="#属性的基本用法" class="headerlink" title="属性的基本用法"></a>属性的基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var/val &lt;propertyName&gt;[:&lt;propertyType&gt;][=&lt;property_initializer&gt;]</div><div class="line">[&lt;getter&gt;]</div><div class="line">[&lt;setter&gt;]</div></pre></td></tr></table></figure><p>在属性语法中，只有var/val和propertyName(属性名)是必须的，其他都是可选的。如果要引用属性，就行引用变量一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Customer2&#123;</div><div class="line"></div><div class="line">    var name:String = &quot;Bill&quot;</div><div class="line">    var value:Int = 20</div><div class="line">    var flag:Boolean = true</div><div class="line"></div><div class="line">    fun getDesc()&#123;</div><div class="line">        println(&quot;name=$&#123;name&#125; value=$&#123;value&#125; flag=$&#123;flag&#125;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="属性的getter和setter形式"><a href="#属性的getter和setter形式" class="headerlink" title="属性的getter和setter形式"></a>属性的getter和setter形式</h3><p>如果属性是只读的，需要将属性声明为val，并只添加一个getter形式，如果属性是读写的，需要使用var是声明属性，并添加getter和vsetter形式。如果getter和setter中只有一行实现代码。直接用=分割getter和代码即可。如果包含多行代码需要使用{……}处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Customer3&#123;</div><div class="line">    // 只读属性</div><div class="line">    val name:String</div><div class="line">        get() = &quot;Bill&quot;</div><div class="line"></div><div class="line">    // 读写属性</div><div class="line">    var v:Int = 20</div><div class="line">    var value:Int</div><div class="line">        get() = v</div><div class="line">        set(value)&#123;</div><div class="line">            println(&quot;value属性被设置&quot;)</div><div class="line">            v = value</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="保存属性值的字段"><a href="#保存属性值的字段" class="headerlink" title="保存属性值的字段"></a>保存属性值的字段</h3><p>在属性的getter和setter中，可以将field当做成员变量使用，也就是通过field读写属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Customer4&#123;</div><div class="line">    val name:String</div><div class="line">        get() = &quot;Bill&quot;</div><div class="line"></div><div class="line">    // 读写属性</div><div class="line">    var value:Int = 0</div><div class="line">        get() = field</div><div class="line">        set(value)&#123;</div><div class="line">            println(&quot;value属性被设置&quot;)</div><div class="line">            field = value</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>修改Customer4的value值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var customer4 = Customer4()</div><div class="line">    customer4.value = 40</div><div class="line">    println(customer4.value)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">value属性被设置</div><div class="line">40</div></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数既可以在类外部定义，也可以在类内部定义。如果是前者是全局函数，如果是后者是类成员函数。</p><p>函数也支持默认参数值。要注意的是，带默认值的参数必须是最后几个参数，也就是说，如果某个参数带默认值。那么该参数后面的所有参数都必须有默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class QACommunity2&#123;</div><div class="line">    fun printQAcommunity(url:String,schema:String=&quot;http&quot;)&#123;</div><div class="line">        println(&quot;$&#123;schema&#125;://$&#123;url&#125;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    QACommunity2().printQAcommunity(&quot;shijiacheng.studio&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://shijiacheng.studio</div></pre></td></tr></table></figure><p>如果我们想为下面的函数按顺序传入参数值，很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Person2&#123;</div><div class="line">    fun process(value: Int,name:String=&quot;Bill&quot;,age:Int=30,salary:Float=4000F)&#123;</div><div class="line">        println(&quot;value=$&#123;value&#125; name=$&#123;name&#125; age=$&#123;age&#125; salary=$&#123;salary&#125;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    Person2().process(30,&quot;Bill&quot;,30,12000F)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果我们只想修改最后 一个参数的值，安装之前的思路必须每个参数的值都传一遍，很麻烦。为了解决这个问题，Kotlin允许使用命名参数传递参数值。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    Person2().process(30,salary = 15000F)</div><div class="line">&#125;frev</div></pre></td></tr></table></figure><p>如果传入参数的参数个数不固定，就要使用可变参数了，可变参数用vararg关键字声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Person3(name: String)&#123;</div><div class="line">    private var mName:String = name</div><div class="line">    fun getName():String&#123;</div><div class="line">        return mName</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Persons&#123;</div><div class="line">    fun addPersons(vararg persons:Person3):List&lt;Person3&gt;&#123;</div><div class="line">        var result = ArrayList&lt;Person3&gt;()</div><div class="line">        for(person in persons)&#123;</div><div class="line">            result.add(person)</div><div class="line">        &#125;</div><div class="line">        return result</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用addPersons方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var persons = Persons().addPersons(Person3(&quot;Bill&quot;), Person3(&quot;Jill&quot;),Person3(&quot;Mike&quot;))</div><div class="line">    for (person in persons)&#123;</div><div class="line">        println(person.getName())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>函数单行表达式：如果Kotlin函数体只有一行代码，可以直接在函数声明后面加等号=，后面直接跟代码，这种表达方式可以省略函数返回值类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person4(name: String)&#123;</div><div class="line">    private var mName:String = name</div><div class="line">    fun getName():String&#123;</div><div class="line">        return mName</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //函数单行表达式</div><div class="line">    fun getName1():String=mName</div><div class="line">    // 函数单行表达式，省略返回值类型</div><div class="line">    fun getName2() = mName</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>本地函数：在函数体内定义函数，作用域就是包含本地函数的函数体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun addPerson(name: String)&#123;</div><div class="line">    //process函数作用域就是addPerson的函数体</div><div class="line">    fun process(age: Int)&#123;</div><div class="line">        println(&quot;age=$&#123;age&#125;&quot;)</div><div class="line">    &#125;</div><div class="line">    process(20)</div><div class="line">    println(&quot;name=$&#123;name&#125;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>嵌套类就是类中定义的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Outer&#123;</div><div class="line">    private val bar:Int = 1</div><div class="line">    //嵌套类</div><div class="line">    class Nested&#123;</div><div class="line">        fun foo() = 2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用foo方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val demo = Outer.Nested().foo()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>嵌套类还可以使用inner关键字声明，这样可以通过外部类的实例引用嵌套类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Outer2&#123;</div><div class="line">    private val bar:Int = 1</div><div class="line">    inner class Inner&#123;</div><div class="line">        fun foo() = bar</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-4修饰符（Modifiers）"><a href="#3-4修饰符（Modifiers）" class="headerlink" title="3.4修饰符（Modifiers）"></a>3.4修饰符（Modifiers）</h2><p>Kotlin中有private、protected、internal、public 4个修饰符。</p><ul><li>private：仅仅在类的内部可以访问</li><li>protected：类似private，但在子类中也可以访问</li><li>internal：在任何模块内部类都可以访问</li><li>public：任何类都可以访问</li></ul><p>如果不指定任何修饰符，默认是public。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">open class Outer3&#123;//open表明Outer2是可继承的</div><div class="line">    private val a = 1</div><div class="line">    protected open val b = 2</div><div class="line">    internal val c = 3</div><div class="line">    val d = 4 // 默认是public</div><div class="line"></div><div class="line">    protected class Nested&#123;</div><div class="line">        public val e:Int = 5</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class SubClass:Outer3()&#123;</div><div class="line">    //无法访问父类的a常量</div><div class="line">    //可以访问b、c、d</div><div class="line">    // Nested类和e变量可以访问</div><div class="line"></div><div class="line">    override val b =5 // 重写父类的常量b</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-5类的继承"><a href="#3-5类的继承" class="headerlink" title="3.5类的继承"></a>3.5类的继承</h2><h3 id="类如何继承"><a href="#类如何继承" class="headerlink" title="类如何继承"></a>类如何继承</h3><p>Kotlin类的继承需要使用冒号（:）,冒号后需要调用父类的构造器，与Java一样，都是单继承的。要注意的是，Kotlin默认时class是final的，也就是说，默认时class不允许继承，需要显式的使用open关键字允许继承class。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">open class Parent &#123;// 需要open声明Parent，才允许其他类继承</div><div class="line">    protected var mName: String = &quot;Bill&quot;</div><div class="line"></div><div class="line">    fun getName(): String &#123;</div><div class="line">        return mName</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Child:Parent()&#123;</div><div class="line">    //Child类继承了Parent类，mName和getName在Child中都可以访问了</div><div class="line"></div><div class="line">    fun printName()&#123;</div><div class="line">        println(mName)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>如果要在子类中重写方法，就需要在父类相应的方法前面加open关键字，而且要在子类重写的方法前面加override关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">open class Parent2 &#123;// 需要open声明Parent，才允许其他类继承</div><div class="line">    protected var mName: String = &quot;Bill&quot;</div><div class="line"></div><div class="line">    open fun getName(): String &#123;</div><div class="line">        // 只有加open关键字，getname才可以被子类的方法重写</div><div class="line">        return mName</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">open class Child2:Parent2()&#123;</div><div class="line">    //Child类继承了Parent类，mName和getName在Child中都可以访问了</div><div class="line"></div><div class="line">    fun printName()&#123;</div><div class="line">        println(getName())</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 重写父类的getname方法</div><div class="line">    override fun getName(): String &#123;</div><div class="line">        return &quot;&lt;&quot;+super.getName()+&quot;&gt;&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在调用Child2l类的getName方法，实际上执行的是Child2自身的getName方法，而不是Parent2类的getName方法。</p><p>如果一个方法前加了override，那么这个方法就可以被重写了，例如Child2类的getName方法在子类中是可以被再次重写的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyChild2:Child2()&#123;</div><div class="line">    //再次重写getName方法</div><div class="line">    override fun getName(): String &#123;</div><div class="line">        return &quot;[&quot;+super.getName()+&quot;]&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果想阻止getName方法被子类重写，需要在override前面加final</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyChild3:Child2()&#123;</div><div class="line">    //再次重写getName方法</div><div class="line">    final override fun getName(): String &#123;</div><div class="line">        return &quot;[&quot;+super.getName()+&quot;]&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h3><p>属性的重写方式与方法类似，被重写的属性必须使用open声明，子类中重写的属性必须使用overr声明。注意的是，val属性可以被重写为var属性，但反过来不可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">open class Parent3&#123;</div><div class="line">    open val name:String=&quot;Bill&quot;</div><div class="line">        get() &#123;</div><div class="line">            println(&quot;获取Parent.name属性值&quot;)</div><div class="line">            return field</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">open class Child3:Parent3()&#123;</div><div class="line">    override var name:String = &quot;Mike&quot;</div><div class="line">        get() &#123;</div><div class="line">            println(&quot;获取Child3.name属性值&quot;)</div><div class="line">            return field</div><div class="line">        &#125;</div><div class="line">        set(value)&#123;</div><div class="line">            field = value</div><div class="line">            println(&quot;Child3.name被写入&quot;)</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var child = Child3()</div><div class="line">    child.name = &quot;John&quot;</div><div class="line">    println(child.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Child3.name被写入</div><div class="line">获取Child3.name属性值</div><div class="line">John</div></pre></td></tr></table></figure><h2 id="3-6接口"><a href="#3-6接口" class="headerlink" title="3.6接口"></a>3.6接口</h2><p>接口使用interface关键字声明，一个类可以实现多个接口。实现的方法和类继承相似。而且接口中的属性和方法都是open的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">interface MyInterface&#123;</div><div class="line">    fun process()</div><div class="line">    fun getName():String&#123;</div><div class="line">        return &quot;Bill&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyClass2 :MyInterface&#123;</div><div class="line">    override fun process() &#123;</div><div class="line">        println(&quot;process&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun getName(): String &#123;</div><div class="line">        return &quot;Mike&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(MyClass2().getName())</div><div class="line">    MyClass2().process()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Kotlin中，允许接口的方法包含默认的方法体。对于有方法体的接口方法。并不要求一定重写该方法。也就是说getName方法可以在MyClass2中不重写。</p><h2 id="3-7抽象类"><a href="#3-7抽象类" class="headerlink" title="3.7抽象类"></a>3.7抽象类</h2><p>抽象类不能被实例化，需要使用abstract关键字声明，抽象类实现接口后，接口中没有函数体的函数可以不重写（override），接口中的这些方法就自动被继承到实现接口的抽象类中，称为抽象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">open class Base&#123;</div><div class="line">    open fun f()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Derived:Base()&#123;</div><div class="line">    override abstract fun f()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>抽象方法不需要使用open声明，因为抽象类本身就是可继承的。</p>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第2章 Kotlin基础知识</title>
      <link href="/2018/05/10/helloKotlin-02/"/>
      <url>/2018/05/10/helloKotlin-02/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="2-1-Kotlin基础语法"><a href="#2-1-Kotlin基础语法" class="headerlink" title="2.1 Kotlin基础语法"></a>2.1 Kotlin基础语法</h2><p>Kotlin 文件以 .kt 为后缀。</p><h3 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h3><p>代码文件的开头一般为包的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.shijc.main</div><div class="line"></div><div class="line">import java.util.*</div><div class="line"></div><div class="line">fun test() &#123;&#125;</div><div class="line">class Shijiacheng &#123;&#125;</div></pre></td></tr></table></figure><p>kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。</p><p>以上例中 test() 的全名是 com.shijc.main.test、Shijiacheng 的全名是 com.shijc.main.Shijiacheng。</p><p>如果没有指定包，默认为 default 包。</p><h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>有多个包会默认导入到每个 Kotlin 文件中：</p><ul><li>kotlin.*</li><li>kotlin.annotation.*</li><li>kotlin.collections.*</li><li>kotlin.comparisons.* </li><li>kotlin.io.*</li><li>kotlin.ranges.*</li><li>kotlin.sequences.*</li><li>kotlin.text.*</li></ul><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int): Int &#123;   // Int 参数，返回值 Int</div><div class="line">    return a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>表达式作为函数体，返回类型自动推断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun sum(a: Int, b: Int) = a + b</div><div class="line"></div><div class="line">public fun sum(a: Int, b: Int): Int = a + b   // public 方法则必须明确写出返回类型</div></pre></td></tr></table></figure><p>无返回值的函数(类似Java中的void)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun printSum(a: Int, b: Int): Unit &#123; </div><div class="line">    print(a + b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</div><div class="line">public fun printSum(a: Int, b: Int) &#123; </div><div class="line">    print(a + b)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h3><p>函数的变长参数可以用 vararg 关键字进行标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun vars(vararg v:Int)&#123;</div><div class="line">    for(vt in v)&#123;</div><div class="line">        print(vt)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 测试</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    vars(1,2,3,4,5)  // 输出12345</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h3><p>lambda表达式使用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 测试</div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125;</div><div class="line">    println(sumLambda(1,2))  // 输出 3</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="定义常量与变量"><a href="#定义常量与变量" class="headerlink" title="定义常量与变量"></a>定义常量与变量</h3><p>可变变量定义：var 关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</div></pre></td></tr></table></figure><p>不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</div></pre></td></tr></table></figure><p>常量与变量都可以没有初始化值,但是在引用前必须初始化</p><p>编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1</div><div class="line">val b = 1       // 系统自动推断变量类型为Int</div><div class="line">val c: Int      // 如果不在声明时初始化则必须提供变量类型</div><div class="line">c = 1           // 明确赋值</div><div class="line"></div><div class="line"></div><div class="line">var x = 5        // 系统自动推断变量类型为Int</div><div class="line">x += 1           // 变量可修改</div></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Kotlin 支持单行和多行注释，实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 这是一个单行注释</div><div class="line"></div><div class="line">/* 这是一个多行的</div><div class="line">   块注释。 */</div></pre></td></tr></table></figure><p>与 Java 不同, Kotlin 中的块注释允许嵌套。</p><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>$ 表示一个变量名或者变量值</p><p>$varName 表示变量值</p><p>${varName.fun()} 表示变量的方法返回值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1</div><div class="line">// 模板中的简单名称：</div><div class="line">val s1 = &quot;a is $a&quot; </div><div class="line"></div><div class="line">a = 2</div><div class="line">// 模板中的任意表达式：</div><div class="line">val s2 = &quot;$&#123;s1.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;</div></pre></td></tr></table></figure><h3 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h3><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//类型后面加?表示可为空</div><div class="line">var age: String? = &quot;23&quot; </div><div class="line">//抛出空指针异常</div><div class="line">val ages = age!!.toInt()</div><div class="line">//不做处理返回 null</div><div class="line">val ages1 = age?.toInt()</div><div class="line">//age为空返回-1</div><div class="line">val ages2 = age?.toInt() ?: -1</div></pre></td></tr></table></figure><p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。</p><p>当 str 中的字符串内容不是一个整数时, 返回 null:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun parseInt(str: String): Int? &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以下实例演示如何使用一个返回值可为 null 的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">  if (args.size &lt; 2) &#123;</div><div class="line">    print(&quot;Two integers expected&quot;)</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  val x = parseInt(args[0])</div><div class="line">  val y = parseInt(args[1])</div><div class="line">  // 直接使用 `x * y` 会导致错误, 因为它们可能为 null.</div><div class="line">  if (x != null &amp;&amp; y != null) &#123;</div><div class="line">    // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量</div><div class="line">    print(x * y)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="类型检测及自动类型转换"><a href="#类型检测及自动类型转换" class="headerlink" title="类型检测及自动类型转换"></a>类型检测及自动类型转换</h3><p>我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  if (obj is String) &#123;</div><div class="line">    // 做过类型判断以后，obj会被系统自动转换为String类型</div><div class="line">    return obj.length </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //在这里还有一种方法，与Java中instanceof不同，使用!is</div><div class="line">  // if (obj !is String)&#123;</div><div class="line">  //   // XXX</div><div class="line">  // &#125;</div><div class="line"></div><div class="line">  // 这里的obj仍然是Any类型的引用</div><div class="line">  return null</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  if (obj !is String)</div><div class="line">    return null</div><div class="line">  // 在这个分支中, `obj` 的类型会被自动转换为 `String`</div><div class="line">  return obj.length</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>甚至还可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun getStringLength(obj: Any): Int? &#123;</div><div class="line">  // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String`</div><div class="line">  if (obj is String &amp;&amp; obj.length &gt; 0)</div><div class="line">    return obj.length</div><div class="line">  return null</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p>区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。 </p><p>区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">for (i in 1..4) print(i) // 输出“1234”</div><div class="line"></div><div class="line">for (i in 4..1) print(i) // 什么都不输出</div><div class="line"></div><div class="line">if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</div><div class="line">    println(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 使用 step 指定步长</div><div class="line">for (i in 1..4 step 2) print(i) // 输出“13”</div><div class="line"></div><div class="line">for (i in 4 downTo 1 step 2) print(i) // 输出“42”</div><div class="line"></div><div class="line"></div><div class="line">// 使用 until 函数排除结束元素</div><div class="line">for (i in 1 until 10) &#123;   // i in [1, 10) 排除了 10</div><div class="line">     println(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    print(&quot;循环输出：&quot;)</div><div class="line">    for (i in 1..4) print(i) // 输出“1234”</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">    print(&quot;设置步长：&quot;)</div><div class="line">    for (i in 1..4 step 2) print(i) // 输出“13”</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">    print(&quot;使用 downTo：&quot;)</div><div class="line">    for (i in 4 downTo 1 step 2) print(i) // 输出“42”</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">    print(&quot;使用 until：&quot;)</div><div class="line">    // 使用 until 函数排除结束元素</div><div class="line">    for (i in 1 until 4) &#123;   // i in [1, 4) 排除了 4</div><div class="line">        print(i)</div><div class="line">    &#125;</div><div class="line">    println(&quot;\n----------------&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">循环输出：1234</div><div class="line">----------------</div><div class="line">设置步长：13</div><div class="line">----------------</div><div class="line">使用 downTo：42</div><div class="line">----------------</div><div class="line">使用 until：123</div><div class="line">----------------</div></pre></td></tr></table></figure><h2 id="2-2-Kotlin-基本数据类型"><a href="#2-2-Kotlin-基本数据类型" class="headerlink" title="2.2 Kotlin 基本数据类型"></a>2.2 Kotlin 基本数据类型</h2><p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于Java的是，字符不属于数值类型，是一个独立的数据类型。 </p><table><thead><tr><th>类型</th><th>位宽度</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><p>下面是所有类型的字面常量：</p><ul><li>十进制：123</li><li>长整型以大写的 L 结尾：123L</li><li>16 进制以 0x 开头：0x0F</li><li>2 进制以 0b 开头：0b00001011</li><li>注意：8进制不支持</li></ul><p>Kotlin 同时也支持传统符号表示的浮点数值：</p><ul><li>Doubles 默认写法: <code>123.5</code>, <code>123.5e10</code></li><li>Floats 使用 f 或者 F 后缀：<code>123.5f</code></li></ul><p>你可以使用下划线使数字常量更易读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val oneMillion = 1_000_000</div><div class="line">val creditCardNumber = 1234_5678_9012_3456L</div><div class="line">val socialSecurityNumber = 999_99_9999L</div><div class="line">val hexBytes = 0xFF_EC_DE_5E</div><div class="line">val bytes = 0b11010010_01101001_10010100_10010010</div></pre></td></tr></table></figure><h3 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h3><p>Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所有在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p><p>在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val a: Int = 10000</div><div class="line">    println(a === a) // true，值相等，对象地址相等</div><div class="line"></div><div class="line">    //经过了装箱，创建了两个不同的对象</div><div class="line">    val boxedA: Int? = a</div><div class="line">    val anotherBoxedA: Int? = a</div><div class="line"></div><div class="line">    //虽然经过了装箱，但是值是相等的，都是10000</div><div class="line">    println(boxedA === anotherBoxedA) //  false，值相等，对象地址不一样</div><div class="line">    println(boxedA == anotherBoxedA) // true，值相等</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val b: Byte = 1 // OK, 字面值是静态检测的</div><div class="line">val i: Int = b // 错误</div></pre></td></tr></table></figure><p>我们可以代用其toInt()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val b: Byte = 1 // OK, 字面值是静态检测的</div><div class="line">val i: Int = b.toInt() // OK</div></pre></td></tr></table></figure><p>每种数据类型都有下面的这些方法，可以转化为其它的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">toByte(): Byte</div><div class="line">toShort(): Short</div><div class="line">toInt(): Int</div><div class="line">toLong(): Long</div><div class="line">toFloat(): Float</div><div class="line">toDouble(): Double</div><div class="line">toChar(): Char</div></pre></td></tr></table></figure><p>有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val l = 1L + 3 // Long + Int =&gt; Long</div></pre></td></tr></table></figure><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>对于Int和Long类型，还有一系列的位操作符可以使用，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">shl(bits) – 左移位 (Java’s &lt;&lt;)</div><div class="line">shr(bits) – 右移位 (Java’s &gt;&gt;)</div><div class="line">ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</div><div class="line">and(bits) – 与</div><div class="line">or(bits) – 或</div><div class="line">xor(bits) – 异或</div><div class="line">inv() – 反向</div></pre></td></tr></table></figure><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ‘ 包含起来的。比如普通字符 ‘0’，’a’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun check(c: Char) &#123;</div><div class="line">    if (c == 1) &#123; // 错误：类型不兼容</div><div class="line">        // ……</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\t、 \b、\n、\r、\’、\”、\ 和 \$。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’。</p><p>我们可以显式把字符转换为 Int 数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun decimalDigitValue(c: Char): Int &#123;</div><div class="line">    if (c !in &apos;0&apos;..&apos;9&apos;)</div><div class="line">        throw IllegalArgumentException(&quot;Out of range&quot;)</div><div class="line">    return c.toInt() - &apos;0&apos;.toInt() // 显式转换为数字</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。</p><h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><p>布尔用 Boolean 类型表示，它有两个值：true 和 false。</p><p>若需要可空引用布尔会被装箱。</p><p>内置的布尔运算有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">|| – 短路逻辑或</div><div class="line">&amp;&amp; – 短路逻辑与</div><div class="line">! - 逻辑非</div></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。</p><p>数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    //[1,2,3]</div><div class="line">    val a = arrayOf(1, 2, 3)</div><div class="line">    //[0,2,4]</div><div class="line">    val b = Array(3, &#123; i -&gt; (i * 2) &#125;)</div><div class="line"></div><div class="line">    //读取数组内容</div><div class="line">    println(a[0])    // 输出结果：1</div><div class="line">    println(b[1])    // 输出结果：2</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上所述，[] 运算符代表调用成员函数 get() 和 set()。</p><p>注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。</p><p>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val x: IntArray = intArrayOf(1, 2, 3)</div><div class="line">x[0] = x[1] + x[2]</div></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>和 Java 一样，String 是可不变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (c in str) &#123;</div><div class="line">    println(c)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val text = &quot;&quot;&quot;</div><div class="line">    多行字符串</div><div class="line">    多行字符串</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    println(text)   // 输出有一些前置空格</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>String 可以通过 trimMargin() 方法来删除多余的空白。</p><h2 id="2-3-Kotlin-条件控制"><a href="#2-3-Kotlin-条件控制" class="headerlink" title="2.3 Kotlin 条件控制"></a>2.3 Kotlin 条件控制</h2><h3 id="IF-表达式"><a href="#IF-表达式" class="headerlink" title="IF 表达式"></a>IF 表达式</h3><p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 传统用法</div><div class="line">var max = a </div><div class="line">if (a &lt; b) max = b</div><div class="line"></div><div class="line">// 使用 else </div><div class="line">var max: Int</div><div class="line">if (a &gt; b) &#123;</div><div class="line">    max = a</div><div class="line">&#125; else &#123;</div><div class="line">    max = b</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 作为表达式</div><div class="line">val max = if (a &gt; b) a else b</div></pre></td></tr></table></figure><p>我们也可以把 IF 表达式的结果赋值给一个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val max = if (a &gt; b) &#123;</div><div class="line">    print(&quot;Choose a&quot;)</div><div class="line">    a</div><div class="line">&#125; else &#123;</div><div class="line">    print(&quot;Choose b&quot;)</div><div class="line">    b</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val c = if (condition) a else b</div></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var x = 0</div><div class="line">    if(x&gt;0)&#123;</div><div class="line">        println(&quot;x 大于 0&quot;)</div><div class="line">    &#125;else if(x==0)&#123;</div><div class="line">        println(&quot;x 等于 0&quot;)</div><div class="line">    &#125;else&#123;</div><div class="line">        println(&quot;x 小于 0&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var a = 1</div><div class="line">    var b = 2</div><div class="line">    val c = if (a&gt;=b) a else b</div><div class="line">    println(&quot;c 的值为 $c&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x 等于 0</div><div class="line">c 的值为 2</div></pre></td></tr></table></figure><h3 id="使用区间"><a href="#使用区间" class="headerlink" title="使用区间"></a>使用区间</h3><p>使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ：</p><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val x = 5</div><div class="line">    val y = 9</div><div class="line">    if (x in 1..8) &#123;</div><div class="line">        println(&quot;x 在区间内&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x 在区间内</div></pre></td></tr></table></figure><h3 id="When-表达式"><a href="#When-表达式" class="headerlink" title="When 表达式"></a>When 表达式</h3><p>when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。</p><p>when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。</p><p>when 类似其他语言的 switch 操作符。其最简单的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    1 -&gt; print(&quot;x == 1&quot;)</div><div class="line">    2 -&gt; print(&quot;x == 2&quot;)</div><div class="line">    else -&gt; &#123; // 注意这个块</div><div class="line">        print(&quot;x 不是 1 ，也不是 2&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支。 </p><p>如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;)</div><div class="line">    else -&gt; print(&quot;otherwise&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">when (x) &#123;</div><div class="line">    in 1..10 -&gt; print(&quot;x is in the range&quot;)</div><div class="line">    in validNumbers -&gt; print(&quot;x is valid&quot;)</div><div class="line">    !in 10..20 -&gt; print(&quot;x is outside the range&quot;)</div><div class="line">    else -&gt; print(&quot;none of the above&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun hasPrefix(x: Any) = when(x) &#123;</div><div class="line">    is String -&gt; x.startsWith(&quot;prefix&quot;)</div><div class="line">    else -&gt; false</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">when &#123;</div><div class="line">    x.isOdd() -&gt; print(&quot;x is odd&quot;)</div><div class="line">    x.isEven() -&gt; print(&quot;x is even&quot;)</div><div class="line">    else -&gt; print(&quot;x is funny&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var x = 0</div><div class="line">    when (x) &#123;</div><div class="line">        0, 1 -&gt; println(&quot;x == 0 or x == 1&quot;)</div><div class="line">        else -&gt; println(&quot;otherwise&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    when (x) &#123;</div><div class="line">        1 -&gt; println(&quot;x == 1&quot;)</div><div class="line">        2 -&gt; println(&quot;x == 2&quot;)</div><div class="line">        else -&gt; &#123; // 注意这个块</div><div class="line">            println(&quot;x 不是 1 ，也不是 2&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    when (x) &#123;</div><div class="line">        in 0..10 -&gt; println(&quot;x 在该区间范围内&quot;)</div><div class="line">        else -&gt; println(&quot;x 不在该区间范围内&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x == 0 or x == 1</div><div class="line">x 不是 1 ，也不是 2</div><div class="line">x 在该区间范围内</div></pre></td></tr></table></figure><p>when 中使用 in 运算符来判断集合内是否包含某实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val items = setOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;)</div><div class="line">    when &#123;</div><div class="line">        &quot;orange&quot; in items -&gt; println(&quot;juicy&quot;)</div><div class="line">        &quot;apple&quot; in items -&gt; println(&quot;apple is fine too&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apple is fine too</div></pre></td></tr></table></figure><h2 id="2-4-Kotlin-循环控制"><a href="#2-4-Kotlin-循环控制" class="headerlink" title="2.4 Kotlin 循环控制"></a>2.4 Kotlin 循环控制</h2><h3 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h3><p>for 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (item in collection) print(item)</div></pre></td></tr></table></figure><p>循环体可以是一个代码块:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (item: Int in ints) &#123;</div><div class="line">    // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上所述，for 可以循环遍历任何提供了迭代器的对象。</p><p>如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i in array.indices) &#123;</div><div class="line">    print(array[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。</p><p>或者你可以用库函数 withIndex：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for ((index, value) in array.withIndex()) &#123;</div><div class="line">    println(&quot;the element at $index is $value&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实例</p><p>对集合进行迭代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;)</div><div class="line">    for (item in items) &#123;</div><div class="line">        println(item)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (index in items.indices) &#123;</div><div class="line">        println(&quot;item at $index is $&#123;items[index]&#125;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">apple</div><div class="line">banana</div><div class="line">kiwi</div><div class="line">item at 0 is apple</div><div class="line">item at 1 is banana</div><div class="line">item at 2 is kiwi</div></pre></td></tr></table></figure><h3 id="while-与-do…while-循环"><a href="#while-与-do…while-循环" class="headerlink" title="while 与 do…while 循环"></a>while 与 do…while 循环</h3><p>while是最基本的循环，它的结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while( 布尔表达式 ) &#123;</div><div class="line">  //循环内容</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">do &#123;</div><div class="line">       //代码语句</div><div class="line">&#125;while(布尔表达式);</div></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(&quot;----while 使用-----&quot;)</div><div class="line">    var x = 5</div><div class="line">    while (x &gt; 0) &#123;</div><div class="line">        println( x--)</div><div class="line">    &#125;</div><div class="line">    println(&quot;----do...while 使用-----&quot;)</div><div class="line">    var y = 5</div><div class="line">    do &#123;</div><div class="line">        println(y--)</div><div class="line">    &#125; while(y&gt;0)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">4</div><div class="line">3</div><div class="line">2</div><div class="line">1</div><div class="line">----do...while 使用-----</div><div class="line">5</div><div class="line">4</div><div class="line">3</div><div class="line">2</div><div class="line">1</div></pre></td></tr></table></figure><h3 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h3><p>Kotlin 有三种结构化跳转表达式：</p><ul><li><em>return</em>。默认从最直接包围它的函数或者匿名函数返回。</li><li><em>break</em>。终止最直接包围它的循环。</li><li><em>continue</em>。继续下一次最直接包围它的循环。</li></ul><p>在循环中 Kotlin 支持传统的 break 和 continue 操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    for (i in 1..10) &#123;</div><div class="line">        if (i==3) continue  // i 为 3 时跳过当前循环，继续下一次循环</div><div class="line">        println(i)</div><div class="line">        if (i&gt;5) break   // i 为 6 时 跳出循环</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td></tr></table></figure><h3 id="Break-和-Continue-标签"><a href="#Break-和-Continue-标签" class="headerlink" title="Break 和 Continue 标签"></a>Break 和 Continue 标签</h3><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">loop@ for (i in 1..100) &#123;</div><div class="line">    // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，我们可以用标签限制 break 或者continue：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">loop@ for (i in 1..100) &#123;</div><div class="line">    for (j in 1..100) &#123;</div><div class="line">        if (……) break@loop</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。</p><h3 id="标签处返回"><a href="#标签处返回" class="headerlink" title="标签处返回"></a>标签处返回</h3><p>Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;</div><div class="line">    ints.forEach &#123;</div><div class="line">        if (it == 0) return</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;</div><div class="line">    ints.forEach lit@ &#123;</div><div class="line">        if (it == 0) return@lit</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;</div><div class="line">    ints.forEach &#123;</div><div class="line">        if (it == 0) return@forEach</div><div class="line">        print(it)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;</div><div class="line">    ints.forEach(fun(value: Int) &#123;</div><div class="line">        if (value == 0) return</div><div class="line">        print(value)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当要返一个回值的时候，解析器优先选用标签限制的 return，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return@a 1</div></pre></td></tr></table></figure><p>意为”从标签 @a 返回 1”，而不是”返回一个标签标注的表达式 (@a 1)”。</p>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第1章 第一个Kotlin程序</title>
      <link href="/2018/05/10/helloKotlin-01/"/>
      <url>/2018/05/10/helloKotlin-01/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/HelloKotlin/blob/master/note/images/15.jpg?raw=true" alt=""></p><a id="more"></a><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。</p><p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><p>Kotlin 程序文件以  .kt 结尾，如：hello.kt 、app.kt。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package hello                      //  可选的包头</div><div class="line"> </div><div class="line">fun main(args: Array&lt;String&gt;) &#123;    // 包级可见的函数，接受一个字符串数组作为参数</div><div class="line">   println(&quot;Hello World!&quot;)         // 分号可以省略</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="为什么选择-Kotlin？"><a href="#为什么选择-Kotlin？" class="headerlink" title="为什么选择 Kotlin？"></a>为什么选择 Kotlin？</h3><ul><li>简洁: 大大减少样板代码的数量。</li><li>安全: 避免空指针异常等整个类的错误。</li><li>互操作性: 充分利用 JVM、Android 和浏览器的现有库。</li><li>工具友好: 可用任何 Java IDE 或者使用命令行构建。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3>]]></content>
      
      <categories>
          
          <category> Kotlin入坑小结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode刷题</title>
      <link href="/2018/04/14/crazyleetcode/"/>
      <url>/2018/04/14/crazyleetcode/</url>
      <content type="html"><![CDATA[<h2 id="LeetCode-刷题"><a href="#LeetCode-刷题" class="headerlink" title="LeetCode 刷题"></a>LeetCode 刷题</h2><ol><li>Two Sum</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>网易2019实习生招聘编程题集合</title>
      <link href="/2018/04/06/netease-intern-2019/"/>
      <url>/2018/04/06/netease-intern-2019/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shijiacheng/AlgorithmProblems/blob/master/images/netease-logo.jpeg?raw=true" alt=""></p><a id="more"></a><h3 id="1-牛牛找工作"><a href="#1-牛牛找工作" class="headerlink" title="1.牛牛找工作"></a>1.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/JobSearch.java" target="_blank" rel="external">牛牛找工作</a></h3><p>为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。</p><h3 id="2-被3整除"><a href="#2-被3整除" class="headerlink" title="2.被3整除"></a>2.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/DividedBy3.java" target="_blank" rel="external">被3整除</a></h3><p>小Q得到一个神奇的数列: 1, 12, 123,…12345678910,1234567891011…。<br>并且小Q对于能否被3整除这个性质很感兴趣。<br>小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。</p><h3 id="3-安置路灯"><a href="#3-安置路灯" class="headerlink" title="3.安置路灯"></a>3.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/PutLamps.java" target="_blank" rel="external">安置路灯</a></h3><p>小Q正在给一条长度为n的道路设计路灯安置方案。<br>为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。<br>小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。<br>小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。</p><h3 id="4-迷路的牛牛"><a href="#4-迷路的牛牛" class="headerlink" title="4.迷路的牛牛"></a>4.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/FindDirection.java" target="_blank" rel="external">迷路的牛牛</a></h3><p>牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。</p><h3 id="5-数对"><a href="#5-数对" class="headerlink" title="5.数对"></a>5.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/NumberPairs.java" target="_blank" rel="external">数对</a></h3><p>牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。<br>但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。<br>牛牛希望你能帮他计算一共有多少个可能的数对。</p><h3 id="6-矩形重叠"><a href="#6-矩形重叠" class="headerlink" title="6.矩形重叠"></a>6.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/RectanglesOverlap.java" target="_blank" rel="external">矩形重叠</a></h3><p>平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。<br>如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。<br>请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。</p><h3 id="7-牛牛的闹钟"><a href="#7-牛牛的闹钟" class="headerlink" title="7.牛牛的闹钟"></a>7.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/AlarmClock.java" target="_blank" rel="external">牛牛的闹钟</a></h3><p>牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床</p><h3 id="8-牛牛的背包问题"><a href="#8-牛牛的背包问题" class="headerlink" title="8.牛牛的背包问题"></a>8.<a href="https://github.com/shijiacheng/AlgorithmProblems/blob/master/src/com/shijc/coding/netease_intern_2019/BackpackSolution.java" target="_blank" rel="external">牛牛的背包问题</a></h3><p>牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。<br>牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。<br>牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。</p>]]></content>
      
      <categories>
          
          <category> 笔试算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易2019实习生招聘编程题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OkHttp实现全局过期token自动刷新</title>
      <link href="/2018/03/28/okhttp-interceptor/"/>
      <url>/2018/03/28/okhttp-interceptor/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一次面试遇到的一个问题，其实也是实际开发中很容易遇到的问题，特此记录一下。</p><p>当请求某个接口的时候，我们会在请求的header中携带token消息，但是发现token失效，接口请求报错，怎么马上刷新token，然后重复请求方才那个接口呢？这个过程应该说对用户来说是无感的。</p><a id="more"></a><p>这个过程用流程图可以这样表示：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/okhttp-interceptor.png" alt="自动更新token流程"></p><p>要实现上述需求的话，大家会如何实现呢？</p><h2 id="首先讲一下Token和Cookie吧"><a href="#首先讲一下Token和Cookie吧" class="headerlink" title="首先讲一下Token和Cookie吧"></a>首先讲一下Token和Cookie吧</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="- cookie"></a>- cookie</h3><p>cookie是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p><p>cookie的组成有：名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”\”)、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。</p><h3 id="token"><a href="#token" class="headerlink" title="- token"></a>- token</h3><p>token的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>通过拦截器，获取返回的数据</li><li>判断token是否过期</li><li>如果token过期则刷新token</li><li>使用最新的token，重新请求网络数据</li></ol><ul><li>自定义自动刷新token的拦截器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">import android.util.Log;</div><div class="line">import java.io.IOException;</div><div class="line">import okhttp3.Interceptor;</div><div class="line">import okhttp3.Request;</div><div class="line">import okhttp3.Response;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 自动刷新token的拦截器</div><div class="line"> * </div><div class="line"> * @author shijiacheng </div><div class="line"> * @version 1.0</div><div class="line"> */</div><div class="line"></div><div class="line">public class TokenInterceptor implements Interceptor &#123;</div><div class="line"></div><div class="line">    private static final String TAG = &quot;TokenInterceptor&quot;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">        Request request = chain.request();</div><div class="line">        Response response = chain.proceed(request);</div><div class="line">        Log.d(TAG, &quot;response.code=&quot; + response.code());</div><div class="line"></div><div class="line">        //根据和服务端的约定判断token过期</div><div class="line">        if (isTokenExpired(response)) &#123;</div><div class="line">            Log.d(TAG, &quot;自动刷新Token,然后重新请求数据&quot;);</div><div class="line">            //同步请求方式，获取最新的Token</div><div class="line">            String newToken = getNewToken();</div><div class="line">            //使用新的Token，创建新的请求</div><div class="line">            Request newRequest = chain.request()</div><div class="line">                    .newBuilder()</div><div class="line">                    .header(&quot;Authorization&quot;, &quot;Basic &quot; + newToken)</div><div class="line">                    .build();</div><div class="line">            //重新请求</div><div class="line">            return chain.proceed(newRequest);</div><div class="line">        &#125;</div><div class="line">        return response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据Response，判断Token是否失效</div><div class="line">     *</div><div class="line">     * @param response</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean isTokenExpired(Response response) &#123;</div><div class="line">        if (response.code() == 301) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 同步请求方式，获取最新的Token</div><div class="line">     *</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private String getNewToken() throws IOException &#123;</div><div class="line">        // 通过获取token的接口，同步请求接口</div><div class="line">        String newToken = &quot;&quot;;</div><div class="line">        return newToken;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配置下OkHttpUtils</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 初始化OkHttpUtils</div><div class="line"> */</div><div class="line">public OkHttpUtils()&#123;</div><div class="line">/**</div><div class="line"> * 配置OkHttpClient</div><div class="line"> */</div><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">.connectTimeout(15, TimeUnit.SECONDS)</div><div class="line">.readTimeout(3000, TimeUnit.SECONDS)</div><div class="line">.writeTimeout(3000, TimeUnit.SECONDS)</div><div class="line">//.cache(new Cache())</div><div class="line">//.addInterceptor(interceptor)//这里可以继续添加多种拦截器</div><div class="line">.addInterceptor(new TokenInterceptor())//添加获取token的拦截器</div><div class="line">.build();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Okhttp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android启动页解决攻略</title>
      <link href="/2017/09/09/android-splash-demo/"/>
      <url>/2017/09/09/android-splash-demo/</url>
      <content type="html"><![CDATA[<p>相信很多人都在网上查过关于启动白屏或者黑屏的问题。</p><p>一般的App应该是分为两种：</p><ul><li>有闪屏页或者启动页(SplashActivity)，页面大概会持续2到3秒</li><li>没有闪屏页和启动页，打开应用后会直接跳转到应用主界面</li></ul><a id="more"></a><p>不管有没有启动页，如果你不处理，你会发现当你点击桌面上那个icon图标的时候会先闪白屏或者黑屏一下，然后才会进入我们设定的页面。</p><p>但是我们手机上的常用应用，比如美团，今日头条，微信等，点击app icon的时候，其实感觉是一瞬间秒开的，没有白屏的过程，那么这是如何处理的呢？</p><h2 id="先说一说为什么会出现白屏或者黑屏吧！"><a href="#先说一说为什么会出现白屏或者黑屏吧！" class="headerlink" title="先说一说为什么会出现白屏或者黑屏吧！"></a>先说一说为什么会出现白屏或者黑屏吧！</h2><p>当打开一个Activity时，如果这个Activity所属的应用还没有在运行，系统会为这个Activity所属的应用创建一个进程，但进程的创建与初始化都需要时间，如果没有任何反应的话，如果程序初始化的时间很长，用户可能还以为没有点到相应的位置。但此时所启动的程序还没初始化完，既无法显示程序，又不能停在原处不做任何动作，这就有了Starting Window的概念，也可以称之为Preview Window。</p><p>Starting Window就是一个用于在应用程序进程创建并初始化成功前显示的临时窗口，拥有的Window Type是TYPE_APPLICATION_STARTING。在程序初始化完成前显示这个窗口，以告知用户系统已经知道了他要打开这个应用并做出了响应，当程序初始化完成后显示用户UI并移除这个窗口。</p><p>显示白屏或者黑屏，是由你的启动Activity或者Application来决定的。如果你使用的是Light主题，那么就可能出现白屏；如果你使用的是Black主题，那么就可能出现黑屏。当你设置Light或者Black主题时，Starting Window显示的就是你启动Activity的android:windowBackground属性，所以才会出现白屏或者黑屏的情况。</p><p>网上有很多教程，说是把主题的背景设为透明，这样子的确实没有白屏了，但是你会发现点击完app的icon之后，会有一小会的停顿，给用户一种卡顿的感觉，体验非常不好，不能为了实现功能而实现功能，软件开发用户体验至上！</p><hr><p>那么好的体验该如何开发呢？我们以实现一个今日头条app的启动页作为案例。</p><p>我们先来看一看常规情况下app启动的黑白屏。</p><p>为了让白屏或者黑屏明显的显示，在SplashActivity的onCreate方法中setContentView之前加入一个休眠1秒的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*还没有加载布局是睡眠1秒，确保黑屏或白屏效果明显*/</div><div class="line">try &#123;</div><div class="line">    Thread.sleep(1000);</div><div class="line">&#125; catch (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**闪屏页持续1s然后进入主页*/</div><div class="line">mHandler.postDelayed(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                Intent intent = new Intent(activity,AdsActivity.class);</div><div class="line">                startActivity(intent);</div><div class="line">                finish();</div><div class="line">                overridePendingTransition(R.anim.fade,R.anim.hold);</div><div class="line">            &#125;</div><div class="line">        &#125;, 1000);</div></pre></td></tr></table></figure><p>效果是：</p><p><img src="http://upload-images.jianshu.io/upload_images/1762953-8f5bdb31e61ceed3.gif?imageMogr2/auto-orient/strip" alt="没做任何处理的启动页"></p><h2 id="接下来我们来消灭白屏。"><a href="#接下来我们来消灭白屏。" class="headerlink" title="接下来我们来消灭白屏。"></a>接下来我们来消灭白屏。</h2><h3 id="第一步-消灭白屏"><a href="#第一步-消灭白屏" class="headerlink" title="第一步 消灭白屏"></a>第一步 消灭白屏</h3><p><strong>1.我们需要删除原来的闪屏页的布局activity_splash.xml，同时删除SplashActivity中setContentView(R.layout.activity_splash)方法。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    /*还没有加载布局是睡眠1秒，确保黑屏或白屏效果明显*/</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//    setContentView(R.layout.activity_splash);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>2.为了让闪屏页持续时间长一点，我们用handler模拟耗时操作，1秒后进行跳转。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mHandler.postDelayed(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">        //这块耗时操作可以进行初始化，或者网络请求等，1秒结束后跳转到广告页面</div><div class="line">            Intent intent = new Intent(activity,AdsActivity.class);</div><div class="line">            startActivity(intent);</div><div class="line">            finish();</div><div class="line">        &#125;</div><div class="line">    &#125;, 1000);</div></pre></td></tr></table></figure><p><strong>3.我们删除了闪屏页的布局文件，想法是将闪屏的背景作为Activity的主题背景，要做到这一点，首先要在 res/drawable创建一个XML drawable文件。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line"></div><div class="line">    &lt;item android:drawable=&quot;@color/white&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;item android:bottom=&quot;20dp&quot;&gt;</div><div class="line">        &lt;bitmap</div><div class="line">            android:gravity=&quot;bottom&quot;</div><div class="line">            android:src=&quot;@mipmap/icon_logo&quot; /&gt;</div><div class="line">    &lt;/item&gt;</div><div class="line"></div><div class="line">&lt;/layer-list&gt;</div></pre></td></tr></table></figure><p><strong>4.接下来在style.xml中创建一个闪屏页的主题，将创建的xml设置为window的背景。并且在AndroidManifest.xml中给SplashActivity配置style。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;AppTheme.Splash&quot; parent =&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt;</div><div class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/drawable_splash&lt;/item&gt;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.SplahActivity&quot;</div><div class="line">       android:theme=&quot;@style/AppTheme.Splash&quot;&gt;</div><div class="line">       &lt;intent-filter&gt;</div><div class="line">            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</div><div class="line"></div><div class="line">            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</div><div class="line">       &lt;/intent-filter&gt;</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure><p>这个时候运行程序，我们发现其实已经没有白屏了。</p><h3 id="第二步，我们实现广告加载页面"><a href="#第二步，我们实现广告加载页面" class="headerlink" title="第二步，我们实现广告加载页面"></a>第二步，我们实现广告加载页面</h3><p><strong> 1.广告页是一个倒计时的显示，布局中放入一个TextView来显示倒计时信息，放入一个ImageView来显示加载动画。点击跳过广告的时候显示加载动画。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;ImageView</div><div class="line">        android:id=&quot;@+id/iv_logo&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:src=&quot;@mipmap/icon_logo&quot;</div><div class="line">        android:layout_marginBottom=&quot;20dp&quot;</div><div class="line">        android:layout_alignParentBottom=&quot;true&quot;</div><div class="line">        android:layout_centerHorizontal=&quot;true&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:layout_marginBottom=&quot;20dp&quot;</div><div class="line">        android:layout_above=&quot;@+id/iv_logo&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:background=&quot;@color/colorAccent&quot;&gt;</div><div class="line">        </div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/tv_ads&quot;</div><div class="line">            android:layout_alignParentRight=&quot;true&quot;</div><div class="line">            android:layout_marginTop=&quot;20dp&quot;</div><div class="line">            android:layout_marginRight=&quot;20dp&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:text=&quot;跳过广告&quot;</div><div class="line">            android:textColor=&quot;@color/white&quot;</div><div class="line">            android:textSize=&quot;12sp&quot;</div><div class="line">            android:background=&quot;@drawable/bg_ad_text&quot;</div><div class="line">            android:padding=&quot;5dp&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;/RelativeLayout&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure><p><strong>2.页面实现中，我们定义一个CountDownTimer，这个类是Android SDK提供用来进行倒计时的。<code>CountDownTimer(long millisInFuture, long countDownInterval)</code>有两个参数，第一个是计时的总时长，第二个是间隔。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class AdsActivity extends Activity &#123;</div><div class="line">    private Activity activity;</div><div class="line">    private TextView tvAds;</div><div class="line">    private CountDownTimer countDownTimer;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_ads);</div><div class="line">        activity =this;</div><div class="line">        tvAds = (TextView) findViewById(R.id.tv_ads);</div><div class="line"></div><div class="line">        countDownTimer = new CountDownTimer(4000,1000) &#123;</div><div class="line">            @Override</div><div class="line">            public void onTick(long millisUntilFinished) &#123;</div><div class="line">                tvAds.setText(&quot;跳过广告&quot;+(millisUntilFinished/1000)+&quot;秒&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onFinish() &#123;</div><div class="line">                Intent intent = new Intent(activity,MainActivity.class);</div><div class="line">                startActivity(intent);</div><div class="line">                finish();</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 跳过广告</div><div class="line">         */</div><div class="line">        tvAds.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                countDownTimer.cancel();</div><div class="line">                Intent intent = new Intent(activity,MainActivity.class);</div><div class="line">                startActivity(intent);</div><div class="line">                finish();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="第三步，优化"><a href="#第三步，优化" class="headerlink" title="第三步，优化"></a>第三步，优化</h3><p><strong>1.我们运行起来，发现页面之间的跳转有些不美观，从右向左进入的动画感觉有些生硬。因此我们给页面之间加入转场动画。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#fade.xml 页面退出动画</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">       android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</div><div class="line">       android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;0.0&quot;</div><div class="line">       android:duration=&quot;400&quot; /&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#hold.xml 页面进入动画</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">       android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</div><div class="line">       android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;0&quot;</div><div class="line">       android:duration=&quot;400&quot; /&gt;</div></pre></td></tr></table></figure><p>在每个Intent跳转的地方加入转场效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(activity,AdsActivity.class);</div><div class="line">startActivity(intent);</div><div class="line">finish();</div><div class="line">overridePendingTransition(R.anim.fade,R.anim.hold);</div></pre></td></tr></table></figure><p>最终的效果是：</p><p><img src="http://upload-images.jianshu.io/upload_images/1762953-fdc554c31e89df64.gif?imageMogr2/auto-orient/strip" alt="消除黑白屏的启动页"></p><p><strong>有两点注意：</strong></p><ul><li><code>overridePendingTransition</code>方法要写在finish后面</li><li><code>overridePendingTransition</code>方法一定要写在主线程中，在子线程是没有作用的。</li></ul><p>源码地址：<a href="http://download.csdn.net/download/u012771445/9971093" target="_blank" rel="external">http://download.csdn.net/download/u012771445/9971093</a></p>]]></content>
      
      <categories>
          
          <category> Android基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Google VR教你打造全景图片展示</title>
      <link href="/2017/09/07/GoogleVRImage/"/>
      <url>/2017/09/07/GoogleVRImage/</url>
      <content type="html"><![CDATA[<blockquote><p>本文章主要参考Google VR中的文档，如果您能流利的读懂英文开发文档，可以去<a href="https://developers.google.cn/vr/android/" target="_blank" rel="external">官网</a>自行查看。</p></blockquote><a id="more"></a><h2 id="1-介绍VR-View"><a href="#1-介绍VR-View" class="headerlink" title="1.介绍VR View"></a>1.介绍VR View</h2><blockquote><p>VR view allows you to embed 360 degree VR media into websites on desktop and mobile, and native apps on Android and iOS. This technology is designed to enable developers of traditional apps to enhance the apps with immersive content.</p></blockquote><p>VR视图允许你将360度的VR媒体嵌入桌面和移动的网站，以及Android和iOS上的原生应用。这项技术旨在使传统应用程序的开发者能够通过沉浸式的内容来增强应用程序。</p><blockquote><p>VR view supports mono and stereo 360 images and videos. Images and video need to be stored in the equirectangular-panoramic (equirect-pano) format, which is a common format supported by many capture solutions.</p></blockquote><p>VR视图支持mono和立体图像和视频。图像和视频需要存储在equi矩形-全景(equirect - pano)格式中，这是许多捕获解决方案支持的公共格式。</p><p><strong>Image规格</strong></p><ul><li>VR查看图像可以保存为PNG，JPEG或GIF。Google建议使用JPEG改进压缩。  </li><li>为了获得最大的兼容性和性能，图像尺寸应该是2的倍数（例如，2048或4096）。</li><li>单个图像应为2：1纵横比（例如4096×2048）。  </li><li>立体图像应为1：1纵横比（例如4096×4096）。</li></ul><table><thead><tr><th style="text-align:center">mono单个图像</th><th style="text-align:center">stereo立体图像</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/vr/vr-1.jpg" width="300px" height="150px"></td><td style="text-align:center"><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/vr/vr-2.jpg" width="300px" height="150px"></td></tr></tbody></table><p>先来看看效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1762953-317ede75dbf01bef.gif?imageMogr2/auto-orient/strip" alt=""></p><h2 id="2-使用VrPanoramaView嵌入全景图像"><a href="#2-使用VrPanoramaView嵌入全景图像" class="headerlink" title="2.使用VrPanoramaView嵌入全景图像"></a>2.使用<code>VrPanoramaView</code>嵌入全景图像</h2><h3 id="1-build-gradle"><a href="#1-build-gradle" class="headerlink" title="1.build.gradle"></a>1.build.gradle</h3><p>在app下的<code>build.gradle</code>中添加panowidget库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.google.vr:sdk-panowidget:1.10.0&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-AndroiManifest-xml"><a href="#2-AndroiManifest-xml" class="headerlink" title="2.AndroiManifest.xml"></a>2.AndroiManifest.xml</h3><p>在使用VrPanoramaView的Acitivity的intent-filter节点添加过滤分类：<br><code>com.google.intent.category.CARDBOARD</code> ： 兼容Cardboard纸盒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.VrPanoramaActivity&quot;  &gt;  </div><div class="line">        &lt;intent-filter&gt;  </div><div class="line">            &lt;category android:name=&quot;com.google.intent.category.CARDBOARD&quot; /&gt;  </div><div class="line">        &lt;/intent-filter&gt;  </div><div class="line">    &lt;/activity&gt;</div></pre></td></tr></table></figure><h3 id="3-布局文件"><a href="#3-布局文件" class="headerlink" title="3.布局文件"></a>3.布局文件</h3><p>只需在布局中添加一个控件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;com.google.vr.sdk.widgets.pano.VrPanoramaView</div><div class="line">     android:id=&quot;@+id/pano_view&quot;</div><div class="line">     android:layout_margin=&quot;5dip&quot;</div><div class="line">     android:layout_width=&quot;match_parent&quot;</div><div class="line">     android:scrollbars=&quot;@null&quot;</div><div class="line">     android:layout_height=&quot;250dip&quot; /&gt;</div></pre></td></tr></table></figure><h3 id="4-加载全景图"><a href="#4-加载全景图" class="headerlink" title="4.加载全景图"></a>4.加载全景图</h3><p><strong>A.初始化控件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VrPanoramaView vrPanView = (VrPanoramaView) findViewById(R.id.vr_pan_view);</div></pre></td></tr></table></figure><p><strong>B.读取图片</strong></p><p>我们提前将一张选择好的全景图放在assets目录中，aa.jpg,将图片转为bitmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**获取assets中的图片，转为流**/</div><div class="line">InputStream open = null;</div><div class="line">try &#123;</div><div class="line">    open = getAssets().open(&quot;aa.jpg&quot;);</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line">Bitmap bitmap = BitmapFactory.decodeStream(open);</div></pre></td></tr></table></figure><p><strong>C.设置VrPanoramaView.Options</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/**VrPanoramaView.Options 设置**/</div><div class="line">VrPanoramaView.Options options = new VrPanoramaView.Options();</div><div class="line">options.inputType = VrPanoramaView.Options.TYPE_MONO;</div></pre></td></tr></table></figure><p>VrPanoramaView.Options有两种类型：</p><ul><li><p>TYPE_MONO 360度单图(2：1纵横比)<br>图像被预期以覆盖沿着其水平轴360度，而垂直范围是根据图像的宽高比来计算。例如，如果一个1000x250像素的图像，给出所述全景将覆盖360x90度与垂直范围是-45至+45度。</p></li><li><p>TYPE_STEREO_OVER_UNDER 立体图(1：1纵横比)<br>包含两个大小相等的投影 全景图垂直叠加。顶部图像被显示给左眼、底部图像被显示给右眼。图像将覆盖沿水平轴360度，而垂直范围是根据图像的宽高比来计算。例如，如果一个1000x500像素的图像中给出（即1000x250像素每个眼睛），全景将覆盖360x90度与垂直范围是-45至+45度。</p></li></ul><p><strong>D.加载全景图</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vrPanView.loadImageFromBitmap(bitmap, options);</div></pre></td></tr></table></figure><p><strong>E.设置加载监听VrPanoramaEventListener</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**设置加载图片监听**/</div><div class="line">vrPanView.setEventListener(new VrPanoramaEventListener() &#123;</div><div class="line">    /**</div><div class="line">    * 显示模式改变回调</div><div class="line">    * 1.默认</div><div class="line">    * 2.全屏模式</div><div class="line">    * 3.VR观看模式，即横屏分屏模式</div><div class="line">    */</div><div class="line">    @Override</div><div class="line">    public void onDisplayModeChanged(int newDisplayMode) &#123;</div><div class="line">        super.onDisplayModeChanged(newDisplayMode);</div><div class="line">        Log.d(TAG, &quot;onDisplayModeChanged()-&gt;newDisplayMode=&quot; + newDisplayMode);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    * 加载VR图片失败回调</div><div class="line">    */</div><div class="line">    @Override</div><div class="line">    public void onLoadError(String errorMessage) &#123;</div><div class="line">        super.onLoadError(errorMessage);</div><div class="line">        Log.d(TAG, &quot;onLoadError()-&gt;errorMessage=&quot; + errorMessage);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    * 加载VR图片成功回调</div><div class="line">    */</div><div class="line">    @Override</div><div class="line">    public void onLoadSuccess() &#123;</div><div class="line">        super.onLoadSuccess();</div><div class="line">        Log.d(TAG, &quot;onLoadSuccess-&gt;图片加载成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">    * 点击VR图片回调</div><div class="line">    */</div><div class="line">    @Override</div><div class="line">    public void onClick() &#123;</div><div class="line">        super.onClick();</div><div class="line">        Log.d(TAG, &quot;onClick()&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>F.在onPause、onResume、onDestroy中做出相应处理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onPause() &#123;</div><div class="line">    super.onPause();</div><div class="line">vrPanView.pauseRendering();//暂停3D渲染和跟踪</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onResume() &#123;</div><div class="line">    super.onResume();</div><div class="line">    vrPanView.resumeRendering();//恢复3D渲染和跟踪</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDestroy() &#123;</div><div class="line">    vrPanView.shutdown();//关闭渲染下并释放相关的内存</div><div class="line">    super.onDestroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>G.一些其他方法</strong></p><p>//是否隐藏左下角信息的按钮<br>vrPanView.setInfoButtonEnabled(boolean enabled);</p><p>//是否隐藏全屏按钮<br>vrPanView.setFullscreenButtonEnabled(boolean enabled);</p><p>未完，如果遇到新的继续添加</p><h3 id="最后附上完整代码："><a href="#最后附上完整代码：" class="headerlink" title="最后附上完整代码："></a>最后附上完整代码：</h3><p><a href="http://git.oschina.net/shijiacheng/codes/hk1uxjwvlimo8nrfda73t55" target="_blank" rel="external">VrPanoramaActivity.java</a></p>]]></content>
      
      <categories>
          
          <category> Android提高 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android控件 </tag>
            
            <tag> Google VR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>First RecyclerView (RecyclerView使用详解)</title>
      <link href="/2017/06/30/first-RecyclerView/"/>
      <url>/2017/06/30/first-RecyclerView/</url>
      <content type="html"><![CDATA[<h2 id="1-RecyclerView是什么？"><a href="#1-RecyclerView是什么？" class="headerlink" title="1. RecyclerView是什么？"></a>1. RecyclerView是什么？</h2><p>根据Google官方给出的说明：</p><blockquote><p>A flexible view for providing a limited window into a large data set.</p><p>能够在有限的窗口中展示大数据集合的灵活视图。</p></blockquote><p>所以我们能够理解为，RecyclerView的一个恰当的使用场景是：由于尺寸限制，用户的设备不能一次性展现所有条目，用户需要上下滚动以查看更多条目。滚出可见区域的条目将被回收，并在下一个条目可见的时候被复用。</p><a id="more"></a><p>对于减少内存开销和CPU的计算，缓存条目是一个非常有用的方法，因为这意味着我们不必每次都创建新的条目，从而减小内存开销和CPU的计算，而且还能够有效降低屏幕的卡顿，保证滑动的顺滑。</p><p>RecyclerView不关心视觉效果（visuals）</p><p>但是和ListView有什么区别呀？我们已经使用ListView很长一段时间了呀，它一样可以做到呀。从它的类名上看，RecyclerView代表的意义是，我只管Recycler View，也就是说RecyclerView只管回收与复用View，其他的开发者可以自己去设置。你想要另一个布局？插入另一个<code>LayoutManager</code>。你想要不同的动画吗？插入一个<code>ItemAnimator</code>，等等。可以看出其高度的解耦，给予你充分的定制自由（所以你才可以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果）。</p><h2 id="2-引入RecyclerView"><a href="#2-引入RecyclerView" class="headerlink" title="2. 引入RecyclerView"></a>2. 引入RecyclerView</h2><p><strong>RecyclerView 是Support Library的一部分</strong>。所以只需要在<code>app/build.gradle</code>中添加以下依赖，便能立即使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.android.support:recyclerview-v7:25.3.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在布局文件中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;android.support.v7.widget.RecyclerView</div><div class="line">        android:id=&quot;@+id/recycler_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</div></pre></td></tr></table></figure><p>然后在页面中引入<strong>RecyclerView</strong>即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);</div></pre></td></tr></table></figure><p>OK，从现在开始，让我们一步一步，开始了解它。</p><h2 id="3-使用RecyclerView"><a href="#3-使用RecyclerView" class="headerlink" title="3. 使用RecyclerView"></a>3. 使用RecyclerView</h2><p>下面的表格中就是使用RecyclerView来显示数据中用到的几个最重要的类，这些类都是RecyclerView的内部类，如果你想使用RecyclerView，需要做以下操作：</p><table><thead><tr><th>Class</th><th>功能</th></tr></thead><tbody><tr><td>Adapter</td><td>处理数据集合并负责绑定视图</td></tr><tr><td>ViewHolder</td><td>持有所有的用于绑定数据或者需要操作的View</td></tr><tr><td>LayoutManager</td><td>负责摆放视图等相关操作</td></tr><tr><td>ItemDecoration</td><td>负责绘制Item附近的分割线</td></tr><tr><td>ItemAnimator</td><td>为Item的一般操作添加动画效果，如，增删条目等</td></tr></tbody></table><p>我们可以从下图更直观的了解到<strong>RecyclerView</strong>的基本结构：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_8.png" alt="img"></p><p>接下来，我将要描述每个类或接口的内容以及如何使用它。</p><h3 id="3-1-RecyclerView-ViewHolder"><a href="#3-1-RecyclerView-ViewHolder" class="headerlink" title="3.1 RecyclerView.ViewHolder"></a>3.1 RecyclerView.ViewHolder</h3><p>ViewHolder的基本用法是用来存放View对象。Android团队很早之前就推荐使用“ViewHolder设计模式”，但是没有要求开发者在Adapter中必须使用<strong>ViewHolder模式</strong>。那么现在对于这种新型的<strong>RecyclerView.Adapter</strong>，我们必须实现并使用这种模式。</p><p>Google官方等了这么长时间才强制使用ViewHolder模式，这有点奇怪，但迟做总比不做好。如果您不了解ViewHolder模式，请查看一下Android training <a href="https://developer.android.google.cn/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">Hold View Objects in a View Holder</a>。另外网上有大量关于ListView优化的文章。面试重点。</p><p>有一件事是专门针对RecyclerView的。ViewHolder子类可以通过访问公共成员itemView来访问ViewHolder的根视图。所以不需要在ViewHolder子类中存储。</p><p>下面是示例的ViewHolder的代码，ViewHolder是示例Adapter的内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static class MyViewHolder extends RecyclerView.ViewHolder&#123;</div><div class="line"></div><div class="line">    TextView tv;</div><div class="line"></div><div class="line">    public MyViewHolder(View itemView) &#123;</div><div class="line">        super(itemView);</div><div class="line">        tv = (TextView) itemView.findViewById(R.id.tv);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-Adapter"><a href="#3-2-Adapter" class="headerlink" title="3.2 Adapter"></a>3.2 Adapter</h3><p>Adapter扮演着两个角色。一是，根据不同ViewType创建与之相应的的Item-Layout，二是，访问数据集合并将数据绑定到正确的View上。这就需要我们重写以下3个方法：</p><ul><li><code>public VH onCreateViewHolder(ViewGroup parent, int viewType)</code> 创建Item视图，并返回相应的ViewHolder</li><li><code>public void onBindViewHolder(VH holder, int position)</code> 绑定数据到正确的Item视图上。</li></ul><ul><li><code>public int getItemCount()</code> 返回该Adapter所持有的item数量</li></ul><p>示例代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">    MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context)</div><div class="line">            .inflate(R.layout.item_recycler_view,parent,false));</div><div class="line">    return holder;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onBindViewHolder(MyViewHolder holder, int position) &#123;</div><div class="line">    holder.tv.setText(mDatas.get(position));</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public int getItemCount() &#123;</div><div class="line">    return mDatas.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此，一个基本的<code>RecyclerView.Adapter</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecyclerAdapter.MyViewHolder&gt; &#123;</div><div class="line">    private Context context;</div><div class="line">    private List&lt;String&gt; mDatas;</div><div class="line"></div><div class="line">    public RecyclerAdapter(Context context, List&lt;String&gt; mDatas) &#123;</div><div class="line">        this.context = context;</div><div class="line">        this.mDatas = mDatas;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context)</div><div class="line">                .inflate(R.layout.item_recycler_view, parent, false));</div><div class="line">        return holder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(MyViewHolder holder, int position) &#123;</div><div class="line">        holder.tv.setText(mDatas.get(position));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return mDatas == null ? 0 : mDatas.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class MyViewHolder extends RecyclerView.ViewHolder &#123;</div><div class="line"></div><div class="line">        TextView tv;</div><div class="line"></div><div class="line">        public MyViewHolder(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            tv = (TextView) itemView.findViewById(R.id.tv);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-3-RecyclerView-LayoutManager"><a href="#3-3-RecyclerView-LayoutManager" class="headerlink" title="3.3 RecyclerView.LayoutManager"></a>3.3 RecyclerView.LayoutManager</h3><p>LayoutManager的职责是摆放Item的位置，并且负责决定何时回收和重用Item。它有一个默认的实现：LinearLayoutManager，它可以用于垂直和水平列表。</p><p>RecyclerView.LayoutManager是一个抽象类，RecyclerView为我们提供3个实现类：</p><ol><li>LinearLayoutManager 现行管理器，支持横向、纵向。</li><li>GridLayoutManager 网格布局管理器</li><li>StaggeredGridLayoutManager 瀑布流式布局管理器</li></ol><h4 id="3-3-1-LinearlayoutManager"><a href="#3-3-1-LinearlayoutManager" class="headerlink" title="3.3.1 LinearlayoutManager"></a>3.3.1 LinearlayoutManager</h4><p>LinearlayoutManager是LayoutManager的默认实现。你可以使用这个类来创建垂直或水平列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 设置RecyclerView布局方式为纵向布局</div><div class="line">LinearLayoutManager layoutManager = new LinearLayoutManager(context);</div><div class="line">layoutManager.setOrientation(LinearLayoutManager.VERTICAL);</div><div class="line">recyclerView.setLayoutManager(layoutManager);</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 设置RecyclerView布局方式为横向布局</div><div class="line">LinearLayoutManager layoutManager= new LinearLayoutManager(this);</div><div class="line">layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);</div><div class="line">recyclerView.setLayoutManager(layoutManager);</div></pre></td></tr></table></figure><p>运行程序，我们看到如下效果：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_2.jpg" style="width:60%"></p><p>我们发现和ListView有一些不同，没有分割线让这个列表看起来很不美观，给RecyclerView设置分割线这个我们在下一小节说明。</p><p>当然LinearlayoutManager中还有一些很实用的API：</p><ul><li><code>findFirstVisibleItemPosition()</code> 返回当前第一个可见Item的position</li><li><code>findFirstCompletelyVisibleItemPosition()</code> 返回当前第一个完全可见Item的position</li><li><code>findLastVisibleItemPosition()</code> 返回当前最后一个可见Item的position</li><li><code>findLastCompletelyVisibleItemPosition()</code> 返回当前最后一个完全可见Item的position</li></ul><h4 id="3-3-2-GridLayoutManager"><a href="#3-3-2-GridLayoutManager" class="headerlink" title="3.3.2 GridLayoutManager"></a>3.3.2 GridLayoutManager</h4><p>有两个构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Creates a vertical GridLayoutManager</div><div class="line">*</div><div class="line">* @param context Current context, will be used to access resources.</div><div class="line">* @param spanCount 设置行数，因为默认是纵向的</div><div class="line">*/</div><div class="line">public GridLayoutManager(Context context, int spanCount) &#123;</div><div class="line">    super(context);</div><div class="line">    setSpanCount(spanCount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* @param context Current context, will be used to access resources.</div><div class="line">* @param spanCount 设置行数或者列数，根据方向</div><div class="line">* @param orientation 布局方向 HORIZONTAL or VERTICAL.</div><div class="line">* @param reverseLayout 是否反向显示 When set to true, layouts from end to start.</div><div class="line">*/</div><div class="line">public GridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) &#123;</div><div class="line">    super(context, orientation, reverseLayout);</div><div class="line">    setSpanCount(spanCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们按如下代码设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 设置纵向的4列的表格布局</div><div class="line">GridLayoutManager layoutManager = new GridLayoutManager(this,4,GridLayoutManager.VERTICAL,false);</div><div class="line">recyclerView.setLayoutManager(layoutManager);</div><div class="line"></div><div class="line">// 设置横向的3行的表格布局</div><div class="line">GridLayoutManager layoutManager = new GridLayoutManager(this,3,GridLayoutManager.HORIZONTAL,false);</div><div class="line">recyclerView.setLayoutManager(layoutManager);</div></pre></td></tr></table></figure><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_3.jpg" style="width:60%"></p><h4 id="3-3-3-StaggeredGridLayoutManager"><a href="#3-3-3-StaggeredGridLayoutManager" class="headerlink" title="3.3.3 StaggeredGridLayoutManager"></a>3.3.3 StaggeredGridLayoutManager</h4><p>我们来看<strong>StaggeredGridLayoutManager</strong>的构造方法，只有一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* Creates a StaggeredGridLayoutManager with given parameters.</div><div class="line">*</div><div class="line">* @param spanCount   设置行数或者列数，根据方向，纵向就是列数，横向就是行数</div><div class="line">* @param orientation 方向</div><div class="line">*/</div><div class="line">public StaggeredGridLayoutManager(int spanCount, int orientation) &#123;&#125;</div></pre></td></tr></table></figure><p>因此我们这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 设置纵向的瀑布流布局</div><div class="line">StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL);</div><div class="line">recyclerView.setLayoutManager(layoutManager);</div></pre></td></tr></table></figure><hr><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_5.png" style="width:30%"></p><p>我们看效果和GridLayoutManager没有什么区别呢，那我们来小小的修改一下，你就可以看到它的强大。</p><p>我们给每个item的布局加入margin：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:layout_margin=&quot;5dp&quot;</div><div class="line">    android:background=&quot;@color/colorAccent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv&quot;</div><div class="line">        android:layout_width=&quot;100dp&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;</div><div class="line">        android:gravity=&quot;center&quot;</div><div class="line">        android:textColor=&quot;#fff&quot;</div><div class="line">        /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure><p>然后我们在适配器的<code>onBindViewHolder</code>方法中为我们的item设置个随机的高度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//贴上部分代码，其余的请看附件 </div><div class="line">    private List&lt;Integer&gt; mHeights;</div><div class="line"></div><div class="line">    public RecyclerAdapter(Context context, List&lt;String&gt; mDatas) &#123;</div><div class="line">        this.context = context;</div><div class="line">        this.mDatas = mDatas;</div><div class="line">        mHeights = new ArrayList&lt;Integer&gt;();</div><div class="line">        for (int i = 0; i &lt; mDatas.size(); i++) &#123;</div><div class="line">            mHeights.add((int) (100 + Math.random() * 300));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(MyViewHolder holder, final int position) &#123;</div><div class="line">        ViewGroup.LayoutParams lp = holder.tv.getLayoutParams();</div><div class="line">        lp.height = mHeights.get(position);</div><div class="line">        holder.tv.setLayoutParams(lp);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行，我们可以看到效果，是不是很炫！</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_6.png" style="width:30%"></p><h3 id="3-4-RecyclerView-ItemDecoration"><a href="#3-4-RecyclerView-ItemDecoration" class="headerlink" title="3.4 RecyclerView.ItemDecoration"></a>3.4 RecyclerView.ItemDecoration</h3><p>通过设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">recyclerView.addItemDecoration(new DividerDecoration(Context context, int orientation));</div></pre></td></tr></table></figure><p>来改变Item之间的偏移量或者对Item进行装饰。</p><p>例如，在上面的设置LinearlayoutManager之后加入以下代码，那么列表的效果就会发生改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 给纵向显示RecyclerView设置分割线</div><div class="line">recyclerView.addItemDecoration(new DividerItemDecoration(activity,DividerItemDecoration.VERTICAL));</div><div class="line">// 给横向显示RecyclerView设置分割线</div><div class="line">recyclerView.addItemDecoration(new DividerItemDecoration(activity,DividerItemDecoration.HORIZONTAL));</div></pre></td></tr></table></figure><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_1.jpg" style="width:60%"></p><p>当然，你也可以对RecyclerView设置多个<code>ItemDecoration</code>，列表展示的时候会遍历所有的<code>ItemDecoration</code>并调用里面的绘制方法，对Item进行装饰。</p><p><code>RecyclerView.ItemDecoration</code>是一个抽象类，可以通过重写以下三个方法，来实现Item之间的偏移量或者装饰效果：</p><ul><li><code>public void onDraw(Canvas c, RecyclerView parent)</code> 装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡</li><li><code>public void onDrawOver(Canvas c, RecyclerView parent)</code> 装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上</li><li><code>public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent)</code> 与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。</li></ul><p>当然了，如果我们使用GridLayoutManager后，对于分割线，前面的DividerItemDecoration就不适用了，主要是因为它在绘制的时候，比如水平线，针对每个child的取值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final int left = parent.getPaddingLeft();</div><div class="line">final int right = parent.getWidth() - parent.getPaddingRight();</div></pre></td></tr></table></figure><p>因为每个Item一行，这样是没问题的。而GridLayoutManager时，一行有多个childItem，这样就多次绘制了，并且GridLayoutManager时，Item如果为最后一列（则右边无间隔线）或者为最后一行（底部无分割线）。</p><p>按照上述的方法，我们可以自定义一个<code>DividerGridItemDecoration</code>。由于代码篇幅过长，我们在附件中给出。我们给GridLayoutManager设置<code>DividerGridItemDecoration</code>，运行效果如下：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_4.png" style="width:30%"></p><h3 id="3-5-RecyclerView-ItemAnimator"><a href="#3-5-RecyclerView-ItemAnimator" class="headerlink" title="3.5 RecyclerView.ItemAnimator"></a>3.5 RecyclerView.ItemAnimator</h3><p>ItemAnimator能够帮助Item实现独立的动画。</p><p>ItemAnimator作触发于以下三种事件：</p><ol><li>某条数据被插入到数据集合中</li><li>从数据集合中移除某条数据</li><li>更改数据集合中的某条数据</li></ol><p>幸运的是，在Android中默认实现了一个<code>DefaultItemAnimator</code>，我们可以通过以下代码为Item增加动画效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">recyclerView.setItemAnimator(new DefaultItemAnimator());</div></pre></td></tr></table></figure><p>在之前的版本中，当时据集合发生改变时，我们通过调用<code>.notifyDataSetChanged()</code>，来刷新列表，因为这样做会触发列表的重绘，所以并不会出现任何动画效果，因此需要调用一些以<code>notifyItem*()</code>作为前缀的特殊方法，比如：</p><ul><li><code>public final void notifyItemInserted(int position)</code> 向指定位置插入Item</li><li><code>public final void notifyItemRemoved(int position)</code> 移除指定位置Item</li><li><code>public final void notifyItemChanged(int position)</code> 更新指定位置Item</li></ul><p>下面我们使用<code>DefaultItemAnimator</code>来展示一下动画效果，修改代码如下：</p><p>在Activity中添加两个按钮add和remove负责动态插入和移除item</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">btnAdd.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                adapter.addData(1);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">btnRemove.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                adapter.removeData(2);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure><p>在Adapter中添加两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void addData(int position) &#123;</div><div class="line">        mDatas.add(position, &quot;Insert&quot;);</div><div class="line">        mHeights.add( (int) (100 + Math.random() * 300));</div><div class="line">        notifyItemInserted(position);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void removeData(int position) &#123;</div><div class="line">        mDatas.remove(position);</div><div class="line">        notifyItemRemoved(position);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://img.blog.csdn.net/20170630193658617?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjc3MTQ0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><h3 id="3-6-Listeners"><a href="#3-6-Listeners" class="headerlink" title="3.6 Listeners"></a>3.6 Listeners</h3><p>很遗憾，<code>RecyclerView</code>并没有像<code>ListView</code>那样提供以下两个Item的点击监听事件</p><ul><li><code>public void setOnItemClickListener(@Nullable OnItemClickListener listener)</code> Item点击事件监听</li><li><code>public void setOnItemLongClickListener(OnItemLongClickListener listener)</code> Item长按事件监听</li></ul><p>但是这并不能阻拦我们的脚步，我可以定义这样的两个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface OnItemClickLitener &#123;</div><div class="line">    void onItemClick(View view, int position);</div><div class="line">    void onItemLongClick(View view, int position);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private OnItemClickLitener litener;</div><div class="line"></div><div class="line">public void setLitener(OnItemClickLitener litener) &#123;</div><div class="line">    this.litener = litener;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在onBindViewHolder方法中给需要响应点击事件的控件设置监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 如果设置了回调，则响应点击事件</div><div class="line">holder.itemView.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        if (litener != null) &#123;</div><div class="line">            litener.onItemClick(v, position);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public boolean onLongClick(View v) &#123;</div><div class="line">        if (litener != null) &#123;</div><div class="line">            litener.onItemLongClick(v, position);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>在Activity中设置这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">adapter.setLitener(new RecyclerAdapter.OnItemClickLitener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onItemClick(View view, int position) &#123;</div><div class="line">        Toast.makeText(activity,&quot;第&quot;+position+&quot;项被点击了&quot;,Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onItemLongClick(View view, int position) &#123;</div><div class="line">        Toast.makeText(activity,&quot;第&quot;+position+&quot;项被长按了&quot;,Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>效果如图：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/android/recyclerview/rv_demo_7.jpg" style="width:60%"></p><blockquote><p>源码地址：<a href="http://download.csdn.net/detail/u012771445/9885640" target="_blank" rel="external">http://download.csdn.net/detail/u012771445/9885640</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android控件 </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第9章 列表生成式</title>
      <link href="/2017/06/23/python-junior-9/"/>
      <url>/2017/06/23/python-junior-9/</url>
      <content type="html"><![CDATA[<h2 id="生成列表"><a href="#生成列表" class="headerlink" title="生成列表"></a>生成列表</h2><p>要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; range(1, 11)</div><div class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div></pre></td></tr></table></figure><p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？</p><a id="more"></a><p>方法一是循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = []</div><div class="line">&gt;&gt;&gt; for x in range(1, 11):</div><div class="line">...    L.append(x * x)</div><div class="line">... </div><div class="line">&gt;&gt;&gt; L</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure><p>这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。</p><p>写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, …, 99x100]</p><p><strong>提示：</strong>range(1, 100, 2) 可以生成list [1, 3, 5, 7, 9,…]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#Listcomprehensions1.py</div><div class="line">print [x*(x+1) for x in range(1, 100, 2)]</div></pre></td></tr></table></figure><h2 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h2><p>使用<strong>for循环</strong>的迭代不仅可以迭代普通的list，还可以迭代dict。</p><p>假设有如下的dict：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</div></pre></td></tr></table></figure><p>完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()]</div><div class="line">print &apos;&lt;table&gt;&apos;</div><div class="line">print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;</div><div class="line">print &apos;\n&apos;.join(tds)</div><div class="line">print &apos;&lt;/table&gt;&apos;</div></pre></td></tr></table></figure><p><strong>注：</strong>字符串可以通过 % 进行格式化，用指定的参数替代<strong>%s</strong>。字符串的join()方法可以把一个 list 拼接成一个字符串。</p><p>把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;table border=&quot;1&quot;&gt;</div><div class="line">&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;</div><div class="line">&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;</div><div class="line">&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;</div><div class="line">&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure><p><a href="http://img.mukewang.com/540fcd2a0001ff4600940104.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/540fcd2a0001ff4600940104.jpg" alt="img"></a></p><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><p>在生成的表格中，对于没有及格的同学，请把分数标记为红色。</p><p><strong>提示：</strong>红色可以用 <td style="color:red"> 实现。</td></p><p><a href="http://img.mukewang.com/540fcd610001be6800940104.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/540fcd610001be6800940104.jpg" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#Listcomprehensions2.py</div><div class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</div><div class="line">def generate_tr(name, score):</div><div class="line">    if score &lt; 60:</div><div class="line">        return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score)</div><div class="line">    return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score)</div><div class="line"></div><div class="line">tds = [generate_tr(name,score) for name, score in d.iteritems()]</div><div class="line">print &apos;&lt;table border=&quot;1&quot;&gt;&apos;</div><div class="line">print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;</div><div class="line">print &apos;\n&apos;.join(tds)</div><div class="line">print &apos;&lt;/table&gt;&apos;</div></pre></td></tr></table></figure><h2 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h2><p>列表生成式的 <strong>for 循环后面还可以加上 if 判断</strong>。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</div><div class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></pre></td></tr></table></figure><p>如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</div><div class="line">[4, 16, 36, 64, 100]</div></pre></td></tr></table></figure><p>有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。</p><h3 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h3><p>请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。</p><p><strong>提示：</strong></p><ol><li>isinstance(x, str) 可以判断变量 x 是否是字符串；</li><li>字符串的 upper() 方法可以返回大写的字母。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#Listcomprehensions3.py</div><div class="line">def uperList(L):</div><div class="line">    return [s.upper() for s in L if isinstance(s, str)]</div><div class="line">print uperList([&apos;Hello&apos;, &apos;world&apos;, 101])</div></pre></td></tr></table></figure><h2 id="多层表达式"><a href="#多层表达式" class="headerlink" title="多层表达式"></a>多层表达式</h2><p>for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。</p><p>对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;]</div><div class="line">[&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;]</div></pre></td></tr></table></figure><p>翻译成循环代码就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">L = []</div><div class="line">for m in &apos;ABC&apos;:</div><div class="line">    for n in &apos;123&apos;:</div><div class="line">        L.append(m + n)</div></pre></td></tr></table></figure><h3 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h3><p>利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#Listcomprehensions4.py</div><div class="line">L= [100*a+10*b+c for a in range(1,10) for b in range(10) for c in range(10) if a == c]</div><div class="line">print L</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第8章 迭代</title>
      <link href="/2017/06/23/python-junior-8/"/>
      <url>/2017/06/23/python-junior-8/</url>
      <content type="html"><![CDATA[<h2 id="什么是迭代"><a href="#什么是迭代" class="headerlink" title="什么是迭代"></a>什么是迭代</h2><p>在Python中，如果给定一个<strong>list</strong>或<strong>tuple</strong>，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。</p><a id="more"></a><p>在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i=0; i&lt;list.length; i++) &#123;</div><div class="line">    n = list[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出，Python的for循环抽象程度要高于Java的for循环。</p><p><strong>因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。</strong></p><p>因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：</div><div class="line">1. 有序集合：list，tuple，str和unicode；</div><div class="line">2. 无序集合：set</div><div class="line">3. 无序集合并且具有 key-value 对：dict</div></pre></td></tr></table></figure><p>而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。</p><p>迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>请用for循环迭代数列 1-100 并打印出7的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#Iteration1.py</div><div class="line">L = range(1,101)</div><div class="line">for num in L:</div><div class="line">    if num %7==0:</div><div class="line">        print num</div></pre></td></tr></table></figure><h2 id="索引迭代"><a href="#索引迭代" class="headerlink" title="索引迭代"></a>索引迭代</h2><p>Python中，<strong>迭代永远是取出元素本身，而非元素的索引。</strong></p><p>对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？</p><p>方法是使用 <strong>enumerate() 函数</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div><div class="line">&gt;&gt;&gt; for index, name in enumerate(L):</div><div class="line">...     print index, &apos;-&apos;, name</div><div class="line">... </div><div class="line">0 - Adam</div><div class="line">1 - Lisa</div><div class="line">2 - Bart</div><div class="line">3 - Paul</div></pre></td></tr></table></figure><p>使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div></pre></td></tr></table></figure><p>变成了类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)]</div></pre></td></tr></table></figure><p>因此，迭代的每一个元素实际上是一个tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for t in enumerate(L):</div><div class="line">    index = t[0]</div><div class="line">    name = t[1]</div><div class="line">    print index, &apos;-&apos;, name</div></pre></td></tr></table></figure><p>如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for index, name in enumerate(L):</div><div class="line">    print index, &apos;-&apos;, name</div></pre></td></tr></table></figure><p>这样不但代码更简单，而且还少了两条赋值语句。</p><p>可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。</p><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><p>zip()函数可以把两个 list 变成一个 list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])</div><div class="line">[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)]</div></pre></td></tr></table></figure><p>在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。</p><p><strong>提示：</strong>考虑使用zip()函数和range()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Iteration2.py</div><div class="line">L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div><div class="line">for index,name in zip(range(1,len(L)+1),L):</div><div class="line">    print index,&apos;-&apos;,name</div></pre></td></tr></table></figure><h2 id="迭代dict的value"><a href="#迭代dict的value" class="headerlink" title="迭代dict的value"></a>迭代dict的value</h2><p>我们已经了解了<strong>dict对象</strong>本身就是可<strong>迭代对象</strong>，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。</p><p>如果我们希望迭代 dict 对象的value，应该怎么做？</p><p>dict 对象有一个 <strong>values() 方法</strong>，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</div><div class="line">print d.values()</div><div class="line"># [85, 95, 59]</div><div class="line">for v in d.values():</div><div class="line">    print v</div><div class="line"># 85</div><div class="line"># 95</div><div class="line"># 59</div></pre></td></tr></table></figure><p>如果仔细阅读Python的文档，还可以发现，dict除了<strong>values()</strong>方法外，还有一个<strong>itervalues() </strong>方法，用<strong>itervalues()</strong> 方法替代 <strong>values()</strong> 方法，迭代效果完全一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</div><div class="line">print d.itervalues()</div><div class="line"># &lt;dictionary-valueiterator object at 0x106adbb50&gt;</div><div class="line">for v in d.itervalues():</div><div class="line">    print v</div><div class="line"># 85</div><div class="line"># 95</div><div class="line"># 59</div></pre></td></tr></table></figure><p><strong>那这两个方法有何不同之处呢？</strong></p><ol><li><strong>values()</strong> 方法实际上把一个 dict 转换成了包含 value 的list。</li><li>但是 <strong>itervalues()</strong> 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。</li><li>打印 itervalues() 发现它返回一个 <dictionary-valueiterator> 对象，这说明在Python中，<strong>for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等</strong>，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。</dictionary-valueiterator></li></ol><p><strong>如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。</strong></p><h3 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h3><p>给定一个dict：</p><p>d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 }</p><p>请计算所有同学的平均分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#Iteration3.py</div><div class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;</div><div class="line">sum = 0.0</div><div class="line">for i in d.itervalues():</div><div class="line">    sum = sum +i</div><div class="line">print sum/len(d)</div></pre></td></tr></table></figure><h2 id="迭代dict的key和value"><a href="#迭代dict的key和value" class="headerlink" title="迭代dict的key和value"></a>迭代dict的key和value</h2><p>我们了解了如何<strong>迭代 dict</strong> 的<strong>key</strong>和<strong>value</strong>，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。</p><p>首先，我们看看 dict 对象的 <strong>items()</strong> 方法返回的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</div><div class="line">&gt;&gt;&gt; print d.items()</div><div class="line">[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)]</div></pre></td></tr></table></figure><p>可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for key, value in d.items():</div><div class="line">...     print key, &apos;:&apos;, value</div><div class="line">... </div><div class="line">Lisa : 85</div><div class="line">Adam : 95</div><div class="line">Bart : 59</div></pre></td></tr></table></figure><p>和 values() 有一个 itervalues() 类似， <strong>items() </strong>也有一个对应的 <strong>iteritems()</strong>，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。</p><h3 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h3><p>请根据dict：</p><p>d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 }</p><p>打印出 name : score，最后再打印出平均分 average : score。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#Iteration4.py</div><div class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;</div><div class="line">sum = 0.0</div><div class="line">for name,score in d.iteritems():</div><div class="line">    print name,&apos;:&apos;,score</div><div class="line">    sum = sum + score</div><div class="line">print &quot;average&quot;,&apos;:&apos;,sum/len(d)</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第7章 切片</title>
      <link href="/2017/06/22/python-junior-7/"/>
      <url>/2017/06/22/python-junior-7/</url>
      <content type="html"><![CDATA[<h2 id="对list进行切片"><a href="#对list进行切片" class="headerlink" title="对list进行切片"></a>对list进行切片</h2><p>取一个list的部分元素是非常常见的操作。比如，一个list如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div></pre></td></tr></table></figure><p>取前3个元素，应该怎么做？</p><a id="more"></a><p>笨办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; [L[0], L[1], L[2]]</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>之所以是笨办法是因为扩展一下，取前N个元素就没辙了。</p><p>取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = []</div><div class="line">&gt;&gt;&gt; n = 3</div><div class="line">&gt;&gt;&gt; for i in range(n):</div><div class="line">...     r.append(L[i])</div><div class="line">... </div><div class="line">&gt;&gt;&gt; r</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</p><p>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[0:3]</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p><p>如果第一个索引是0，还可以省略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[:3]</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>也可以从索引1开始，取出2个元素出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[1:3]</div><div class="line">[&apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>只用一个<strong>:</strong>，表示从头到尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[:]</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div></pre></td></tr></table></figure><p>因此，L[:]实际上复制出了一个新list。</p><p>切片操作还可以指定第三个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[::2]</div><div class="line">[&apos;Adam&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。</p><p>把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>range()函数可以创建一个数列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; range(1, 101)</div><div class="line">[1, 2, 3, ..., 100]</div></pre></td></tr></table></figure><p>请利用切片，取出：</p><ol><li>前10个数；</li><li>3的倍数；</li><li>不大于50的5的倍数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#SliceQues1.py</div><div class="line">L = range(1,101)</div><div class="line">print L[:10]</div><div class="line">print L[2::3]</div><div class="line">print L[4:51:5]</div></pre></td></tr></table></figure><h2 id="倒序切片"><a href="#倒序切片" class="headerlink" title="倒序切片"></a>倒序切片</h2><p>对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; L[-2:]</div><div class="line">[&apos;Bart&apos;, &apos;Paul&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; L[:-2]</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; L[-3:-1]</div><div class="line">[&apos;Lisa&apos;, &apos;Bart&apos;]</div><div class="line"></div><div class="line">&gt;&gt;&gt; L[-4:-1:2]</div><div class="line">[&apos;Adam&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。</p><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><p>利用倒序切片对 1 - 100 的数列取出：</p><p>* 最后10个数；</p><p>* 最后10个5的倍数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#SliceQues2.py</div><div class="line">L = range(1,101)</div><div class="line">print L[-10:]</div><div class="line">print L[4::5][-10:]</div></pre></td></tr></table></figure><h2 id="对字符串切片"><a href="#对字符串切片" class="headerlink" title="对字符串切片"></a>对字符串切片</h2><p>字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</div><div class="line">&apos;ABC&apos;</div><div class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[-3:]</div><div class="line">&apos;EFG&apos;</div><div class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</div><div class="line">&apos;ACEG&apos;</div></pre></td></tr></table></figure><p>在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p><h3 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h3><p>字符串有个方法 upper() 可以把字符变成大写字母：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;abc&apos;.upper()</div><div class="line">&apos;ABC&apos;</div></pre></td></tr></table></figure><p>但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SliceQues3.py</div><div class="line">def upperFirstChar(s):</div><div class="line">    return s[:1].upper()+s[1:]</div><div class="line"></div><div class="line">print upperFirstChar(&apos;hello&apos;)</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第6章 函数</title>
      <link href="/2017/06/22/python-junior-6/"/>
      <url>/2017/06/22/python-junior-6/</url>
      <content type="html"><![CDATA[<h2 id="Python之什么是函数"><a href="#Python之什么是函数" class="headerlink" title="Python之什么是函数"></a>Python之什么是函数</h2><p>我们知道圆的面积计算公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">S = πr²</div></pre></td></tr></table></figure><p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">r1 = 12.34</div><div class="line">r2 = 9.08</div><div class="line">r3 = 73.1</div><div class="line">s1 = 3.14 * r1 * r1</div><div class="line">s2 = 3.14 * r2 * r2</div><div class="line">s3 = 3.14 * r3 * r3</div></pre></td></tr></table></figure><p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 <em> x </em> x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p><a id="more"></a><p>有了函数，我们就不再每次写s = 3.14 <em> x </em> x，而是写成更有意义的函数调用 <code>s = area_of_circle(x)</code>，而函数 area_of_circle 本身只需要写一次，就可以多次调用。</p><p><strong>抽象</strong>是数学中非常常见的概念。举个例子：</p><p>计算数列的和，比如：<strong>1 + 2 + 3 + … + 100</strong>，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100</div><div class="line">∑n</div><div class="line">n=1</div></pre></td></tr></table></figure><p>这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。</p><p>而且，这种抽象记法是可扩展的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100</div><div class="line">∑(n²+1)</div><div class="line">n=1</div></pre></td></tr></table></figure><p>还原成加法运算就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)</div></pre></td></tr></table></figure><p>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p><p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p><p>Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p><h2 id="Python之调用函数"><a href="#Python之调用函数" class="headerlink" title="Python之调用函数"></a>Python之调用函数</h2><p>Python内置了很多有用的函数，我们可以直接调用。</p><p>要调用一个函数，需要知道<strong>函数</strong>的<strong>名称</strong>和<strong>参数</strong>，比如求绝对值的函数 abs，它接收一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">可以直接从Python的官方网站查看文档：</div><div class="line">http://docs.python.org/2/library/functions.html#abs</div></pre></td></tr></table></figure><p>也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。</p><p>调用 <strong>abs </strong>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs(100)</div><div class="line">100</div><div class="line">&gt;&gt;&gt; abs(-20)</div><div class="line">20</div><div class="line">&gt;&gt;&gt; abs(12.34)</div><div class="line">12.34</div></pre></td></tr></table></figure><p>调用函数的时候，如果传入的参数数量不对，会报<strong>TypeError</strong>的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs(1, 2)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: abs() takes exactly one argument (2 given)</div></pre></td></tr></table></figure><p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报<strong>TypeError</strong>的错误，并且给出错误信息：str是错误的参数类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; abs(&apos;a&apos;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: bad operand type for abs(): &apos;str&apos;</div></pre></td></tr></table></figure><p>而比较函数 cmp(x, y) 就需要两个参数，如果 <strong>x&lt;y</strong>，返回<strong> -1</strong>，如果<strong> x==y</strong>，返回 <strong>0</strong>，如果 <strong>x&gt;y</strong>，返回 <strong>1</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; cmp(1, 2)</div><div class="line">-1</div><div class="line">&gt;&gt;&gt; cmp(2, 1)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; cmp(3, 3)</div><div class="line">0</div></pre></td></tr></table></figure><p>Python内置的常用函数还包括数据类型转换函数，比如   int()函数可以把其他数据类型转换为整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; int(&apos;123&apos;)</div><div class="line">123</div><div class="line">&gt;&gt;&gt; int(12.34)</div><div class="line">12</div></pre></td></tr></table></figure><p>str()函数把其他类型转换成 str：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; str(123)</div><div class="line">&apos;123&apos;</div><div class="line">&gt;&gt;&gt; str(1.23)</div><div class="line">&apos;1.23&apos;</div></pre></td></tr></table></figure><h2 id="Python之编写函数"><a href="#Python之编写函数" class="headerlink" title="Python之编写函数"></a>Python之编写函数</h2><p>在Python中，定义一个函数要使用<strong>def </strong>语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 <strong>return</strong> 语句返回。</p><p>我们以自定义一个求绝对值的 my_abs 函数为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def my_abs(x):</div><div class="line">    if x &gt;= 0:</div><div class="line">        return x</div><div class="line">    else:</div><div class="line">        return -x</div></pre></td></tr></table></figure><p><strong>请注意</strong>，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p><p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。</p><p>return None可以简写为return。</p><h2 id="Python函数之返回多值"><a href="#Python函数之返回多值" class="headerlink" title="Python函数之返回多值"></a>Python函数之返回多值</h2><p>函数可以返回多个值吗？答案是肯定的。</p><p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p><p><strong># math</strong>包提供了<strong>sin()</strong>和 <strong>cos()</strong>函数，我们先用import引用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">def move(x, y, step, angle):</div><div class="line">    nx = x + step * math.cos(angle)</div><div class="line">    ny = y - step * math.sin(angle)</div><div class="line">    return nx, ny</div></pre></td></tr></table></figure><p>这样我们就可以同时获得返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print x, y</div><div class="line">151.961524227 70.0</div></pre></td></tr></table></figure><p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</div><div class="line">&gt;&gt;&gt; print r</div><div class="line">(151.96152422706632, 70.0)</div></pre></td></tr></table></figure><p>用print打印返回结果，原来返回值是一个<strong>tuple</strong>！</p><p>但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，<strong>Python的函数</strong>返回多值其实就是<strong>返回一个tuple</strong>，但写起来更方便。</p><h2 id="Python之递归函数"><a href="#Python之递归函数" class="headerlink" title="Python之递归函数"></a>Python之递归函数</h2><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><p>举个例子，我们来计算阶乘 <strong>n! = 1 * 2 <em> 3 </em> … * n</strong>，用函数 <strong>fact(n)</strong>表示，可以看出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n</div></pre></td></tr></table></figure><p>所以，<strong>fact(n)</strong>可以表示为 <strong>n * fact(n-1)</strong>，只有n=1时需要特殊处理。</p><p>于是，fact(n)用递归的方式写出来就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def fact(n):</div><div class="line">    if n==1:</div><div class="line">        return 1</div><div class="line">    return n * fact(n - 1)</div></pre></td></tr></table></figure><p>上面就是一个递归函数。可以试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; fact(1)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; fact(5)</div><div class="line">120</div><div class="line">&gt;&gt;&gt; fact(100)</div><div class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L</div></pre></td></tr></table></figure><p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">===&gt; fact(5)</div><div class="line">===&gt; 5 * fact(4)</div><div class="line">===&gt; 5 * (4 * fact(3))</div><div class="line">===&gt; 5 * (4 * (3 * fact(2)))</div><div class="line">===&gt; 5 * (4 * (3 * (2 * fact(1))))</div><div class="line">===&gt; 5 * (4 * (3 * (2 * 1)))</div><div class="line">===&gt; 5 * (4 * (3 * 2))</div><div class="line">===&gt; 5 * (4 * 6)</div><div class="line">===&gt; 5 * 24</div><div class="line">===&gt; 120</div></pre></td></tr></table></figure><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p><p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>汉诺塔 (<a href="http://baike.baidu.com/view/191666.htm" target="_blank" rel="external">http://baike.baidu.com/view/191666.htm</a>) 的移动也可以看做是递归函数。</p><p>我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为：</p><p>如果a只有一个圆盘，可以直接移动到c；</p><p>如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。</p><p>请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤：</p><p>move(n, a, b, c)</p><p>例如，输入 move(2, ‘A’, ‘B’, ‘C’)，打印出：</p><p>A –&gt; B<br>A –&gt; C<br>B –&gt; C</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#HanoiTower.py</div><div class="line">def move(n,a,b,c):</div><div class="line">    if n == 1:</div><div class="line">        print a,&quot;--&gt;&quot;,c</div><div class="line">        return</div><div class="line">    move(n-1, a, c, b)</div><div class="line">    print a,&quot;--&gt;&quot;,c</div><div class="line">    move(n-1, b, c, a)</div><div class="line">    </div><div class="line">move(4, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);</div></pre></td></tr></table></figure><h2 id="Python之定义默认参数"><a href="#Python之定义默认参数" class="headerlink" title="Python之定义默认参数"></a>Python之定义默认参数</h2><p>定义函数的时候，还可以有默认参数。</p><p>例如Python自带的 <strong>int()</strong> 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; int(&apos;123&apos;)</div><div class="line">123</div><div class="line">&gt;&gt;&gt; int(&apos;123&apos;, 8)</div><div class="line">83</div></pre></td></tr></table></figure><p>int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。</p><p>可见，<strong>函数的默认参数的作用是简化调用</strong>，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。</p><p>我们来定义一个计算 x 的N次方的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def power(x, n):</div><div class="line">    s = 1</div><div class="line">    while n &gt; 0:</div><div class="line">        n = n - 1</div><div class="line">        s = s * x</div><div class="line">    return s</div></pre></td></tr></table></figure><p>假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def power(x, n=2):</div><div class="line">    s = 1</div><div class="line">    while n &gt; 0:</div><div class="line">        n = n - 1</div><div class="line">        s = s * x</div><div class="line">    return s</div></pre></td></tr></table></figure><p>这样一来，计算平方就不需要传入两个参数了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; power(5)</div><div class="line">25</div></pre></td></tr></table></figure><p>由于函数的参数按从左到右的顺序匹配，所以<strong>默认参数只能定义在必需参数的后面：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># OK:</div><div class="line">def fn1(a, b=1, c=2):</div><div class="line">    pass</div><div class="line"># Error:</div><div class="line">def fn2(a=1, b):</div><div class="line">    pass</div></pre></td></tr></table></figure><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h3><p>请定义一个 greet() 函数，它包含一个默认参数，如果没有传入，打印 ‘Hello, world.’，如果传入，打印 ‘Hello, xxx.’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#VariableParams.py</div><div class="line">def greet(a=&apos;world&apos;):</div><div class="line">    print &apos;Hello,&apos;+a+&apos;.&apos;</div><div class="line">    </div><div class="line">greet()</div><div class="line">greet(&apos;python&apos;)</div></pre></td></tr></table></figure><h2 id="Python之定义可变参数"><a href="#Python之定义可变参数" class="headerlink" title="Python之定义可变参数"></a>Python之定义可变参数</h2><p>如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def fn(*args):</div><div class="line">    print args</div></pre></td></tr></table></figure><p>可变参数的名字前面有个 <strong>* </strong>号，我们可以传入0个、1个或多个参数给可变参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; fn()</div><div class="line">()</div><div class="line">&gt;&gt;&gt; fn(&apos;a&apos;)</div><div class="line">(&apos;a&apos;,)</div><div class="line">&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;)</div><div class="line">(&apos;a&apos;, &apos;b&apos;)</div><div class="line">&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</div><div class="line">(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</div></pre></td></tr></table></figure><p>可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p><p>定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def average(*args):</div><div class="line">    ...</div></pre></td></tr></table></figure><p>这样，在调用的时候，可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; average()</div><div class="line">0</div><div class="line">&gt;&gt;&gt; average(1, 2)</div><div class="line">1.5</div><div class="line">&gt;&gt;&gt; average(1, 2, 2, 3, 4)</div><div class="line">2.4</div></pre></td></tr></table></figure><h3 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h3><p>请编写接受可变参数的 average() 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#VariableParams.py</div><div class="line">def average(*args):</div><div class="line">    if len(args)==0:</div><div class="line">        print 0</div><div class="line">    else:</div><div class="line">        sum = 0.0</div><div class="line">        for s in args:</div><div class="line">            sum = sum+s</div><div class="line">        print sum/len(args)</div><div class="line">    </div><div class="line">average()</div><div class="line">average(1,2)</div><div class="line">average(1,2,3,4)</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第5章 Dict和Set类型</title>
      <link href="/2017/06/18/python-junior-5/"/>
      <url>/2017/06/18/python-junior-5/</url>
      <content type="html"><![CDATA[<h2 id="Python之什么是dict"><a href="#Python之什么是dict" class="headerlink" title="Python之什么是dict"></a>Python之什么是dict</h2><p>我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>或者考试的成绩列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[95, 85, 59]</div></pre></td></tr></table></figure><p>但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。</p><a id="more"></a><p>如果把名字和分数关联起来，组成类似的查找表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;Adam&apos; ==&gt; 95</div><div class="line">&apos;Lisa&apos; ==&gt; 85</div><div class="line">&apos;Bart&apos; ==&gt; 59</div></pre></td></tr></table></figure><p>给定一个名字，就可以直接查到分数。</p><p>Python的 dict 就是专门干这件事的。用 <strong>dict </strong>表示<strong>“名字”-“成绩”</strong>的查找表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = &#123;</div><div class="line">    &apos;Adam&apos;: 95,</div><div class="line">    &apos;Lisa&apos;: 85,</div><div class="line">    &apos;Bart&apos;: 59</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们把<strong>名字称为key</strong>，对应的<strong>成绩称为value</strong>，dict就是通过 <strong>key</strong> 来查找 <strong>value</strong>。</p><p>花括号 {} 表示这是一个dict，然后按照<strong>key: value</strong>, 写出来即可。最后一个 key: value 的逗号可以省略。</p><p>由于dict也是集合，len() 函数可以计算任意集合的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; len(d)</div><div class="line">3</div></pre></td></tr></table></figure><p><strong>注意:</strong> 一个 key-value 算一个，因此，dict大小为3。</p><h2 id="Python之访问dict"><a href="#Python之访问dict" class="headerlink" title="Python之访问dict"></a>Python之访问dict</h2><p>我们已经能创建一个dict，用于表示名字和成绩的对应关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = &#123;</div><div class="line">    &apos;Adam&apos;: 95,</div><div class="line">    &apos;Lisa&apos;: 85,</div><div class="line">    &apos;Bart&apos;: 59</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么，如何根据名字来查找对应的成绩呢？</p><p>可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，<strong>list 必须使用索引返回对应的元素，而dict使用key：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print d[&apos;Adam&apos;]</div><div class="line">95</div><div class="line">&gt;&gt;&gt; print d[&apos;Paul&apos;]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;index.py&quot;, line 11, in &lt;module&gt;</div><div class="line">    print d[&apos;Paul&apos;]</div><div class="line">KeyError: &apos;Paul&apos;</div></pre></td></tr></table></figure><p><strong>注意:</strong> 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。</p><p>要避免 KeyError 发生，有两个办法：</p><p><strong>一是先判断一下 key 是否存在，用 in 操作符：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if &apos;Paul&apos; in d:</div><div class="line">    print d[&apos;Paul&apos;]</div></pre></td></tr></table></figure><p>如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。</p><p><strong>二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print d.get(&apos;Bart&apos;)</div><div class="line">59</div><div class="line">&gt;&gt;&gt; print d.get(&apos;Paul&apos;)</div><div class="line">None</div></pre></td></tr></table></figure><h2 id="Python中dict的特点"><a href="#Python中dict的特点" class="headerlink" title="Python中dict的特点"></a>Python中dict的特点</h2><p><strong>dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样</strong>。而list的查找速度随着元素增加而逐渐下降。</p><p>不过dict的查找速度快不是没有代价的，<strong>dict的缺点是占用内存大，还会浪费很多内容</strong>，list正好相反，占用内存小，但是查找速度慢。</p><p>由于dict是按 key 查找，所以，在一个dict中，key不能重复。</p><p><strong>dict的第二个特点就是存储的key-value序对是没有顺序的！</strong>这和list不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = &#123;</div><div class="line">    &apos;Adam&apos;: 95,</div><div class="line">    &apos;Lisa&apos;: 85,</div><div class="line">    &apos;Bart&apos;: 59</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当我们试图打印这个dict时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print d</div><div class="line">&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125;</div></pre></td></tr></table></figure><p>打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是<strong>无序</strong>的，不能用dict存储有序的集合。</p><p><strong>dict的第三个特点是作为 key 的元素必须不可变</strong>，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。</p><p>可以试试用list作为key时会报什么样的错误。</p><p>不可变这个限制仅作用于key，value是否可变无所谓：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &apos;123&apos;: [1, 2, 3],  # key 是 str，value是list</div><div class="line">    123: &apos;123&apos;,  # key 是 int，value 是 str</div><div class="line">    (&apos;a&apos;, &apos;b&apos;): True  # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最常用的key还是字符串，因为用起来最方便。</p><h2 id="Python更新dict"><a href="#Python更新dict" class="headerlink" title="Python更新dict"></a>Python更新dict</h2><p>dict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = &#123;</div><div class="line">    &apos;Adam&apos;: 95,</div><div class="line">    &apos;Lisa&apos;: 85,</div><div class="line">    &apos;Bart&apos;: 59</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要把新同学’Paul’的成绩 72 加进去，用赋值语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d[&apos;Paul&apos;] = 72</div></pre></td></tr></table></figure><p>再看看dict的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print d</div><div class="line">&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125;</div></pre></td></tr></table></figure><p>如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d[&apos;Bart&apos;] = 60</div><div class="line">&gt;&gt;&gt; print d</div><div class="line">&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 60&#125;</div></pre></td></tr></table></figure><h2 id="Python之-遍历dict"><a href="#Python之-遍历dict" class="headerlink" title="Python之 遍历dict"></a>Python之 遍历dict</h2><p>由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。</p><p>直接使用for循环可以遍历 dict 的 key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</div><div class="line">&gt;&gt;&gt; for key in d:</div><div class="line">...     print key</div><div class="line">... </div><div class="line">Lisa</div><div class="line">Adam</div><div class="line">Bart</div></pre></td></tr></table></figure><p>由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。</p><h2 id="Python中什么是set"><a href="#Python中什么是set" class="headerlink" title="Python中什么是set"></a>Python中什么是set</h2><p><strong>dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。</strong></p><p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。</p><p><strong>set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。</strong></p><p>创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])</div></pre></td></tr></table></figure><p>可以查看 set 的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print s</div><div class="line">set([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])</div></pre></td></tr></table></figure><p><strong>请注意</strong>，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是<strong>无序</strong>的。</p><p>因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;C&apos;])</div><div class="line">&gt;&gt;&gt; print s</div><div class="line">set([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])</div><div class="line">&gt;&gt;&gt; len(s)</div><div class="line">3</div></pre></td></tr></table></figure><p>结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。</p><h2 id="Python之-访问set"><a href="#Python之-访问set" class="headerlink" title="Python之 访问set"></a>Python之 访问set</h2><p>由于<strong>set存储的是无序集合</strong>，所以我们没法通过索引来访问。</p><p>访问 set中的某个元素实际上就是判断一个元素是否在set中。</p><p>例如，存储了班里同学名字的set：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;])</div></pre></td></tr></table></figure><p>我们可以用 in 操作符判断：</p><p>Bart是该班的同学吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Bart&apos; in s</div><div class="line">True</div></pre></td></tr></table></figure><p>Bill是该班的同学吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;Bill&apos; in s</div><div class="line">False</div></pre></td></tr></table></figure><p>bart是该班的同学吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &apos;bart&apos; in s</div><div class="line">False</div></pre></td></tr></table></figure><p>看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。</p><h2 id="Python之-set的特点"><a href="#Python之-set的特点" class="headerlink" title="Python之 set的特点"></a>Python之 set的特点</h2><p><strong>set的内部结构和dict很像，唯一区别是不存储value</strong>，因此，判断一个元素是否在set中速度很快。</p><p><strong>set存储的元素和dict的key类似，必须是不变对象</strong>，因此，任何可变对象是不能放入set中的。</p><p>最后，set存储的元素也是没有顺序的。</p><p>set的这些特点，可以应用在哪些地方呢？</p><p>星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。</p><p>假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？</p><p>可以用<strong> if 语句</strong>判断，但这样做非常繁琐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = &apos;???&apos; # 用户输入的字符串</div><div class="line">if x!= &apos;MON&apos; and x!= &apos;TUE&apos; and x!= &apos;WED&apos; ... and x!= &apos;SUN&apos;:</div><div class="line">    print &apos;input error&apos;</div><div class="line">else:</div><div class="line">    print &apos;input ok&apos;</div></pre></td></tr></table></figure><p><strong>注意：</strong>if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。</p><p>如果事先创建好一个set，包含’MON’ ~ ‘SUN’：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weekdays = set([&apos;MON&apos;, &apos;TUE&apos;, &apos;WED&apos;, &apos;THU&apos;, &apos;FRI&apos;, &apos;SAT&apos;, &apos;SUN&apos;])</div></pre></td></tr></table></figure><p>再判断输入是否有效，只需要判断该字符串是否在set中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = &apos;???&apos; # 用户输入的字符串</div><div class="line">if x in weekdays:</div><div class="line">    print &apos;input ok&apos;</div><div class="line">else:</div><div class="line">    print &apos;input error&apos;</div></pre></td></tr></table></figure><p>这样一来，代码就简单多了。</p><h2 id="Python之-遍历set"><a href="#Python之-遍历set" class="headerlink" title="Python之 遍历set"></a>Python之 遍历set</h2><p>由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。</p><p>直接使用 for 循环可以遍历 set 的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;])</div><div class="line">&gt;&gt;&gt; for name in s:</div><div class="line">...     print name</div><div class="line">... </div><div class="line">Lisa</div><div class="line">Adam</div><div class="line">Bart</div></pre></td></tr></table></figure><p><strong>注意: </strong>观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。</p><h2 id="Python之-更新set"><a href="#Python之-更新set" class="headerlink" title="Python之 更新set"></a>Python之 更新set</h2><p>由于<strong>set存储的是一组不重复的无序元素</strong>，因此，更新set主要做两件事：</p><p><strong>一是把新的元素添加到set中，二是把已有元素从set中删除。</strong></p><p>添加元素时，用set的add()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([1, 2, 3])</div><div class="line">&gt;&gt;&gt; s.add(4)</div><div class="line">&gt;&gt;&gt; print s</div><div class="line">set([1, 2, 3, 4])</div></pre></td></tr></table></figure><p>如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([1, 2, 3])</div><div class="line">&gt;&gt;&gt; s.add(3)</div><div class="line">&gt;&gt;&gt; print s</div><div class="line">set([1, 2, 3])</div></pre></td></tr></table></figure><p>删除set中的元素时，用set的remove()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([1, 2, 3, 4])</div><div class="line">&gt;&gt;&gt; s.remove(4)</div><div class="line">&gt;&gt;&gt; print s</div><div class="line">set([1, 2, 3])</div></pre></td></tr></table></figure><p>如果删除的元素不存在set中，remove()会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = set([1, 2, 3])</div><div class="line">&gt;&gt;&gt; s.remove(4)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">KeyError: 4</div></pre></td></tr></table></figure><p>所以用add()可以直接添加，而remove()前需要判断。</p>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第4章 条件判断和循环</title>
      <link href="/2017/06/18/python-junior-4/"/>
      <url>/2017/06/18/python-junior-4/</url>
      <content type="html"><![CDATA[<h2 id="Python之if语句"><a href="#Python之if语句" class="headerlink" title="Python之if语句"></a>Python之if语句</h2><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p><p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">age = 20</div><div class="line">if age &gt;= 18:</div><div class="line">    print &apos;your age is&apos;, age</div><div class="line">    print &apos;adult&apos;</div><div class="line">print &apos;END&apos;</div></pre></td></tr></table></figure><a id="more"></a><p><strong>注意: </strong>Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。</p><p>缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。</p><p><strong>注意</strong>: if 语句后接表达式，然后用<code>:</code>表示代码块开始。</p><p>如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; age = 20</div><div class="line">&gt;&gt;&gt; if age &gt;= 18:</div><div class="line">...     print &apos;your age is&apos;, age</div><div class="line">...     print &apos;adult&apos;</div><div class="line">...</div><div class="line">your age is 20</div><div class="line">adult</div></pre></td></tr></table></figure><h2 id="Python之-if-else"><a href="#Python之-if-else" class="headerlink" title="Python之 if-else"></a>Python之 if-else</h2><p>当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    print &apos;adult&apos;</div></pre></td></tr></table></figure><p>如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，方法是再写一个 if:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if age &lt; 18:</div><div class="line">    print &apos;teenager&apos;</div></pre></td></tr></table></figure><p>或者用 not 运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if not age &gt;= 18:</div><div class="line">    print &apos;teenager&apos;</div></pre></td></tr></table></figure><p>这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if … else … 语句把它们统一起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    print &apos;adult&apos;</div><div class="line">else:</div><div class="line">    print &apos;teenager&apos;</div></pre></td></tr></table></figure><p>利用 if … else … 语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。</p><p><strong>注意:</strong> else 后面有个“:”。</p><h2 id="Python之-if-elif-else"><a href="#Python之-if-elif-else" class="headerlink" title="Python之 if-elif-else"></a>Python之 if-elif-else</h2><p>有的时候，一个 if … else … 还不够用。比如，根据年龄的划分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">条件1：18岁或以上：adult</div><div class="line">条件2：6岁或以上：teenager</div><div class="line">条件3：6岁以下：kid</div></pre></td></tr></table></figure><p>我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    print &apos;adult&apos;</div><div class="line">else:</div><div class="line">    if age &gt;= 6:</div><div class="line">        print &apos;teenager&apos;</div><div class="line">    else:</div><div class="line">        print &apos;kid&apos;</div></pre></td></tr></table></figure><p>这样写出来，我们就得到了一个两层嵌套的 if … else … 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    print &apos;adult&apos;</div><div class="line">else:</div><div class="line">    if age &gt;= 6:</div><div class="line">        print &apos;teenager&apos;</div><div class="line">    else:</div><div class="line">        if age &gt;= 3:</div><div class="line">            print &apos;kid&apos;</div><div class="line">        else:</div><div class="line">            print &apos;baby&apos;</div></pre></td></tr></table></figure><p>这种缩进只会越来越多，代码也会越来越难看。</p><p>要避免嵌套结构的 if … else …，我们可以用 if … 多个elif … else … 的结构，一次写完所有的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if age &gt;= 18:</div><div class="line">    print &apos;adult&apos;</div><div class="line">elif age &gt;= 6:</div><div class="line">    print &apos;teenager&apos;</div><div class="line">elif age &gt;= 3:</div><div class="line">    print &apos;kid&apos;</div><div class="line">else:</div><div class="line">    print &apos;baby&apos;</div></pre></td></tr></table></figure><p>elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。</p><p><strong>特别注意: </strong>这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。</p><h2 id="Python之-for循环"><a href="#Python之-for循环" class="headerlink" title="Python之 for循环"></a>Python之 for循环</h2><p>list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div><div class="line">print L[0]</div><div class="line">print L[1]</div><div class="line">print L[2]</div></pre></td></tr></table></figure><p>如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。</p><p>这时，循环就派上用场了。</p><p>Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div><div class="line">for name in L:</div><div class="line">    print name</div></pre></td></tr></table></figure><p><strong>注意: </strong> name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。</p><p>这样一来，遍历一个list或tuple就非常容易了。</p><h2 id="Python之-while循环"><a href="#Python之-while循环" class="headerlink" title="Python之 while循环"></a>Python之 while循环</h2><p>和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。</p><p>比如要从 0 开始打印不大于 N 的整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">N = 10</div><div class="line">x = 0</div><div class="line">while x &lt; N:</div><div class="line">    print x</div><div class="line">    x = x + 1</div></pre></td></tr></table></figure><p>while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。</p><p>在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。</p><p>如果没有这一个语句，<strong>while循环在判断 x &lt; N 时总是为True</strong>，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。</p><h2 id="Python之-break退出循环"><a href="#Python之-break退出循环" class="headerlink" title="Python之 break退出循环"></a>Python之 break退出循环</h2><p>用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。</p><p>比如计算1至100的整数和，我们用while来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sum = 0</div><div class="line">x = 1</div><div class="line">while True:</div><div class="line">    sum = sum + x</div><div class="line">    x = x + 1</div><div class="line">    if x &gt; 100:</div><div class="line">        break</div><div class="line">print sum</div></pre></td></tr></table></figure><p>while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。</p><h2 id="Python之-continue继续循环"><a href="#Python之-continue继续循环" class="headerlink" title="Python之 continue继续循环"></a>Python之 continue继续循环</h2><p>在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。</p><p>假设我们已经写好了利用for循环计算平均分的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">L = [75, 98, 59, 81, 66, 43, 69, 85]</div><div class="line">sum = 0.0</div><div class="line">n = 0</div><div class="line">for x in L:</div><div class="line">    sum = sum + x</div><div class="line">    n = n + 1</div><div class="line">print sum / n</div></pre></td></tr></table></figure><p>现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for x in L:</div><div class="line">    if x &lt; 60:</div><div class="line">        continue</div><div class="line">    sum = sum + x</div><div class="line">    n = n + 1</div></pre></td></tr></table></figure><h2 id="Python之-多重循环"><a href="#Python之-多重循环" class="headerlink" title="Python之 多重循环"></a>Python之 多重循环</h2><p>在循环内部，还可以嵌套循环，我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]:</div><div class="line">    for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]:</div><div class="line">        print x + y</div></pre></td></tr></table></figure><p>x 每循环一次，y 就会循环 3 次，这样，我们可以打印出一个全排列：</p><p>A1<br>A2<br>A3<br>B1<br>B2<br>B3<br>C1<br>C2<br>C3</p>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第3章 List和Tuple类型</title>
      <link href="/2017/06/18/python-junior-3/"/>
      <url>/2017/06/18/python-junior-3/</url>
      <content type="html"><![CDATA[<h2 id="Python创建list"><a href="#Python创建list" class="headerlink" title="Python创建list"></a>Python创建list</h2><p>Python内置的一种数据类型是列表：<code>list</code>。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。</p><a id="more"></a><p>构造list非常简单，按照上面的代码，直接用<code>[ ]</code>把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div><div class="line">&gt;&gt;&gt; classmates # 打印classmates变量的内容</div><div class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</div></pre></td></tr></table></figure><p>由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Michael&apos;, 100, True]</div></pre></td></tr></table></figure><p>一个元素也没有的list，就是空list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; empty_list = []</div></pre></td></tr></table></figure><h2 id="Python按照索引访问list"><a href="#Python按照索引访问list" class="headerlink" title="Python按照索引访问list"></a>Python按照索引访问list</h2><p>由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>通过索引来获取list中的指定元素。</p><p><strong>需要特别注意的是</strong>，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。</p><p>因此，要打印第一名同学的名字，用 L[0]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print L[0]</div><div class="line">Adam</div></pre></td></tr></table></figure><p>要打印第二名同学的名字，用 L[1]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print L[1]</div><div class="line">Lisa</div></pre></td></tr></table></figure><p>要打印第三名同学的名字，用 L[2]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print L[2]</div><div class="line">Bart</div></pre></td></tr></table></figure><p>要打印第四名同学的名字，用 L[3]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print L[3]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">IndexError: list index out of range</div></pre></td></tr></table></figure><p>报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。</p><p>所以，使用索引时，<strong>千万注意不要越界</strong>。</p><h2 id="Python之倒序访问list"><a href="#Python之倒序访问list" class="headerlink" title="Python之倒序访问list"></a>Python之倒序访问list</h2><p>我们还是用一个list按分数从高到低表示出班里的3个同学：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>我们可以用 -1 这个索引来表示最后一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print L[-1]</div><div class="line">Bart</div></pre></td></tr></table></figure><p>类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print L[-2]</div><div class="line">Lisa</div><div class="line">&gt;&gt;&gt; print L[-3]</div><div class="line">Adam</div><div class="line">&gt;&gt;&gt; print L[-4]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">IndexError: list index out of range</div></pre></td></tr></table></figure><p>L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。</p><p>使用倒序索引时，也要注意<strong>不要越界</strong>。</p><h2 id="Python之添加新元素"><a href="#Python之添加新元素" class="headerlink" title="Python之添加新元素"></a>Python之添加新元素</h2><p>现在，班里有3名同学：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？</p><p>第一个办法是用 list 的<code>append()</code>方法，把新同学追加到 list 的末尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div><div class="line">&gt;&gt;&gt; L.append(&apos;Paul&apos;)</div><div class="line">&gt;&gt;&gt; print L</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div></pre></td></tr></table></figure><p><strong>append()</strong>总是把新的元素添加到 list 的尾部。</p><p>如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？</p><p>方法是用list的<code>insert()</code>方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div><div class="line">&gt;&gt;&gt; L.insert(0, &apos;Paul&apos;)</div><div class="line">&gt;&gt;&gt; print L</div><div class="line">[&apos;Paul&apos;, &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p><strong>L.insert(0, ‘Paul’)</strong> 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。</p><h2 id="Python从list删除元素"><a href="#Python从list删除元素" class="headerlink" title="Python从list删除元素"></a>Python从list删除元素</h2><p>我们怎么把Paul 从现有的list中删除呢？</p><p>如果Paul同学排在最后一个，我们可以用list的<code>pop()</code>方法删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</div><div class="line">&gt;&gt;&gt; L.pop()</div><div class="line">&apos;Paul&apos;</div><div class="line">&gt;&gt;&gt; print L</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p><strong>pop()</strong>方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。</p><p>如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用<code>pop(2)</code>把Paul删掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L.pop(2)</div><div class="line">&apos;Paul&apos;</div><div class="line">&gt;&gt;&gt; print L</div><div class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><h2 id="Python中替换元素"><a href="#Python中替换元素" class="headerlink" title="Python中替换元素"></a>Python中替换元素</h2><p>假设现在班里仍然是3名同学：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</div></pre></td></tr></table></figure><p>现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。</p><p>另一个办法是直接用Paul把Bart给替换掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[2] = &apos;Paul&apos;</div><div class="line">&gt;&gt;&gt; print L</div><div class="line">L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;]</div></pre></td></tr></table></figure><p>对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。</p><p>由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[-1] = &apos;Paul&apos;</div></pre></td></tr></table></figure><h2 id="Python之创建tuple"><a href="#Python之创建tuple" class="headerlink" title="Python之创建tuple"></a>Python之创建tuple</h2><p>tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。</p><p>同样是表示班里同学的名称，用tuple表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;)</div></pre></td></tr></table></figure><p>创建tuple和创建list唯一不同之处是用<code>( )</code>替代了<code>[ ]</code>。</p><p>现在，这个<code>t</code>就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。</p><p>获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t[0] = &apos;Paul&apos;</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: &apos;tuple&apos; object does not support item assignment</div></pre></td></tr></table></figure><h2 id="Python之创建单元素tuple"><a href="#Python之创建单元素tuple" class="headerlink" title="Python之创建单元素tuple"></a>Python之创建单元素tuple</h2><p>tuple和list一样，可以包含 0 个、1个和任意多个元素。</p><p>包含多个元素的 tuple，前面我们已经创建过了。</p><p>包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = ()</div><div class="line">&gt;&gt;&gt; print t</div><div class="line">()</div></pre></td></tr></table></figure><p>创建包含1个元素的 tuple 呢？来试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1)</div><div class="line">&gt;&gt;&gt; print t</div><div class="line">1</div></pre></td></tr></table></figure><p>好像哪里不对！t 不是 tuple ，而是整数1。</p><p>因为<code>()</code>既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。</p><p>正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1,)</div><div class="line">&gt;&gt;&gt; print t</div><div class="line">(1,)</div></pre></td></tr></table></figure><p>Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。</p><p>多元素 tuple 加不加这个额外的“,”效果是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (1, 2, 3,)</div><div class="line">&gt;&gt;&gt; print t</div><div class="line">(1, 2, 3)</div></pre></td></tr></table></figure><h2 id="Python之“可变”的tuple"><a href="#Python之“可变”的tuple" class="headerlink" title="Python之“可变”的tuple"></a>Python之“可变”的tuple</h2><p>前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</div></pre></td></tr></table></figure><p><strong>注意</strong>到 t 有 3 个元素：<strong>‘a’，’b’</strong>和一个list：<strong>[‘A’, ‘B’]</strong>。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L = t[2]</div></pre></td></tr></table></figure><p>然后，我们把list的两个元素改一改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; L[0] = &apos;X&apos;</div><div class="line">&gt;&gt;&gt; L[1] = &apos;Y&apos;</div></pre></td></tr></table></figure><p>再看看tuple的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print t</div><div class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</div></pre></td></tr></table></figure><p>不是说tuple一旦定义后就不可变了吗？怎么现在又变了？</p><p>别急，我们先看看定义的时候tuple包含的3个元素：</p><p><a href="http://img.mukewang.com/540538d400010f4603500260.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/540538d400010f4603500260.jpg" alt="img"></a></p><p>当我们把list的元素<strong>‘A’和’B’</strong>修改为<strong>‘X’和’Y’</strong>后，tuple变为：</p><p><a href="http://img.mukewang.com/540538e9000110c003500260.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/540538e9000110c003500260.jpg" alt="img"></a></p><p>表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。</p><p>tuple一开始指向的list并没有改成别的list，所以，tuple所谓的<strong>“不变”</strong>是说，tuple的每个元素，指向永远不变。即<strong>指向’a’，就不能改成指向’b’</strong>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><p>理解了<strong>“指向不变”</strong>后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第2章 Python中变量和数据类型</title>
      <link href="/2017/06/17/python-junior-2/"/>
      <url>/2017/06/17/python-junior-2/</url>
      <content type="html"><![CDATA[<h2 id="Python中数据类型"><a href="#Python中数据类型" class="headerlink" title="Python中数据类型"></a>Python中数据类型</h2><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><a id="more"></a><p><strong>一、整数</strong></p><p>Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：<code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p><p><strong>二、浮点数</strong></p><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是<strong>1.23e9</strong>，或者<strong>12.3e8</strong>，0.000012可以写成<strong>1.2e-5</strong>，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><p><strong>三、字符串</strong></p><p>字符串是以<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来的任意文本，比如<strong>‘abc’</strong>，<strong>“xyz”</strong>等等。请注意，<strong>‘’</strong>或<strong>“”</strong>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a，b，c</code>这3个字符。</p><p><strong>四、布尔值</strong></p><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来。</p><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p><p><code>and</code>运算是与运算，只有所有都为 True，and运算结果才是 True。</p><p><code>or</code>运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p><p><code>not</code>运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p><p><strong>五、空值</strong></p><p>空值是Python里一个特殊的值，用<code>None</code>表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p><h2 id="Python之print语句"><a href="#Python之print语句" class="headerlink" title="Python之print语句"></a>Python之print语句</h2><p><strong>print</strong>语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print &apos;hello, world&apos;</div></pre></td></tr></table></figure><p>print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print &apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;</div><div class="line">The quick brown fox jumps over the lazy dog</div></pre></td></tr></table></figure><p>print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：</p><p><a href="http://img.mukewang.com/54055502000179c205060086.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/54055502000179c205060086.jpg" alt="img"></a></p><p>print也可以打印整数，或者计算结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print 300</div><div class="line">300    #运行结果</div><div class="line">&gt;&gt;&gt; print 100 + 200</div><div class="line">300    #运行结果</div></pre></td></tr></table></figure><p>因此，我们可以把计算100 + 200的结果打印得更漂亮一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print &apos;100 + 200 =&apos;, 100 + 200</div><div class="line">100 + 200 = 300     #运行结果</div></pre></td></tr></table></figure><h2 id="Python的注释"><a href="#Python的注释" class="headerlink" title="Python的注释"></a>Python的注释</h2><p>Python的注释以<code>#</code>开头，后面的文字直到行尾都算注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 这一行全部都是注释...</div><div class="line">print &apos;hello&apos; # 这也是注释</div></pre></td></tr></table></figure><h2 id="Python中什么是变量"><a href="#Python中什么是变量" class="headerlink" title="Python中什么是变量"></a>Python中什么是变量</h2><p>在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = 1</div></pre></td></tr></table></figure><p>变量<code>a</code>是一个整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t_007 = &apos;T007&apos;</div></pre></td></tr></table></figure><p>变量<code>t_007</code>是一个字符串。</p><p>在Python中，等号<code>=</code>是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = 123    # a是整数</div><div class="line">print a</div><div class="line">a = &apos;imooc&apos;   # a变为字符串</div><div class="line">print a</div></pre></td></tr></table></figure><p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。</p><p>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int a = 123; // a是整数类型变量</div><div class="line">a = &quot;mooc&quot;; // 错误：不能把字符串赋给整型变量</div></pre></td></tr></table></figure><p>和静态语言相比，动态语言更灵活，就是这个原因。</p><p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：<code>a = &#39;ABC&#39;</code>时，Python解释器干了两件事情：</p><ol><li>在内存中创建了一个<code>&#39;ABC&#39;</code>的字符串；</li><li>在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>&#39;ABC&#39;</code>。</li></ol><p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = &apos;ABC&apos;</div><div class="line">b = a</div><div class="line">a = &apos;XYZ&apos;</div><div class="line">print b</div></pre></td></tr></table></figure><p>最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p><p>执行<code>a = &#39;ABC&#39;</code>，解释器创建了字符串  ‘ABC’和变量 a，并把a指向 ‘ABC’：</p><p><a href="http://img.mukewang.com/540581030001c11202360058.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/540581030001c11202360058.jpg" alt="img"></a></p><p>执行<code>b = a</code>，解释器创建了变量 b，并把b指向 a 指向的字符串’ABC’：</p><p><a href="http://img.mukewang.com/53fc5e880001399902360084.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/53fc5e880001399902360084.jpg" alt="img"></a></p><p>执行<code>a = &#39;XYZ&#39;</code>，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改：</p><p><a href="http://img.mukewang.com/53fc5e9f0001b98d02360090.jpg" target="_blank" rel="external"><img src="http://img.mukewang.com/53fc5e9f0001b98d02360090.jpg" alt="img"></a></p><p>所以，最后打印变量<code>b</code>的结果自然是<code>&#39;ABC&#39;</code>了。</p><h2 id="Python中定义字符串"><a href="#Python中定义字符串" class="headerlink" title="Python中定义字符串"></a>Python中定义字符串</h2><p>字符串可以用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>括起来表示。</p><p>如果字符串本身包含<code>&#39;</code>怎么办？比如我们要表示字符串<code>I&#39;m OK</code>，这时，可以用<code>&quot; &quot;</code>括起来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;I&apos;m OK&quot;</div></pre></td></tr></table></figure><p>类似的，如果字符串包含<code>&quot;</code>，我们就可以用<code>&#39; &#39;</code>括起来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;Learn &quot;Python&quot; in imooc&apos;</div></pre></td></tr></table></figure><p>如果字符串既包含<code>&#39;</code>又包含<code>&quot;</code>，就需要对字符串的某些特殊字符进行“转义”，Python字符串用<code>\</code>进行转义。</p><p>要表示字符串 <code>Bob said &quot;I&#39;m OK&quot;.</code><br>由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个<code>\</code>表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos;</div></pre></td></tr></table></figure><p><strong>注意：</strong>转义字符 \ 不计入字符串的内容中。</p><p>常用的转义字符还有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\n 表示换行</div><div class="line">\t 表示一个制表符</div><div class="line">\\ 表示 \ 字符本身</div></pre></td></tr></table></figure><h2 id="Python中raw字符串与多行字符串"><a href="#Python中raw字符串与多行字符串" class="headerlink" title="Python中raw字符串与多行字符串"></a>Python中raw字符串与多行字符串</h2><p>如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀<code>r</code>，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r&apos;\(~_~)/ \(~_~)/&apos;</div></pre></td></tr></table></figure><p>但是<code>r&#39;...&#39;</code>表示法不能表示多行字符串，也不能表示包含<code>&#39;</code>和 <code>&quot;</code>的字符串。</p><p>如果要表示多行字符串，可以用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;&apos;&apos;Line 1</div><div class="line">Line 2</div><div class="line">Line 3&apos;&apos;&apos;</div></pre></td></tr></table></figure><p>上面这个字符串的表示方法和下面的是完全一样的：</p><p>‘Line 1\nLine 2\nLine 3’</p><p>还可以在多行字符串前面添加<code>r</code>，把这个多行字符串也变成一个raw字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">r&apos;&apos;&apos;Python is created by &quot;Guido&quot;.</div><div class="line">It is free and easy to learn.</div><div class="line">Let&apos;s start learn Python in imooc!&apos;&apos;&apos;</div></pre></td></tr></table></figure><h2 id="Python中Unicode字符串"><a href="#Python中Unicode字符串" class="headerlink" title="Python中Unicode字符串"></a>Python中Unicode字符串</h2><p>Python在添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print u&apos;中文&apos;</div><div class="line">中文</div></pre></td></tr></table></figure><p><strong>注意:</strong> 不加 u ，中文就不能正常显示。</p><p>Unicode字符串除了多了一个<code>u</code>之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：</p><p><strong>转义：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">u&apos;中文\n日文\n韩文&apos;</div></pre></td></tr></table></figure><p><strong>多行：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u&apos;&apos;&apos;第一行</div><div class="line">第二行&apos;&apos;&apos;</div></pre></td></tr></table></figure><p><strong>raw+多行：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ur&apos;&apos;&apos;Python的Unicode字符串支持&quot;中文&quot;,</div><div class="line">&quot;日文&quot;,</div><div class="line">&quot;韩文&quot;等多种语言&apos;&apos;&apos;</div></pre></td></tr></table></figure><p>如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div></pre></td></tr></table></figure><h2 id="Python中整数和浮点数"><a href="#Python中整数和浮点数" class="headerlink" title="Python中整数和浮点数"></a>Python中整数和浮点数</h2><p>Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。</p><p>基本的运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1 + 2 + 3   # ==&gt; 6</div><div class="line">4 * 5 - 6   # ==&gt; 14</div><div class="line">7.5 / 8 + 2.1   # ==&gt; 3.0375</div></pre></td></tr></table></figure><p>使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1 + 2) * 3    # ==&gt; 9</div><div class="line">(2.2 + 3.3) / (1.5 * (9 - 0.3))    # ==&gt; 0.42145593869731807</div></pre></td></tr></table></figure><p>和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 + 2    # ==&gt; 整数 3</div><div class="line">1.0 + 2.0    # ==&gt; 浮点数 3.0</div></pre></td></tr></table></figure><p>但是整数和浮点数混合运算的结果就变成浮点数了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 + 2.0    # ==&gt; 浮点数 3.0</div></pre></td></tr></table></figure><h2 id="Python中布尔类型"><a href="#Python中布尔类型" class="headerlink" title="Python中布尔类型"></a>Python中布尔类型</h2><p>我们已经了解了Python支持布尔类型的数据，布尔类型只有<code>True</code>和<code>False</code>两种值，但是布尔类型有以下几种运算：</p><p><strong>与运算</strong>：只有两个布尔值都为 True 时，计算结果才为 True。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">True and True   # ==&gt; True</div><div class="line">True and False   # ==&gt; False</div><div class="line">False and True   # ==&gt; False</div><div class="line">False and False   # ==&gt; False</div></pre></td></tr></table></figure><p><strong>或运算</strong>：只要有一个布尔值为 True，计算结果就是 True。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">True or True   # ==&gt; True</div><div class="line">True or False   # ==&gt; True</div><div class="line">False or True   # ==&gt; True</div><div class="line">False or False   # ==&gt; False</div></pre></td></tr></table></figure><p><strong>非运算</strong>：把True变为False，或者把False变为True：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">not True   # ==&gt; False</div><div class="line">not False   # ==&gt; True</div></pre></td></tr></table></figure><p>在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = True</div><div class="line">print a and &apos;a=T&apos; or &apos;a=F&apos;</div></pre></td></tr></table></figure><p>计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？</p><p>因为Python把<code>0</code>、<code>空字符串&#39;&#39;</code>和<code>None</code>看成 False，其他数值和非空字符串都看成 True，所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">True and &apos;a=T&apos; 计算结果是 &apos;a=T&apos;</div><div class="line">继续计算 &apos;a=T&apos; or &apos;a=F&apos; 计算结果还是 &apos;a=T&apos;</div></pre></td></tr></table></figure><p><strong>要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。</strong></p><ol><li>在计算<code>a and b</code>时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。</li><li>在计算<code>a or b</code>时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。</li></ol><p>所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。</p>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第1章 python基本配置</title>
      <link href="/2017/06/17/python-junior-1/"/>
      <url>/2017/06/17/python-junior-1/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>我是一个Android开发工程师，对于python也属于初学者，我希望通过记录笔记的方式记录我学习python的过程，对自己是一种整理与升华的过程，希望能够对其他python入门学习的开发者也能起到一点作用。</p><a id="more"></a><p>我的这套笔记中使用的python版本是python2.7，至于为什么不用python3，我觉得现在对于python2的教程更多一些，方便学习。另外我也属于第一次接触python，如果有哪里写的不对不严谨的地方，请您在评论区指正，我会虚心接受。</p><p>同时，如果你也对python开发感兴趣，不妨我们一起交流，互相学习，共同进步。</p><h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><h3 id="通过安装包安装"><a href="#通过安装包安装" class="headerlink" title="通过安装包安装"></a>通过安装包安装</h3><p>如果你想更新至最新的2.7.x或3.x版本，你可以直接从<a href="https://www.python.org/downloads/" target="_blank" rel="external">python官网</a>下载二进制安装文件。</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-1.png" alt="图1"></p><p>点击上面的链接，然后选择需要的版本。Python 2和3的最新版本就在页面的顶部。选择好Python版本之后，你就能看到针对不同操作系统的安装包下载链接了。</p><p>我建议你下载相应系统的安装器，因为它会处理好所有的安装事宜，只需要确保下载了自己电脑CPU架构（32位或64位）对应的文件即可。笔者下载的则是python2.7.13-Mac OS X 64-bit/32-bit installer。</p><p>双击安装器之后，只要按照提示操作，一路下一步，就可以顺利安装Python。</p><p>安装成功后，打开mac终端，输入python回车，然后就会出现安装的Python的版本信息。键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print &apos;hello,Python!&apos;</div></pre></td></tr></table></figure><p>输出如下图所示</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-2.png" alt="图2"></p><h2 id="mac配置Python集成开发环境（Eclipse-Python-Pydev"><a href="#mac配置Python集成开发环境（Eclipse-Python-Pydev" class="headerlink" title="mac配置Python集成开发环境（Eclipse +Python+Pydev)"></a>mac配置Python集成开发环境（Eclipse +Python+Pydev)</h2><ol><li><p>下载Mac版64位的Eclipse。</p><p>进入到Eclipse官方网站的下载页面（<a href="http://www.eclipse.org/downloads/）" target="_blank" rel="external">http://www.eclipse.org/downloads/）</a></p></li><li><p>下载JDK以及安装</p><p>进入到java开发语言包JDK的官方下载页面（<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html）" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html）</a></p><p>下载后运行安装文件，按步骤安装jdk。因为本套教程不是讲解java开发，所以这里不详细介绍jdk的安装和配置了。在终端键入 java -version 出现以下jdk信息：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-3.png" alt="图3"></p></li><li><p>下载安装Pydev插件</p><p>打开eclipse，菜单栏Help-Install New Software…</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-4.png" alt="图4"></p><p>打开页面后，1点击Add…，2输入Location值为“<a href="http://www.pydev.org/updates”" target="_blank" rel="external">http://www.pydev.org/updates”</a> ，name值任意。输入完成后点击ok按钮。</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-5.png" alt="图5"></p><p>在install中选中第一项，然后点击next，一路next。同意它所有的申请。</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-6.png" alt="图6"></p></li><li><p>配置eclipse的python开发环境</p><p>对eclipse进行设置，具体步骤如下图所示：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-7.png" alt="图7"></p></li><li><p>第一个python工程，步骤如下：</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-8.png" alt="图8"></p><p>在src文件夹new file，输入文件名为hello.py，点击finish</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-9.png" alt="图9"></p><p>在文件中输入如图所示的代码，然后执行，环境正常搭建完成。</p><p><img src="http://7xqgfg.com1.z0.glb.clouddn.com/image/python/python-junior-1-10.png" alt="图10"></p></li></ol>]]></content>
      
      <categories>
          
          <category> Python入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python教程 </tag>
            
            <tag> Python入门 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/06/05/hello-world/"/>
      <url>/2017/06/05/hello-world/</url>
      <content type="html"><![CDATA[<p>博客我来啦！</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>2016-2017 毕业1年总结</title>
      <link href="/2017/05/28/graduation-1st/"/>
      <url>/2017/05/28/graduation-1st/</url>
      <content type="html"><![CDATA[<p>​        自2016年6月本科毕业论文答辩之后正式离开学校，如今已经1年，本人Android攻城狮一枚，23岁，身处帝都，定位西二旗，互联网软件公司，这一年，经历的事情太多，本来要做一款App，但是实在是没有什么时间，算了，写几个字吧，算是对这一年的总结和回顾，同时也对下一年做一个准备。</p><a id="more"></a> <p>​        先说说这一年的变化吧。</p><ul><li>变化</li></ul><ol><li>这一年Android系统版本从Android6.0到7.0，前些日子又来了8.0。Google把之前挖的坑填平了一些，但是又继续挖了更多的坑。其实Google一向如此。</li><li>这一年电脑内存从4G升到6G升到12G，硬盘加固。</li><li>开发工具从Eclipse转向Android Studio，AS原来就是谷歌的巨坑，不过最近几个版本优化的十分不错，现在AS用的很溜。</li><li>开发语言目前主要还是Java，java能力我觉得可以从40%的水平提升到60%，前路漫漫，同时也涉猎html、js、jsp还有一些Java后台框架，还有Python也在不断学习中。对了，有一个事情不可不提，今年Google I/O大会竟然提出Kotlin，然后现在网上各种Kotlin将作为Android第一开发语言的言论铺天盖地而来，然后Kotlin官网就多了一句<a href="http://kotlinlang.org/" target="_blank" rel="external">Now official on Android</a>，我已是无力吐槽，我周围的人都在说学会了Kotlin万一把Java Api给整混乱就犯不上了。</li><li>认识的人也越多了，各种社交软件零零散散加起来应该多了两百多人吧。</li><li>薪资也有一丢丢提高，隐私就不说了。</li></ol><ul><li>不变的</li></ul><ol><li>这一年，我还是早上7点之前起床，不睡懒觉。</li><li>我用的还是那款手机，MI NOTE LTE。</li><li>依然还有一颗热爱生活、积极向上的心态。</li></ol><ul><li>总结一下</li></ul><ol><li><p>工作上</p><p>一入编程深似海啊，面对着每天至少8个小时的工作，也许8小时都是奢望，确实是充实。长时间的工作，成长贼快，面对如浩瀚汪洋般的Coding世界，只有不断学习，不断查阅资料，这点度娘不行，还得Google。话说起来柯洁0：3负于AlphaGo还是有点小小遗憾，不过我觉的就算再智能，也得加上“人工”两个字。</p><p>这一年主要负责和参与的企业级项目有7个，目前都在迭代，都可以在AppStore去下载玩玩看，大概修复缺陷和新增功能加一起大概500+个，你要知道每个人写的代码风格不尽相同，阅读别人的代码你都恨不得每行加上注释SB。最怕那种不谈什么底层原理、运行效率、算法优化什么的主，老夫Coding就是一把梭！真想一脚踹飞他！</p><p>总的来说我觉的进步还是不小的，原来网上的一些慕课只来的还需去看视频，现在查阅一下资料就能懂，被人教会和主动学会的感觉是不一样的。我下一步的计划就是要教会别人。</p></li><li><p>生活中</p><p>这一年，我长了一岁，家人也老了一岁，希望家人都健健康康。想想从初中开始就没怎么陪伴过家人，现在是真的觉得应该时常陪在家人身边，家庭最重要！还是觉的小时候好，不是因为小时候的自己可以无忧无虑，而是小时候亲人都在，长大之后慢慢就会有亲人要离开我们。小时候真好。</p><p>这一年，我和她在一起第4个念头，这一年我们都在北京，我们基本走遍北京的所有景点，吃了很多美食。下一步我觉的还要发掘一些新的玩处，玩出水平。</p></li><li><p>说说我的工作吧</p><p>说说工作就不可避免的要谈到大学生活。</p><p>这一年，可以说是在为大学买单，大学不如名校，其实已经被人家落下了，如果你不够十二分的努力，那么就被拉的更远，不说别的，单单说基础编程能力，你以为你在大学如何如何，殊不知人家已经起飞，而自己还在跑道上滑行。这个时候就要付出更多努力，加大马力，同时还要掌握正确的方法方式，追上人家，超越不是随便讲出来的，但并不是不可能完成。</p><p>我不觉的我的第一份工作有多好，但是我把这个当作是充电与追赶的跳板。出身不好就要更加努力，基础打牢。</p><p>接下来的一年，我要系统学习其他几种编程语言还有一些其他的技术，目前来说应该是python和Java后台，同时要从架构和底层的角度多多考虑。</p><p>接下来的一年，我要用更多的时间陪伴家人和爱人。</p><p>接下来的一年，我要继续保持阳光的心态，保证健康的身体。</p></li></ol><p>​       不求能成为榜样，但求能以自己的绵薄之力为社会、为家人、为他人做出那么一点点贡献。</p><p>​       好了，就写这么多了，端午的假期得早点睡！</p><p>​                                                                     2017年5月28日 夜</p><p>​                                                                                北京 昌平</p>]]></content>
      
      <categories>
          
          <category> 个人总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
