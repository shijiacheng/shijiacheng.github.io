<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode刷题]]></title>
    <url>%2F2018%2F04%2F14%2Fcrazyleetcode%2F</url>
    <content type="text"><![CDATA[LeetCode 刷题 Two Sum]]></content>
  </entry>
  <entry>
    <title><![CDATA[网易2019实习生招聘编程题集合]]></title>
    <url>%2F2018%2F04%2F06%2Fnetease-intern-2019%2F</url>
    <content type="text"><![CDATA[1.牛牛找工作为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。 2.被3整除小Q得到一个神奇的数列: 1, 12, 123,…12345678910,1234567891011…。并且小Q对于能否被3整除这个性质很感兴趣。小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。 3.安置路灯小Q正在给一条长度为n的道路设计路灯安置方案。为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’.’表示, 不需要照亮的障碍物格子用’X’表示。小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。小Q希望能安置尽量少的路灯照亮所有’.’区域, 希望你能帮他计算一下最少需要多少盏路灯。 4.迷路的牛牛牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。 5.数对牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。牛牛希望你能帮他计算一共有多少个可能的数对。 6.矩形重叠平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。 7.牛牛的闹钟牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床 8.牛牛的背包问题牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。]]></content>
      <categories>
        <category>笔试算法题</category>
      </categories>
      <tags>
        <tag>网易2019实习生招聘编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp实现全局过期token自动刷新]]></title>
    <url>%2F2018%2F03%2F28%2Fokhttp-interceptor%2F</url>
    <content type="text"><![CDATA[问题一次面试遇到的一个问题，其实也是实际开发中很容易遇到的问题，特此记录一下。 当请求某个接口的时候，我们会在请求的header中携带token消息，但是发现token失效，接口请求报错，怎么马上刷新token，然后重复请求方才那个接口呢？这个过程应该说对用户来说是无感的。 这个过程用流程图可以这样表示： 要实现上述需求的话，大家会如何实现呢？ 首先讲一下Token和Cookie吧- cookiecookie是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 cookie的组成有：名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”\”)、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。 - tokentoken的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。 解决方案 通过拦截器，获取返回的数据 判断token是否过期 如果token过期则刷新token 使用最新的token，重新请求网络数据 自定义自动刷新token的拦截器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import android.util.Log;import java.io.IOException;import okhttp3.Interceptor;import okhttp3.Request;import okhttp3.Response;/** * 自动刷新token的拦截器 * * @author shijiacheng * @version 1.0 */public class TokenInterceptor implements Interceptor &#123; private static final String TAG = &quot;TokenInterceptor&quot;; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Response response = chain.proceed(request); Log.d(TAG, &quot;response.code=&quot; + response.code()); //根据和服务端的约定判断token过期 if (isTokenExpired(response)) &#123; Log.d(TAG, &quot;自动刷新Token,然后重新请求数据&quot;); //同步请求方式，获取最新的Token String newToken = getNewToken(); //使用新的Token，创建新的请求 Request newRequest = chain.request() .newBuilder() .header(&quot;Authorization&quot;, &quot;Basic &quot; + newToken) .build(); //重新请求 return chain.proceed(newRequest); &#125; return response; &#125; /** * 根据Response，判断Token是否失效 * * @param response * @return */ private boolean isTokenExpired(Response response) &#123; if (response.code() == 301) &#123; return true; &#125; return false; &#125; /** * 同步请求方式，获取最新的Token * * @return */ private String getNewToken() throws IOException &#123; // 通过获取token的接口，同步请求接口 String newToken = &quot;&quot;; return newToken; &#125;&#125; 配置下OkHttpUtils 1234567891011121314151617/** * 初始化OkHttpUtils */public OkHttpUtils()&#123; /** * 配置OkHttpClient */ OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .readTimeout(3000, TimeUnit.SECONDS) .writeTimeout(3000, TimeUnit.SECONDS)// .cache(new Cache())// .addInterceptor(interceptor)//这里可以继续添加多种拦截器 .addInterceptor(new TokenInterceptor())//添加获取token的拦截器 .build(); &#125;]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android启动页解决攻略]]></title>
    <url>%2F2017%2F09%2F09%2Fandroid-splash-demo%2F</url>
    <content type="text"><![CDATA[相信很多人都在网上查过关于启动白屏或者黑屏的问题。 一般的App应该是分为两种： 有闪屏页或者启动页(SplashActivity)，页面大概会持续2到3秒 没有闪屏页和启动页，打开应用后会直接跳转到应用主界面 不管有没有启动页，如果你不处理，你会发现当你点击桌面上那个icon图标的时候会先闪白屏或者黑屏一下，然后才会进入我们设定的页面。 但是我们手机上的常用应用，比如美团，今日头条，微信等，点击app icon的时候，其实感觉是一瞬间秒开的，没有白屏的过程，那么这是如何处理的呢？ 先说一说为什么会出现白屏或者黑屏吧！当打开一个Activity时，如果这个Activity所属的应用还没有在运行，系统会为这个Activity所属的应用创建一个进程，但进程的创建与初始化都需要时间，如果没有任何反应的话，如果程序初始化的时间很长，用户可能还以为没有点到相应的位置。但此时所启动的程序还没初始化完，既无法显示程序，又不能停在原处不做任何动作，这就有了Starting Window的概念，也可以称之为Preview Window。 Starting Window就是一个用于在应用程序进程创建并初始化成功前显示的临时窗口，拥有的Window Type是TYPE_APPLICATION_STARTING。在程序初始化完成前显示这个窗口，以告知用户系统已经知道了他要打开这个应用并做出了响应，当程序初始化完成后显示用户UI并移除这个窗口。 显示白屏或者黑屏，是由你的启动Activity或者Application来决定的。如果你使用的是Light主题，那么就可能出现白屏；如果你使用的是Black主题，那么就可能出现黑屏。当你设置Light或者Black主题时，Starting Window显示的就是你启动Activity的android:windowBackground属性，所以才会出现白屏或者黑屏的情况。 网上有很多教程，说是把主题的背景设为透明，这样子的确实没有白屏了，但是你会发现点击完app的icon之后，会有一小会的停顿，给用户一种卡顿的感觉，体验非常不好，不能为了实现功能而实现功能，软件开发用户体验至上！ 那么好的体验该如何开发呢？我们以实现一个今日头条app的启动页作为案例。 我们先来看一看常规情况下app启动的黑白屏。 为了让白屏或者黑屏明显的显示，在SplashActivity的onCreate方法中setContentView之前加入一个休眠1秒的操作。 123456/*还没有加载布局是睡眠1秒，确保黑屏或白屏效果明显*/try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; 12345678910/**闪屏页持续1s然后进入主页*/mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Intent intent = new Intent(activity,AdsActivity.class); startActivity(intent); finish(); overridePendingTransition(R.anim.fade,R.anim.hold); &#125; &#125;, 1000); 效果是： 接下来我们来消灭白屏。第一步 消灭白屏1.我们需要删除原来的闪屏页的布局activity_splash.xml，同时删除SplashActivity中setContentView(R.layout.activity_splash)方法。 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); /*还没有加载布局是睡眠1秒，确保黑屏或白屏效果明显*/ try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;// setContentView(R.layout.activity_splash);&#125; 2.为了让闪屏页持续时间长一点，我们用handler模拟耗时操作，1秒后进行跳转。 123456789mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; //这块耗时操作可以进行初始化，或者网络请求等，1秒结束后跳转到广告页面 Intent intent = new Intent(activity,AdsActivity.class); startActivity(intent); finish(); &#125; &#125;, 1000); 3.我们删除了闪屏页的布局文件，想法是将闪屏的背景作为Activity的主题背景，要做到这一点，首先要在 res/drawable创建一个XML drawable文件。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@color/white&quot; /&gt; &lt;item android:bottom=&quot;20dp&quot;&gt; &lt;bitmap android:gravity=&quot;bottom&quot; android:src=&quot;@mipmap/icon_logo&quot; /&gt; &lt;/item&gt;&lt;/layer-list&gt; 4.接下来在style.xml中创建一个闪屏页的主题，将创建的xml设置为window的背景。并且在AndroidManifest.xml中给SplashActivity配置style。 123&lt;style name=&quot;AppTheme.Splash&quot; parent =&quot;android:Theme.Holo.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/drawable_splash&lt;/item&gt;&lt;/style&gt; 12345678&lt;activity android:name=&quot;.SplahActivity&quot; android:theme=&quot;@style/AppTheme.Splash&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 这个时候运行程序，我们发现其实已经没有白屏了。 第二步，我们实现广告加载页面 1.广告页是一个倒计时的显示，布局中放入一个TextView来显示倒计时信息，放入一个ImageView来显示加载动画。点击跳过广告的时候显示加载动画。 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_logo&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/icon_logo&quot; android:layout_marginBottom=&quot;20dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot;/&gt; &lt;RelativeLayout android:layout_marginBottom=&quot;20dp&quot; android:layout_above=&quot;@+id/iv_logo&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/colorAccent&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_ads&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;跳过广告&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;12sp&quot; android:background=&quot;@drawable/bg_ad_text&quot; android:padding=&quot;5dp&quot;/&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt; 2.页面实现中，我们定义一个CountDownTimer，这个类是Android SDK提供用来进行倒计时的。CountDownTimer(long millisInFuture, long countDownInterval)有两个参数，第一个是计时的总时长，第二个是间隔。 12345678910111213141516171819202122232425262728293031323334353637383940public class AdsActivity extends Activity &#123; private Activity activity; private TextView tvAds; private CountDownTimer countDownTimer; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_ads); activity =this; tvAds = (TextView) findViewById(R.id.tv_ads); countDownTimer = new CountDownTimer(4000,1000) &#123; @Override public void onTick(long millisUntilFinished) &#123; tvAds.setText(&quot;跳过广告&quot;+(millisUntilFinished/1000)+&quot;秒&quot;); &#125; @Override public void onFinish() &#123; Intent intent = new Intent(activity,MainActivity.class); startActivity(intent); finish(); &#125; &#125;.start(); /** * 跳过广告 */ tvAds.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; countDownTimer.cancel(); Intent intent = new Intent(activity,MainActivity.class); startActivity(intent); finish(); &#125; &#125;); &#125;&#125; 第三步，优化1.我们运行起来，发现页面之间的跳转有些不美观，从右向左进入的动画感觉有些生硬。因此我们给页面之间加入转场动画。 123456#fade.xml 页面退出动画&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;0.0&quot; android:duration=&quot;400&quot; /&gt; 123456#hold.xml 页面进入动画&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot; android:fromXDelta=&quot;0&quot; android:toXDelta=&quot;0&quot; android:duration=&quot;400&quot; /&gt; 在每个Intent跳转的地方加入转场效果 1234Intent intent = new Intent(activity,AdsActivity.class);startActivity(intent);finish();overridePendingTransition(R.anim.fade,R.anim.hold); 最终的效果是： 有两点注意： overridePendingTransition方法要写在finish后面 overridePendingTransition方法一定要写在主线程中，在子线程是没有作用的。 源码地址：http://download.csdn.net/download/u012771445/9971093]]></content>
      <categories>
        <category>Android基础教程</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Google VR教你打造全景图片展示]]></title>
    <url>%2F2017%2F09%2F07%2FGoogleVRImage%2F</url>
    <content type="text"><![CDATA[本文章主要参考Google VR中的文档，如果您能流利的读懂英文开发文档，可以去官网自行查看。 1.介绍VR View VR view allows you to embed 360 degree VR media into websites on desktop and mobile, and native apps on Android and iOS. This technology is designed to enable developers of traditional apps to enhance the apps with immersive content. VR视图允许你将360度的VR媒体嵌入桌面和移动的网站，以及Android和iOS上的原生应用。这项技术旨在使传统应用程序的开发者能够通过沉浸式的内容来增强应用程序。 VR view supports mono and stereo 360 images and videos. Images and video need to be stored in the equirectangular-panoramic (equirect-pano) format, which is a common format supported by many capture solutions. VR视图支持mono和立体图像和视频。图像和视频需要存储在equi矩形-全景(equirect - pano)格式中，这是许多捕获解决方案支持的公共格式。 Image规格 VR查看图像可以保存为PNG，JPEG或GIF。Google建议使用JPEG改进压缩。 为了获得最大的兼容性和性能，图像尺寸应该是2的倍数（例如，2048或4096）。 单个图像应为2：1纵横比（例如4096×2048）。 立体图像应为1：1纵横比（例如4096×4096）。 mono单个图像 stereo立体图像 先来看看效果： 2.使用VrPanoramaView嵌入全景图像1.build.gradle在app下的build.gradle中添加panowidget库 123dependencies &#123; compile &apos;com.google.vr:sdk-panowidget:1.10.0&apos;&#125; 2.AndroiManifest.xml在使用VrPanoramaView的Acitivity的intent-filter节点添加过滤分类：com.google.intent.category.CARDBOARD ： 兼容Cardboard纸盒 12345&lt;activity android:name=&quot;.VrPanoramaActivity&quot; &gt; &lt;intent-filter&gt; &lt;category android:name=&quot;com.google.intent.category.CARDBOARD&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 3.布局文件只需在布局中添加一个控件 123456&lt;com.google.vr.sdk.widgets.pano.VrPanoramaView android:id=&quot;@+id/pano_view&quot; android:layout_margin=&quot;5dip&quot; android:layout_width=&quot;match_parent&quot; android:scrollbars=&quot;@null&quot; android:layout_height=&quot;250dip&quot; /&gt; 4.加载全景图A.初始化控件 1VrPanoramaView vrPanView = (VrPanoramaView) findViewById(R.id.vr_pan_view); B.读取图片 我们提前将一张选择好的全景图放在assets目录中，aa.jpg,将图片转为bitmap 12345678/**获取assets中的图片，转为流**/InputStream open = null;try &#123; open = getAssets().open(&quot;aa.jpg&quot;);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;Bitmap bitmap = BitmapFactory.decodeStream(open); C.设置VrPanoramaView.Options 123/**VrPanoramaView.Options 设置**/VrPanoramaView.Options options = new VrPanoramaView.Options();options.inputType = VrPanoramaView.Options.TYPE_MONO; VrPanoramaView.Options有两种类型： TYPE_MONO 360度单图(2：1纵横比)图像被预期以覆盖沿着其水平轴360度，而垂直范围是根据图像的宽高比来计算。例如，如果一个1000x250像素的图像，给出所述全景将覆盖360x90度与垂直范围是-45至+45度。 TYPE_STEREO_OVER_UNDER 立体图(1：1纵横比)包含两个大小相等的投影 全景图垂直叠加。顶部图像被显示给左眼、底部图像被显示给右眼。图像将覆盖沿水平轴360度，而垂直范围是根据图像的宽高比来计算。例如，如果一个1000x500像素的图像中给出（即1000x250像素每个眼睛），全景将覆盖360x90度与垂直范围是-45至+45度。 D.加载全景图 1vrPanView.loadImageFromBitmap(bitmap, options); E.设置加载监听VrPanoramaEventListener 1234567891011121314151617181920212223242526272829303132333435363738394041/**设置加载图片监听**/vrPanView.setEventListener(new VrPanoramaEventListener() &#123; /** * 显示模式改变回调 * 1.默认 * 2.全屏模式 * 3.VR观看模式，即横屏分屏模式 */ @Override public void onDisplayModeChanged(int newDisplayMode) &#123; super.onDisplayModeChanged(newDisplayMode); Log.d(TAG, &quot;onDisplayModeChanged()-&gt;newDisplayMode=&quot; + newDisplayMode); &#125; /** * 加载VR图片失败回调 */ @Override public void onLoadError(String errorMessage) &#123; super.onLoadError(errorMessage); Log.d(TAG, &quot;onLoadError()-&gt;errorMessage=&quot; + errorMessage); &#125; /** * 加载VR图片成功回调 */ @Override public void onLoadSuccess() &#123; super.onLoadSuccess(); Log.d(TAG, &quot;onLoadSuccess-&gt;图片加载成功&quot;); &#125; /** * 点击VR图片回调 */ @Override public void onClick() &#123; super.onClick(); Log.d(TAG, &quot;onClick()&quot;); &#125;&#125;); F.在onPause、onResume、onDestroy中做出相应处理 1234567891011121314151617@Overrideprotected void onPause() &#123; super.onPause(); vrPanView.pauseRendering();//暂停3D渲染和跟踪&#125;@Overrideprotected void onResume() &#123; super.onResume(); vrPanView.resumeRendering();//恢复3D渲染和跟踪&#125;@Overrideprotected void onDestroy() &#123; vrPanView.shutdown();//关闭渲染下并释放相关的内存 super.onDestroy();&#125; G.一些其他方法 //是否隐藏左下角信息的按钮vrPanView.setInfoButtonEnabled(boolean enabled); //是否隐藏全屏按钮vrPanView.setFullscreenButtonEnabled(boolean enabled); 未完，如果遇到新的继续添加 最后附上完整代码：VrPanoramaActivity.java]]></content>
      <categories>
        <category>Android提高</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>Google VR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First RecyclerView (RecyclerView使用详解)]]></title>
    <url>%2F2017%2F06%2F30%2Ffirst-RecyclerView%2F</url>
    <content type="text"><![CDATA[1. RecyclerView是什么？根据Google官方给出的说明： A flexible view for providing a limited window into a large data set. 能够在有限的窗口中展示大数据集合的灵活视图。 所以我们能够理解为，RecyclerView的一个恰当的使用场景是：由于尺寸限制，用户的设备不能一次性展现所有条目，用户需要上下滚动以查看更多条目。滚出可见区域的条目将被回收，并在下一个条目可见的时候被复用。 对于减少内存开销和CPU的计算，缓存条目是一个非常有用的方法，因为这意味着我们不必每次都创建新的条目，从而减小内存开销和CPU的计算，而且还能够有效降低屏幕的卡顿，保证滑动的顺滑。 RecyclerView不关心视觉效果（visuals） 但是和ListView有什么区别呀？我们已经使用ListView很长一段时间了呀，它一样可以做到呀。从它的类名上看，RecyclerView代表的意义是，我只管Recycler View，也就是说RecyclerView只管回收与复用View，其他的开发者可以自己去设置。你想要另一个布局？插入另一个LayoutManager。你想要不同的动画吗？插入一个ItemAnimator，等等。可以看出其高度的解耦，给予你充分的定制自由（所以你才可以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果）。 2. 引入RecyclerViewRecyclerView 是Support Library的一部分。所以只需要在app/build.gradle中添加以下依赖，便能立即使用： 123dependencies &#123; compile &apos;com.android.support:recyclerview-v7:25.3.1&apos;&#125; 在布局文件中加入： 1234&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后在页面中引入RecyclerView即可： 1RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); OK，从现在开始，让我们一步一步，开始了解它。 3. 使用RecyclerView下面的表格中就是使用RecyclerView来显示数据中用到的几个最重要的类，这些类都是RecyclerView的内部类，如果你想使用RecyclerView，需要做以下操作： Class 功能 Adapter 处理数据集合并负责绑定视图 ViewHolder 持有所有的用于绑定数据或者需要操作的View LayoutManager 负责摆放视图等相关操作 ItemDecoration 负责绘制Item附近的分割线 ItemAnimator 为Item的一般操作添加动画效果，如，增删条目等 我们可以从下图更直观的了解到RecyclerView的基本结构： 接下来，我将要描述每个类或接口的内容以及如何使用它。 3.1 RecyclerView.ViewHolderViewHolder的基本用法是用来存放View对象。Android团队很早之前就推荐使用“ViewHolder设计模式”，但是没有要求开发者在Adapter中必须使用ViewHolder模式。那么现在对于这种新型的RecyclerView.Adapter，我们必须实现并使用这种模式。 Google官方等了这么长时间才强制使用ViewHolder模式，这有点奇怪，但迟做总比不做好。如果您不了解ViewHolder模式，请查看一下Android training Hold View Objects in a View Holder。另外网上有大量关于ListView优化的文章。面试重点。 有一件事是专门针对RecyclerView的。ViewHolder子类可以通过访问公共成员itemView来访问ViewHolder的根视图。所以不需要在ViewHolder子类中存储。 下面是示例的ViewHolder的代码，ViewHolder是示例Adapter的内部类： 123456789public static class MyViewHolder extends RecyclerView.ViewHolder&#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = (TextView) itemView.findViewById(R.id.tv); &#125;&#125; 3.2 AdapterAdapter扮演着两个角色。一是，根据不同ViewType创建与之相应的的Item-Layout，二是，访问数据集合并将数据绑定到正确的View上。这就需要我们重写以下3个方法： public VH onCreateViewHolder(ViewGroup parent, int viewType) 创建Item视图，并返回相应的ViewHolder public void onBindViewHolder(VH holder, int position) 绑定数据到正确的Item视图上。 public int getItemCount() 返回该Adapter所持有的item数量 示例代码如下所示： 12345678910111213141516@Overridepublic MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context) .inflate(R.layout.item_recycler_view,parent,false)); return holder;&#125;@Overridepublic void onBindViewHolder(MyViewHolder holder, int position) &#123; holder.tv.setText(mDatas.get(position));&#125;@Overridepublic int getItemCount() &#123; return mDatas.size();&#125; 因此，一个基本的RecyclerView.Adapter如下： 123456789101112131415161718192021222324252627282930313233343536public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecyclerAdapter.MyViewHolder&gt; &#123; private Context context; private List&lt;String&gt; mDatas; public RecyclerAdapter(Context context, List&lt;String&gt; mDatas) &#123; this.context = context; this.mDatas = mDatas; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MyViewHolder holder = new MyViewHolder(LayoutInflater.from(context) .inflate(R.layout.item_recycler_view, parent, false)); return holder; &#125; @Override public void onBindViewHolder(MyViewHolder holder, int position) &#123; holder.tv.setText(mDatas.get(position)); &#125; @Override public int getItemCount() &#123; return mDatas == null ? 0 : mDatas.size(); &#125; public static class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View itemView) &#123; super(itemView); tv = (TextView) itemView.findViewById(R.id.tv); &#125; &#125;&#125; 3.3 RecyclerView.LayoutManagerLayoutManager的职责是摆放Item的位置，并且负责决定何时回收和重用Item。它有一个默认的实现：LinearLayoutManager，它可以用于垂直和水平列表。 RecyclerView.LayoutManager是一个抽象类，RecyclerView为我们提供3个实现类： LinearLayoutManager 现行管理器，支持横向、纵向。 GridLayoutManager 网格布局管理器 StaggeredGridLayoutManager 瀑布流式布局管理器 3.3.1 LinearlayoutManagerLinearlayoutManager是LayoutManager的默认实现。你可以使用这个类来创建垂直或水平列表。 1234// 设置RecyclerView布局方式为纵向布局LinearLayoutManager layoutManager = new LinearLayoutManager(context);layoutManager.setOrientation(LinearLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); 1234// 设置RecyclerView布局方式为横向布局LinearLayoutManager layoutManager= new LinearLayoutManager(this);layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);recyclerView.setLayoutManager(layoutManager); 运行程序，我们看到如下效果： 我们发现和ListView有一些不同，没有分割线让这个列表看起来很不美观，给RecyclerView设置分割线这个我们在下一小节说明。 当然LinearlayoutManager中还有一些很实用的API： findFirstVisibleItemPosition() 返回当前第一个可见Item的position findFirstCompletelyVisibleItemPosition() 返回当前第一个完全可见Item的position findLastVisibleItemPosition() 返回当前最后一个可见Item的position findLastCompletelyVisibleItemPosition() 返回当前最后一个完全可见Item的position 3.3.2 GridLayoutManager有两个构造方法： 123456789101112131415161718192021/*** Creates a vertical GridLayoutManager** @param context Current context, will be used to access resources.* @param spanCount 设置行数，因为默认是纵向的*/public GridLayoutManager(Context context, int spanCount) &#123; super(context); setSpanCount(spanCount);&#125;/*** @param context Current context, will be used to access resources.* @param spanCount 设置行数或者列数，根据方向* @param orientation 布局方向 HORIZONTAL or VERTICAL.* @param reverseLayout 是否反向显示 When set to true, layouts from end to start.*/public GridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) &#123; super(context, orientation, reverseLayout); setSpanCount(spanCount);&#125; 我们按如下代码设置： 1234567// 设置纵向的4列的表格布局GridLayoutManager layoutManager = new GridLayoutManager(this,4,GridLayoutManager.VERTICAL,false);recyclerView.setLayoutManager(layoutManager);// 设置横向的3行的表格布局GridLayoutManager layoutManager = new GridLayoutManager(this,3,GridLayoutManager.HORIZONTAL,false);recyclerView.setLayoutManager(layoutManager); 3.3.3 StaggeredGridLayoutManager我们来看StaggeredGridLayoutManager的构造方法，只有一个方法 1234567/*** Creates a StaggeredGridLayoutManager with given parameters.** @param spanCount 设置行数或者列数，根据方向，纵向就是列数，横向就是行数* @param orientation 方向*/public StaggeredGridLayoutManager(int spanCount, int orientation) &#123;&#125; 因此我们这样设置： 123// 设置纵向的瀑布流布局StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL);recyclerView.setLayoutManager(layoutManager); 我们看效果和GridLayoutManager没有什么区别呢，那我们来小小的修改一下，你就可以看到它的强大。 我们给每个item的布局加入margin： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; android:background=&quot;@color/colorAccent&quot;&gt; &lt;TextView android:id=&quot;@+id/tv&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:textColor=&quot;#fff&quot; /&gt;&lt;/LinearLayout&gt; 然后我们在适配器的onBindViewHolder方法中为我们的item设置个随机的高度： 123456789101112131415161718//贴上部分代码，其余的请看附件 private List&lt;Integer&gt; mHeights; public RecyclerAdapter(Context context, List&lt;String&gt; mDatas) &#123; this.context = context; this.mDatas = mDatas; mHeights = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; mDatas.size(); i++) &#123; mHeights.add((int) (100 + Math.random() * 300)); &#125; &#125; @Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; ViewGroup.LayoutParams lp = holder.tv.getLayoutParams(); lp.height = mHeights.get(position); holder.tv.setLayoutParams(lp); &#125; 运行，我们可以看到效果，是不是很炫！ 3.4 RecyclerView.ItemDecoration通过设置 1recyclerView.addItemDecoration(new DividerDecoration(Context context, int orientation)); 来改变Item之间的偏移量或者对Item进行装饰。 例如，在上面的设置LinearlayoutManager之后加入以下代码，那么列表的效果就会发生改变： 1234// 给纵向显示RecyclerView设置分割线recyclerView.addItemDecoration(new DividerItemDecoration(activity,DividerItemDecoration.VERTICAL));// 给横向显示RecyclerView设置分割线recyclerView.addItemDecoration(new DividerItemDecoration(activity,DividerItemDecoration.HORIZONTAL)); 当然，你也可以对RecyclerView设置多个ItemDecoration，列表展示的时候会遍历所有的ItemDecoration并调用里面的绘制方法，对Item进行装饰。 RecyclerView.ItemDecoration是一个抽象类，可以通过重写以下三个方法，来实现Item之间的偏移量或者装饰效果： public void onDraw(Canvas c, RecyclerView parent) 装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡 public void onDrawOver(Canvas c, RecyclerView parent) 装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上 public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) 与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。 当然了，如果我们使用GridLayoutManager后，对于分割线，前面的DividerItemDecoration就不适用了，主要是因为它在绘制的时候，比如水平线，针对每个child的取值为： 12final int left = parent.getPaddingLeft();final int right = parent.getWidth() - parent.getPaddingRight(); 因为每个Item一行，这样是没问题的。而GridLayoutManager时，一行有多个childItem，这样就多次绘制了，并且GridLayoutManager时，Item如果为最后一列（则右边无间隔线）或者为最后一行（底部无分割线）。 按照上述的方法，我们可以自定义一个DividerGridItemDecoration。由于代码篇幅过长，我们在附件中给出。我们给GridLayoutManager设置DividerGridItemDecoration，运行效果如下： 3.5 RecyclerView.ItemAnimatorItemAnimator能够帮助Item实现独立的动画。 ItemAnimator作触发于以下三种事件： 某条数据被插入到数据集合中 从数据集合中移除某条数据 更改数据集合中的某条数据 幸运的是，在Android中默认实现了一个DefaultItemAnimator，我们可以通过以下代码为Item增加动画效果： 1recyclerView.setItemAnimator(new DefaultItemAnimator()); 在之前的版本中，当时据集合发生改变时，我们通过调用.notifyDataSetChanged()，来刷新列表，因为这样做会触发列表的重绘，所以并不会出现任何动画效果，因此需要调用一些以notifyItem*()作为前缀的特殊方法，比如： public final void notifyItemInserted(int position) 向指定位置插入Item public final void notifyItemRemoved(int position) 移除指定位置Item public final void notifyItemChanged(int position) 更新指定位置Item 下面我们使用DefaultItemAnimator来展示一下动画效果，修改代码如下： 在Activity中添加两个按钮add和remove负责动态插入和移除item 12345678910111213btnAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; adapter.addData(1); &#125; &#125;);btnRemove.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; adapter.removeData(2); &#125; &#125;); 在Adapter中添加两个方法： 12345678910public void addData(int position) &#123; mDatas.add(position, &quot;Insert&quot;); mHeights.add( (int) (100 + Math.random() * 300)); notifyItemInserted(position);&#125;public void removeData(int position) &#123; mDatas.remove(position); notifyItemRemoved(position);&#125; 运行结果如下： 3.6 Listeners很遗憾，RecyclerView并没有像ListView那样提供以下两个Item的点击监听事件 public void setOnItemClickListener(@Nullable OnItemClickListener listener) Item点击事件监听 public void setOnItemLongClickListener(OnItemLongClickListener listener) Item长按事件监听 但是这并不能阻拦我们的脚步，我可以定义这样的两个方法。 12345678910public interface OnItemClickLitener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position);&#125;private OnItemClickLitener litener;public void setLitener(OnItemClickLitener litener) &#123; this.litener = litener;&#125; 在onBindViewHolder方法中给需要响应点击事件的控件设置监听器： 12345678910111213141516171819// 如果设置了回调，则响应点击事件holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (litener != null) &#123; litener.onItemClick(v, position); &#125; &#125;&#125;);holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; if (litener != null) &#123; litener.onItemLongClick(v, position); &#125; return false; &#125;&#125;); 在Activity中设置这个方法： 1234567891011adapter.setLitener(new RecyclerAdapter.OnItemClickLitener() &#123; @Override public void onItemClick(View view, int position) &#123; Toast.makeText(activity,&quot;第&quot;+position+&quot;项被点击了&quot;,Toast.LENGTH_SHORT).show(); &#125; @Override public void onItemLongClick(View view, int position) &#123; Toast.makeText(activity,&quot;第&quot;+position+&quot;项被长按了&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;); 效果如图： 源码地址：http://download.csdn.net/detail/u012771445/9885640]]></content>
      <categories>
        <category>Android基础教程</category>
      </categories>
      <tags>
        <tag>Android控件</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 列表生成式]]></title>
    <url>%2F2017%2F06%2F23%2Fpython-junior-9%2F</url>
    <content type="text"><![CDATA[生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)： 12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？ 方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)... &gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。 写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 任务请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, …, 99x100] 提示：range(1, 100, 2) 可以生成list [1, 3, 5, 7, 9,…] 12#Listcomprehensions1.pyprint [x*(x+1) for x in range(1, 100, 2)] 复杂表达式使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。 假设有如下的dict： 1d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125; 完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： 12345tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()]print &apos;&lt;table&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 注：字符串可以通过 % 进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个 list 拼接成一个字符串。 把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了： 123456&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 任务在生成的表格中，对于没有及格的同学，请把分数标记为红色。 提示：红色可以用 实现。 123456789101112#Listcomprehensions2.pyd = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;def generate_tr(name, score): if score &lt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score)tds = [generate_tr(name,score) for name, score in d.iteritems()]print &apos;&lt;table border=&quot;1&quot;&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 任务请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。 提示： isinstance(x, str) 可以判断变量 x 是否是字符串； 字符串的 upper() 方法可以返回大写的字母。 1234#Listcomprehensions3.pydef uperList(L): return [s.upper() for s in L if isinstance(s, str)]print uperList([&apos;Hello&apos;, &apos;world&apos;, 101]) 多层表达式for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。 对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： 12&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;][&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;] 翻译成循环代码就像下面这样： 1234L = []for m in &apos;ABC&apos;: for n in &apos;123&apos;: L.append(m + n) 任务利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。 123#Listcomprehensions4.pyL= [100*a+10*b+c for a in range(1,10) for b in range(10) for c in range(10) if a == c]print L]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 迭代]]></title>
    <url>%2F2017%2F06%2F23%2Fpython-junior-8%2F</url>
    <content type="text"><![CDATA[什么是迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。 在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码： 123for (i=0; i&lt;list.length; i++) &#123; n = list[i];&#125; 可以看出，Python的for循环抽象程度要高于Java的for循环。 因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。 因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。 1234注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：1. 有序集合：list，tuple，str和unicode；2. 无序集合：set3. 无序集合并且具有 key-value 对：dict 而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。 迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。 任务请用for循环迭代数列 1-100 并打印出7的倍数。 12345#Iteration1.pyL = range(1,101)for num in L: if num %7==0: print num 索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。 对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 enumerate() 函数： 12345678&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul 使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 变成了类似： 1[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)] 因此，迭代的每一个元素实际上是一个tuple： 1234for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 任务zip()函数可以把两个 list 变成一个 list： 12&gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [‘Adam’, ‘Lisa’, ‘Bart’, ‘Paul’] 时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 提示：考虑使用zip()函数和range()函数 1234Iteration2.pyL = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]for index,name in zip(range(1,len(L)+1),L): print index,&apos;-&apos;,name 迭代dict的value我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。 如果我们希望迭代 dict 对象的value，应该怎么做？ dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个itervalues() 方法，用itervalues() 方法替代 values() 方法，迭代效果完全一样： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 任务给定一个dict： d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 请计算所有同学的平均分。 123456#Iteration3.pyd = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for i in d.itervalues(): sum = sum +iprint sum/len(d) 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。 首先，我们看看 dict 对象的 items() 方法返回的值： 123&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; print d.items()[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value： 123456&gt;&gt;&gt; for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 任务请根据dict： d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 打印出 name : score，最后再打印出平均分 average : score。 1234567#Iteration4.pyd = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for name,score in d.iteritems(): print name,&apos;:&apos;,score sum = sum + scoreprint &quot;average&quot;,&apos;:&apos;,sum/len(d)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 切片]]></title>
    <url>%2F2017%2F06%2F22%2Fpython-junior-7%2F</url>
    <content type="text"><![CDATA[对list进行切片取一个list的部分元素是非常常见的操作。比如，一个list如下： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 取前3个元素，应该怎么做？ 笨办法： 12&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 之所以是笨办法是因为扩展一下，取前N个元素就没辙了。 取前N个元素，也就是索引为0-(N-1)的元素，可以用循环： 1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 12&gt;&gt;&gt; L[0:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： 12&gt;&gt;&gt; L[1:3][&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个:，表示从头到尾： 12&gt;&gt;&gt; L[:][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。 切片操作还可以指定第三个参数： 12&gt;&gt;&gt; L[::2][&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 任务range()函数可以创建一个数列： 12&gt;&gt;&gt; range(1, 101)[1, 2, 3, ..., 100] 请利用切片，取出： 前10个数； 3的倍数； 不大于50的5的倍数。 12345#SliceQues1.pyL = range(1,101)print L[:10]print L[2::3]print L[4:51:5] 倒序切片对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 12345678910111213&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L[-2:][&apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L[:-2][&apos;Adam&apos;, &apos;Lisa&apos;]&gt;&gt;&gt; L[-3:-1][&apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L[-4:-1:2][&apos;Adam&apos;, &apos;Bart&apos;] 记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。 任务利用倒序切片对 1 - 100 的数列取出： * 最后10个数； * 最后10个5的倍数。 1234#SliceQues2.pyL = range(1,101)print L[-10:]print L[4::5][-10:] 对字符串切片字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 123456&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[-3:]&apos;EFG&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。 任务字符串有个方法 upper() 可以把字符变成大写字母： 12&gt;&gt;&gt; &apos;abc&apos;.upper()&apos;ABC&apos; 但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。 12345SliceQues3.pydef upperFirstChar(s): return s[:1].upper()+s[1:]print upperFirstChar(&apos;hello&apos;)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 函数]]></title>
    <url>%2F2017%2F06%2F22%2Fpython-junior-6%2F</url>
    <content type="text"><![CDATA[Python之什么是函数我们知道圆的面积计算公式为： 1S = πr² 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积： 123456r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 * r1 * r1s2 = 3.14 * r2 * r2s3 = 3.14 * r3 * r3 当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 x x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。 有了函数，我们就不再每次写s = 3.14 x x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle 本身只需要写一次，就可以多次调用。 抽象是数学中非常常见的概念。举个例子： 计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作： 123100∑nn=1 这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。 而且，这种抽象记法是可扩展的，比如： 123100∑(n²+1)n=1 还原成加法运算就变成了： 1(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1) 可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。 写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。 Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。 Python之调用函数Python内置了很多有用的函数，我们可以直接调用。 要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。 12可以直接从Python的官方网站查看文档：http://docs.python.org/2/library/functions.html#abs 也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。 调用 abs 函数： 123456&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： 1234&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： 1234&gt;&gt;&gt; abs(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): &apos;str&apos; 而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x==y，返回 0，如果 x&gt;y，返回 1： 123456&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0 Python内置的常用函数还包括数据类型转换函数，比如 int()函数可以把其他数据类型转换为整数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(12.34)12 str()函数把其他类型转换成 str： 1234&gt;&gt;&gt; str(123)&apos;123&apos;&gt;&gt;&gt; str(1.23)&apos;1.23&apos; Python之编写函数在Python中，定义一个函数要使用def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。 我们以自定义一个求绝对值的 my_abs 函数为例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。 return None可以简写为return。 Python函数之返回多值函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： # math包提供了sin()和 cos()函数，我们先用import引用它： 12345import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 这样我们就可以同时获得返回值： 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0) 用print打印返回结果，原来返回值是一个tuple！ 但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 Python之递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘 n! = 1 * 2 3 … * n，用函数 fact(n)表示，可以看出： 1fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n 所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一个递归函数。可以试试： 123456&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 任务汉诺塔 (http://baike.baidu.com/view/191666.htm) 的移动也可以看做是递归函数。 我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为： 如果a只有一个圆盘，可以直接移动到c； 如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。 请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤： move(n, a, b, c) 例如，输入 move(2, ‘A’, ‘B’, ‘C’)，打印出： A –&gt; BA –&gt; CB –&gt; C 12345678910#HanoiTower.pydef move(n,a,b,c): if n == 1: print a,&quot;--&gt;&quot;,c return move(n-1, a, c, b) print a,&quot;--&gt;&quot;,c move(n-1, b, c, a) move(4, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;); Python之定义默认参数定义函数的时候，还可以有默认参数。 例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(&apos;123&apos;, 8)83 int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。 可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。 我们来定义一个计算 x 的N次方的函数: 123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样一来，计算平方就不需要传入两个参数了： 12&gt;&gt;&gt; power(5)25 由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面： 123456# OK:def fn1(a, b=1, c=2): pass# Error:def fn2(a=1, b): pass 任务请定义一个 greet() 函数，它包含一个默认参数，如果没有传入，打印 ‘Hello, world.’，如果传入，打印 ‘Hello, xxx.’ 123456#VariableParams.pydef greet(a=&apos;world&apos;): print &apos;Hello,&apos;+a+&apos;.&apos; greet()greet(&apos;python&apos;) Python之定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： 12def fn(*args): print args 可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数： 12345678&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn(&apos;a&apos;)(&apos;a&apos;,)&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;b&apos;)&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数： 12def average(*args): ... 这样，在调用的时候，可以这样写： 123456&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4 任务请编写接受可变参数的 average() 函数。 12345678910111213#VariableParams.pydef average(*args): if len(args)==0: print 0 else: sum = 0.0 for s in args: sum = sum+s print sum/len(args) average()average(1,2)average(1,2,3,4)]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 Dict和Set类型]]></title>
    <url>%2F2017%2F06%2F18%2Fpython-junior-5%2F</url>
    <content type="text"><![CDATA[Python之什么是dict我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 或者考试的成绩列表： 1[95, 85, 59] 但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。 如果把名字和分数关联起来，组成类似的查找表： 123&apos;Adam&apos; ==&gt; 95&apos;Lisa&apos; ==&gt; 85&apos;Bart&apos; ==&gt; 59 给定一个名字，就可以直接查到分数。 Python的 dict 就是专门干这件事的。用 dict 表示“名字”-“成绩”的查找表如下： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。 花括号 {} 表示这是一个dict，然后按照key: value, 写出来即可。最后一个 key: value 的逗号可以省略。 由于dict也是集合，len() 函数可以计算任意集合的大小： 12&gt;&gt;&gt; len(d)3 注意: 一个 key-value 算一个，因此，dict大小为3。 Python之访问dict我们已经能创建一个dict，用于表示名字和成绩的对应关系： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 那么，如何根据名字来查找对应的成绩呢？ 可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key： 1234567&gt;&gt;&gt; print d[&apos;Adam&apos;]95&gt;&gt;&gt; print d[&apos;Paul&apos;]Traceback (most recent call last): File &quot;index.py&quot;, line 11, in &lt;module&gt; print d[&apos;Paul&apos;]KeyError: &apos;Paul&apos; 注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。 要避免 KeyError 发生，有两个办法： 一是先判断一下 key 是否存在，用 in 操作符： 12if &apos;Paul&apos; in d: print d[&apos;Paul&apos;] 如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。 二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None： 1234&gt;&gt;&gt; print d.get(&apos;Bart&apos;)59&gt;&gt;&gt; print d.get(&apos;Paul&apos;)None Python中dict的特点dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。 不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。 由于dict是按 key 查找，所以，在一个dict中，key不能重复。 dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 当我们试图打印这个dict时： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。 dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。 可以试试用list作为key时会报什么样的错误。 不可变这个限制仅作用于key，value是否可变无所谓： 12345&#123; &apos;123&apos;: [1, 2, 3], # key 是 str，value是list 123: &apos;123&apos;, # key 是 int，value 是 str (&apos;a&apos;, &apos;b&apos;): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean&#125; 最常用的key还是字符串，因为用起来最方便。 Python更新dictdict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 要把新同学’Paul’的成绩 72 加进去，用赋值语句： 1&gt;&gt;&gt; d[&apos;Paul&apos;] = 72 再看看dict的内容： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value： 123&gt;&gt;&gt; d[&apos;Bart&apos;] = 60&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 60&#125; Python之 遍历dict由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。 直接使用for循环可以遍历 dict 的 key： 1234567&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; for key in d:... print key... LisaAdamBart 由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。 Python中什么是setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。 有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。 set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。 创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： 1&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]) 可以查看 set 的内容： 12&gt;&gt;&gt; print sset([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;]) 请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。 因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？ 12345&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;C&apos;])&gt;&gt;&gt; print sset([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])&gt;&gt;&gt; len(s)3 结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。 Python之 访问set由于set存储的是无序集合，所以我们没法通过索引来访问。 访问 set中的某个元素实际上就是判断一个元素是否在set中。 例如，存储了班里同学名字的set： 1&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]) 我们可以用 in 操作符判断： Bart是该班的同学吗？ 12&gt;&gt;&gt; &apos;Bart&apos; in sTrue Bill是该班的同学吗？ 12&gt;&gt;&gt; &apos;Bill&apos; in sFalse bart是该班的同学吗？ 12&gt;&gt;&gt; &apos;bart&apos; in sFalse 看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。 Python之 set的特点set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。 set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。 最后，set存储的元素也是没有顺序的。 set的这些特点，可以应用在哪些地方呢？ 星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。 假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？ 可以用 if 语句判断，但这样做非常繁琐： 12345x = &apos;???&apos; # 用户输入的字符串if x!= &apos;MON&apos; and x!= &apos;TUE&apos; and x!= &apos;WED&apos; ... and x!= &apos;SUN&apos;: print &apos;input error&apos;else: print &apos;input ok&apos; 注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。 如果事先创建好一个set，包含’MON’ ~ ‘SUN’： 1weekdays = set([&apos;MON&apos;, &apos;TUE&apos;, &apos;WED&apos;, &apos;THU&apos;, &apos;FRI&apos;, &apos;SAT&apos;, &apos;SUN&apos;]) 再判断输入是否有效，只需要判断该字符串是否在set中： 12345x = &apos;???&apos; # 用户输入的字符串if x in weekdays: print &apos;input ok&apos;else: print &apos;input error&apos; 这样一来，代码就简单多了。 Python之 遍历set由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。 直接使用 for 循环可以遍历 set 的元素： 1234567&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;])&gt;&gt;&gt; for name in s:... print name... LisaAdamBart 注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。 Python之 更新set由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事： 一是把新的元素添加到set中，二是把已有元素从set中删除。 添加元素时，用set的add()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4]) 如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; print sset([1, 2, 3]) 删除set中的元素时，用set的remove()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3]) 如果删除的元素不存在set中，remove()会报错： 12345&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.remove(4)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 4 所以用add()可以直接添加，而remove()前需要判断。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 条件判断和循环]]></title>
    <url>%2F2017%2F06%2F18%2Fpython-junior-4%2F</url>
    <content type="text"><![CDATA[Python之if语句计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现： 12345age = 20if age &gt;= 18: print &apos;your age is&apos;, age print &apos;adult&apos;print &apos;END&apos; 注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。 缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。 注意: if 语句后接表达式，然后用:表示代码块开始。 如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车： 1234567&gt;&gt;&gt; age = 20&gt;&gt;&gt; if age &gt;= 18:... print &apos;your age is&apos;, age... print &apos;adult&apos;...your age is 20adult Python之 if-else当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块： 12if age &gt;= 18: print &apos;adult&apos; 如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，方法是再写一个 if: 12if age &lt; 18: print &apos;teenager&apos; 或者用 not 运算： 12if not age &gt;= 18: print &apos;teenager&apos; 这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if … else … 语句把它们统一起来： 1234if age &gt;= 18: print &apos;adult&apos;else: print &apos;teenager&apos; 利用 if … else … 语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。 注意: else 后面有个“:”。 Python之 if-elif-else有的时候，一个 if … else … 还不够用。比如，根据年龄的划分： 123条件1：18岁或以上：adult条件2：6岁或以上：teenager条件3：6岁以下：kid 我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3： 1234567if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: print &apos;kid&apos; 这样写出来，我们就得到了一个两层嵌套的 if … else … 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby： 12345678910if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: if age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; 这种缩进只会越来越多，代码也会越来越难看。 要避免嵌套结构的 if … else …，我们可以用 if … 多个elif … else … 的结构，一次写完所有的规则： 12345678if age &gt;= 18: print &apos;adult&apos;elif age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 3: print &apos;kid&apos;else: print &apos;baby&apos; elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。 特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。 Python之 for循环list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list： 1234L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]print L[0]print L[1]print L[2] 如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。 这时，循环就派上用场了。 Python的 for 循环就可以依次把list或tuple的每个元素迭代出来： 123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]for name in L: print name 注意: name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。 这样一来，遍历一个list或tuple就非常容易了。 Python之 while循环和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。 比如要从 0 开始打印不大于 N 的整数： 12345N = 10x = 0while x &lt; N: print x x = x + 1 while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。 在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。 如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。 Python之 break退出循环用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。 比如计算1至100的整数和，我们用while来实现： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。 Python之 continue继续循环在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。 假设我们已经写好了利用for循环计算平均分的代码： 1234567L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: sum = sum + x n = n + 1print sum / n 现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环： 12345for x in L: if x &lt; 60: continue sum = sum + x n = n + 1 Python之 多重循环在循环内部，还可以嵌套循环，我们来看一个例子： 123for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]: print x + y x 每循环一次，y 就会循环 3 次，这样，我们可以打印出一个全排列： A1A2A3B1B2B3C1C2C3]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 List和Tuple类型]]></title>
    <url>%2F2017%2F06%2F18%2Fpython-junior-3%2F</url>
    <content type="text"><![CDATA[Python创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。 构造list非常简单，按照上面的代码，直接用[ ]把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list： 123&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; classmates # 打印classmates变量的内容[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] 由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据： 1&gt;&gt;&gt; L = [&apos;Michael&apos;, 100, True] 一个元素也没有的list，就是空list： 1&gt;&gt;&gt; empty_list = [] Python按照索引访问list由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 通过索引来获取list中的指定元素。 需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。 因此，要打印第一名同学的名字，用 L[0]: 12&gt;&gt;&gt; print L[0]Adam 要打印第二名同学的名字，用 L[1]: 12&gt;&gt;&gt; print L[1]Lisa 要打印第三名同学的名字，用 L[2]: 12&gt;&gt;&gt; print L[2]Bart 要打印第四名同学的名字，用 L[3]: 1234&gt;&gt;&gt; print L[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。 所以，使用索引时，千万注意不要越界。 Python之倒序访问list我们还是用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 我们可以用 -1 这个索引来表示最后一个元素： 12&gt;&gt;&gt; print L[-1]Bart 类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示： 12345678&gt;&gt;&gt; print L[-2]Lisa&gt;&gt;&gt; print L[-3]Adam&gt;&gt;&gt; print L[-4]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。 使用倒序索引时，也要注意不要越界。 Python之添加新元素现在，班里有3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？ 第一个办法是用 list 的append()方法，把新同学追加到 list 的末尾： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.append(&apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] append()总是把新的元素添加到 list 的尾部。 如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？ 方法是用list的insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.insert(0, &apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Paul&apos;, &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。 Python从list删除元素我们怎么把Paul 从现有的list中删除呢？ 如果Paul同学排在最后一个，我们可以用list的pop()方法删除： 12345&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L.pop()&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。 如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;] 要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用pop(2)把Paul删掉： 1234&gt;&gt;&gt; L.pop(2)&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] Python中替换元素假设现在班里仍然是3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。 另一个办法是直接用Paul把Bart给替换掉： 123&gt;&gt;&gt; L[2] = &apos;Paul&apos;&gt;&gt;&gt; print LL = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;] 对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。 由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作： 1&gt;&gt;&gt; L[-1] = &apos;Paul&apos; Python之创建tupletuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。 同样是表示班里同学的名称，用tuple表示如下： 1&gt;&gt;&gt; t = (&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;) 创建tuple和创建list唯一不同之处是用( )替代了[ ]。 现在，这个t就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素。 1234&gt;&gt;&gt; t[0] = &apos;Paul&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment Python之创建单元素tupletuple和list一样，可以包含 0 个、1个和任意多个元素。 包含多个元素的 tuple，前面我们已经创建过了。 包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示： 123&gt;&gt;&gt; t = ()&gt;&gt;&gt; print t() 创建包含1个元素的 tuple 呢？来试试： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; print t1 好像哪里不对！t 不是 tuple ，而是整数1。 因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。 正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; print t(1,) Python在打印单元素tuple时，也自动添加了一个“,”，为了更明确地告诉你这是一个tuple。 多元素 tuple 加不加这个额外的“,”效果是一样的： 123&gt;&gt;&gt; t = (1, 2, 3,)&gt;&gt;&gt; print t(1, 2, 3) Python之“可变”的tuple前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple： 1&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;]) 注意到 t 有 3 个元素：‘a’，’b’和一个list：[‘A’, ‘B’]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到： 1&gt;&gt;&gt; L = t[2] 然后，我们把list的两个元素改一改： 12&gt;&gt;&gt; L[0] = &apos;X&apos;&gt;&gt;&gt; L[1] = &apos;Y&apos; 再看看tuple的内容： 12&gt;&gt;&gt; print t(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 不是说tuple一旦定义后就不可变了吗？怎么现在又变了？ 别急，我们先看看定义的时候tuple包含的3个元素： 当我们把list的元素‘A’和’B’修改为‘X’和’Y’后，tuple变为： 表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。 tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 Python中变量和数据类型]]></title>
    <url>%2F2017%2F06%2F17%2Fpython-junior-2%2F</url>
    <content type="text"><![CDATA[Python中数据类型计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种： 一、整数 Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 二、浮点数 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 三、字符串 字符串是以&#39;&#39;或&quot;&quot;括起来的任意文本，比如‘abc’，“xyz”等等。请注意，‘’或“”本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。 四、布尔值 布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为 True，and运算结果才是 True。 or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。 not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。 五、空值 空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 Python之print语句print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下： 1&gt;&gt;&gt; print &apos;hello, world&apos; print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出： 12&gt;&gt;&gt; print &apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;The quick brown fox jumps over the lazy dog print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的： print也可以打印整数，或者计算结果： 1234&gt;&gt;&gt; print 300300 #运行结果&gt;&gt;&gt; print 100 + 200300 #运行结果 因此，我们可以把计算100 + 200的结果打印得更漂亮一点： 12&gt;&gt;&gt; print &apos;100 + 200 =&apos;, 100 + 200100 + 200 = 300 #运行结果 Python的注释Python的注释以#开头，后面的文字直到行尾都算注释 12# 这一行全部都是注释...print &apos;hello&apos; # 这也是注释 Python中什么是变量在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如： 1a = 1 变量a是一个整数。 1t_007 = &apos;T007&apos; 变量t_007是一个字符串。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： 1234a = 123 # a是整数print aa = &apos;imooc&apos; # a变为字符串print a 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： 12int a = 123; // a是整数类型变量a = &quot;mooc&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 最后，理解变量在计算机内存中的表示也非常重要。当我们写：a = &#39;ABC&#39;时，Python解释器干了两件事情： 在内存中创建了一个&#39;ABC&#39;的字符串； 在内存中创建了一个名为a的变量，并把它指向&#39;ABC&#39;。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： 1234a = &apos;ABC&apos;b = aa = &apos;XYZ&apos;print b 最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事： 执行a = &#39;ABC&#39;，解释器创建了字符串 ‘ABC’和变量 a，并把a指向 ‘ABC’： 执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串’ABC’： 执行a = &#39;XYZ&#39;，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改： 所以，最后打印变量b的结果自然是&#39;ABC&#39;了。 Python中定义字符串字符串可以用&#39;&#39;或者&quot;&quot;括起来表示。 如果字符串本身包含&#39;怎么办？比如我们要表示字符串I&#39;m OK，这时，可以用&quot; &quot;括起来表示： 1&quot;I&apos;m OK&quot; 类似的，如果字符串包含&quot;，我们就可以用&#39; &#39;括起来表示： 1&apos;Learn &quot;Python&quot; in imooc&apos; 如果字符串既包含&#39;又包含&quot;，就需要对字符串的某些特殊字符进行“转义”，Python字符串用\进行转义。 要表示字符串 Bob said &quot;I&#39;m OK&quot;.由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 1&apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; 注意：转义字符 \ 不计入字符串的内容中。 常用的转义字符还有： 123\n 表示换行\t 表示一个制表符\\ 表示 \ 字符本身 Python中raw字符串与多行字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀r，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： 1r&apos;\(~_~)/ \(~_~)/&apos; 但是r&#39;...&#39;表示法不能表示多行字符串，也不能表示包含&#39;和 &quot;的字符串。 如果要表示多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： 123&apos;&apos;&apos;Line 1Line 2Line 3&apos;&apos;&apos; 上面这个字符串的表示方法和下面的是完全一样的： ‘Line 1\nLine 2\nLine 3’ 还可以在多行字符串前面添加r，把这个多行字符串也变成一个raw字符串： 123r&apos;&apos;&apos;Python is created by &quot;Guido&quot;.It is free and easy to learn.Let&apos;s start learn Python in imooc!&apos;&apos;&apos; Python中Unicode字符串Python在添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： 12print u&apos;中文&apos;中文 注意: 不加 u ，中文就不能正常显示。 Unicode字符串除了多了一个u之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效： 转义： 1u&apos;中文\n日文\n韩文&apos; 多行： 12u&apos;&apos;&apos;第一行第二行&apos;&apos;&apos; raw+多行： 123ur&apos;&apos;&apos;Python的Unicode字符串支持&quot;中文&quot;,&quot;日文&quot;,&quot;韩文&quot;等多种语言&apos;&apos;&apos; 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1# -*- coding: utf-8 -*- Python中整数和浮点数Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。 基本的运算： 1231 + 2 + 3 # ==&gt; 64 * 5 - 6 # ==&gt; 147.5 / 8 + 2.1 # ==&gt; 3.0375 使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层： 12(1 + 2) * 3 # ==&gt; 9(2.2 + 3.3) / (1.5 * (9 - 0.3)) # ==&gt; 0.42145593869731807 和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数： 121 + 2 # ==&gt; 整数 31.0 + 2.0 # ==&gt; 浮点数 3.0 但是整数和浮点数混合运算的结果就变成浮点数了： 11 + 2.0 # ==&gt; 浮点数 3.0 Python中布尔类型我们已经了解了Python支持布尔类型的数据，布尔类型只有True和False两种值，但是布尔类型有以下几种运算： 与运算：只有两个布尔值都为 True 时，计算结果才为 True。 1234True and True # ==&gt; TrueTrue and False # ==&gt; FalseFalse and True # ==&gt; FalseFalse and False # ==&gt; False 或运算：只要有一个布尔值为 True，计算结果就是 True。 1234True or True # ==&gt; TrueTrue or False # ==&gt; TrueFalse or True # ==&gt; TrueFalse or False # ==&gt; False 非运算：把True变为False，或者把False变为True： 12not True # ==&gt; Falsenot False # ==&gt; True 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： 12a = Trueprint a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串&#39;&#39;和None看成 False，其他数值和非空字符串都看成 True，所以： 12True and &apos;a=T&apos; 计算结果是 &apos;a=T&apos;继续计算 &apos;a=T&apos; or &apos;a=F&apos; 计算结果还是 &apos;a=T&apos; 要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 在计算a and b时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算a or b时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章 python基本配置]]></title>
    <url>%2F2017%2F06%2F17%2Fpython-junior-1%2F</url>
    <content type="text"><![CDATA[写在前面我是一个Android开发工程师，对于python也属于初学者，我希望通过记录笔记的方式记录我学习python的过程，对自己是一种整理与升华的过程，希望能够对其他python入门学习的开发者也能起到一点作用。 我的这套笔记中使用的python版本是python2.7，至于为什么不用python3，我觉得现在对于python2的教程更多一些，方便学习。另外我也属于第一次接触python，如果有哪里写的不对不严谨的地方，请您在评论区指正，我会虚心接受。 同时，如果你也对python开发感兴趣，不妨我们一起交流，互相学习，共同进步。 安装python通过安装包安装如果你想更新至最新的2.7.x或3.x版本，你可以直接从python官网下载二进制安装文件。 点击上面的链接，然后选择需要的版本。Python 2和3的最新版本就在页面的顶部。选择好Python版本之后，你就能看到针对不同操作系统的安装包下载链接了。 我建议你下载相应系统的安装器，因为它会处理好所有的安装事宜，只需要确保下载了自己电脑CPU架构（32位或64位）对应的文件即可。笔者下载的则是python2.7.13-Mac OS X 64-bit/32-bit installer。 双击安装器之后，只要按照提示操作，一路下一步，就可以顺利安装Python。 安装成功后，打开mac终端，输入python回车，然后就会出现安装的Python的版本信息。键入： 1&gt;&gt;&gt; print &apos;hello,Python!&apos; 输出如下图所示 mac配置Python集成开发环境（Eclipse +Python+Pydev) 下载Mac版64位的Eclipse。 进入到Eclipse官方网站的下载页面（http://www.eclipse.org/downloads/） 下载JDK以及安装 进入到java开发语言包JDK的官方下载页面（http://www.oracle.com/technetwork/java/javase/downloads/index.html） 下载后运行安装文件，按步骤安装jdk。因为本套教程不是讲解java开发，所以这里不详细介绍jdk的安装和配置了。在终端键入 java -version 出现以下jdk信息： 下载安装Pydev插件 打开eclipse，菜单栏Help-Install New Software… 打开页面后，1点击Add…，2输入Location值为“http://www.pydev.org/updates” ，name值任意。输入完成后点击ok按钮。 在install中选中第一项，然后点击next，一路next。同意它所有的申请。 配置eclipse的python开发环境 对eclipse进行设置，具体步骤如下图所示： 第一个python工程，步骤如下： 在src文件夹new file，输入文件名为hello.py，点击finish 在文件中输入如图所示的代码，然后执行，环境正常搭建完成。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python教程</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[博客我来啦！]]></content>
  </entry>
  <entry>
    <title><![CDATA[2016-2017 毕业1年总结]]></title>
    <url>%2F2017%2F05%2F28%2Fgraduation-1st%2F</url>
    <content type="text"><![CDATA[​ 自2016年6月本科毕业论文答辩之后正式离开学校，如今已经1年，本人Android攻城狮一枚，23岁，身处帝都，定位西二旗，互联网软件公司，这一年，经历的事情太多，本来要做一款App，但是实在是没有什么时间，算了，写几个字吧，算是对这一年的总结和回顾，同时也对下一年做一个准备。 ​ 先说说这一年的变化吧。 变化 这一年Android系统版本从Android6.0到7.0，前些日子又来了8.0。Google把之前挖的坑填平了一些，但是又继续挖了更多的坑。其实Google一向如此。 这一年电脑内存从4G升到6G升到12G，硬盘加固。 开发工具从Eclipse转向Android Studio，AS原来就是谷歌的巨坑，不过最近几个版本优化的十分不错，现在AS用的很溜。 开发语言目前主要还是Java，java能力我觉得可以从40%的水平提升到60%，前路漫漫，同时也涉猎html、js、jsp还有一些Java后台框架，还有Python也在不断学习中。对了，有一个事情不可不提，今年Google I/O大会竟然提出Kotlin，然后现在网上各种Kotlin将作为Android第一开发语言的言论铺天盖地而来，然后Kotlin官网就多了一句Now official on Android，我已是无力吐槽，我周围的人都在说学会了Kotlin万一把Java Api给整混乱就犯不上了。 认识的人也越多了，各种社交软件零零散散加起来应该多了两百多人吧。 薪资也有一丢丢提高，隐私就不说了。 不变的 这一年，我还是早上7点之前起床，不睡懒觉。 我用的还是那款手机，MI NOTE LTE。 依然还有一颗热爱生活、积极向上的心态。 总结一下 工作上 一入编程深似海啊，面对着每天至少8个小时的工作，也许8小时都是奢望，确实是充实。长时间的工作，成长贼快，面对如浩瀚汪洋般的Coding世界，只有不断学习，不断查阅资料，这点度娘不行，还得Google。话说起来柯洁0：3负于AlphaGo还是有点小小遗憾，不过我觉的就算再智能，也得加上“人工”两个字。 这一年主要负责和参与的企业级项目有7个，目前都在迭代，都可以在AppStore去下载玩玩看，大概修复缺陷和新增功能加一起大概500+个，你要知道每个人写的代码风格不尽相同，阅读别人的代码你都恨不得每行加上注释SB。最怕那种不谈什么底层原理、运行效率、算法优化什么的主，老夫Coding就是一把梭！真想一脚踹飞他！ 总的来说我觉的进步还是不小的，原来网上的一些慕课只来的还需去看视频，现在查阅一下资料就能懂，被人教会和主动学会的感觉是不一样的。我下一步的计划就是要教会别人。 生活中 这一年，我长了一岁，家人也老了一岁，希望家人都健健康康。想想从初中开始就没怎么陪伴过家人，现在是真的觉得应该时常陪在家人身边，家庭最重要！还是觉的小时候好，不是因为小时候的自己可以无忧无虑，而是小时候亲人都在，长大之后慢慢就会有亲人要离开我们。小时候真好。 这一年，我和她在一起第4个念头，这一年我们都在北京，我们基本走遍北京的所有景点，吃了很多美食。下一步我觉的还要发掘一些新的玩处，玩出水平。 说说我的工作吧 说说工作就不可避免的要谈到大学生活。 这一年，可以说是在为大学买单，大学不如名校，其实已经被人家落下了，如果你不够十二分的努力，那么就被拉的更远，不说别的，单单说基础编程能力，你以为你在大学如何如何，殊不知人家已经起飞，而自己还在跑道上滑行。这个时候就要付出更多努力，加大马力，同时还要掌握正确的方法方式，追上人家，超越不是随便讲出来的，但并不是不可能完成。 我不觉的我的第一份工作有多好，但是我把这个当作是充电与追赶的跳板。出身不好就要更加努力，基础打牢。 接下来的一年，我要系统学习其他几种编程语言还有一些其他的技术，目前来说应该是python和Java后台，同时要从架构和底层的角度多多考虑。 接下来的一年，我要用更多的时间陪伴家人和爱人。 接下来的一年，我要继续保持阳光的心态，保证健康的身体。 ​ 不求能成为榜样，但求能以自己的绵薄之力为社会、为家人、为他人做出那么一点点贡献。 ​ 好了，就写这么多了，端午的假期得早点睡！ ​ 2017年5月28日 夜 ​ 北京 昌平]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
</search>
